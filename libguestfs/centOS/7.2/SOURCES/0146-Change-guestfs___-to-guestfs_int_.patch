From 77bd645afd932a49e61d9ea204977d29a3557fc2 Mon Sep 17 00:00:00 2001
From: "Richard W.M. Jones" <rjones@redhat.com>
Date: Sat, 14 Feb 2015 15:14:48 +0000
Subject: [PATCH] Change guestfs___* to guestfs_int_*

libguestfs has used double and triple underscores in identifiers.
These aren't valid for global names in C++.

The first step is to replace all guestfs___* (3 underscores) with
guestfs_int_*.  We've used guestfs_int_* elsewhere already as a prefix
for internal identifiers.

This is an entirely mechanical change done using:
  git ls-files | xargs perl -pi.bak -e 's/guestfs___/guestfs_int_/g'

Reference: http://stackoverflow.com/a/228797

RHEL 7.2:

I did not cherry pick commit bfbcc01403ef99599568881aa9b3995d83859f05
for this.  Instead I ran the Perl command above on the RHEL 7.2 tree.
---
 align/scan.c                                  |  18 +-
 builder/index-validate.c                      |  18 +-
 cat/cat.c                                     |   8 +-
 cat/filesystems.c                             |  14 +-
 cat/log.c                                     |  20 +--
 cat/ls.c                                      |  12 +-
 cat/visit.c                                   |   4 +-
 daemon/proto.c                                |   2 +-
 df/df.c                                       |   4 +-
 df/domains.c                                  |  10 +-
 df/main.c                                     |  14 +-
 df/parallel.c                                 |   2 +-
 diff/diff.c                                   |  16 +-
 edit/edit.c                                   |  12 +-
 examples/guestfs-performance.pod              |   6 +-
 fish/config.c                                 |  10 +-
 fish/destpaths.c                              |   2 +-
 fish/fish.c                                   |  54 +++---
 fish/glob.c                                   |  16 +-
 fish/inspect.c                                |  16 +-
 fish/man.c                                    |   2 +-
 fish/options.c                                |  12 +-
 fish/options.h                                |   6 +-
 fish/uri.c                                    |  14 +-
 fish/windows.c                                |   4 +-
 format/format.c                               |  14 +-
 fuse/guestmount.c                             |  22 +--
 fuse/guestunmount.c                           |  16 +-
 fuse/test-guestmount-fd.c                     |  16 +-
 fuse/test-guestunmount-fd.c                   |   8 +-
 generator/c.ml                                |  60 +++----
 generator/erlang.ml                           |   6 +-
 generator/errnostring.ml                      |  16 +-
 generator/fish.ml                             |  16 +-
 generator/java.ml                             |   8 +-
 generator/lua.ml                              |   4 +-
 generator/ocaml.ml                            |  12 +-
 generator/perl.ml                             |   4 +-
 generator/python.ml                           |   4 +-
 generator/ruby.ml                             |   4 +-
 generator/types.ml                            |   2 +-
 generator/xdr.ml                              |   2 +-
 inspector/inspector.c                         |  38 ++--
 make-fs/make-fs.c                             |  28 +--
 mllib/uri-c.c                                 |   2 +-
 ocaml/guestfs-c.c                             |  10 +-
 p2v/config.c                                  |  16 +-
 p2v/conversion.c                              |   8 +-
 p2v/gui.c                                     |  24 +--
 p2v/kernel.c                                  |  34 ++--
 p2v/main.c                                    |  20 +--
 p2v/ssh.c                                     |  12 +-
 po-docs/ja.po                                 |   6 +-
 po-docs/libguestfs-docs.pot                   |   6 +-
 po-docs/uk.po                                 |  12 +-
 python/guestfs-py-byhand.c                    |   2 +-
 rescue/rescue.c                               |  22 +--
 src/actions-support.c                         |  10 +-
 src/alloc.c                                   |  14 +-
 src/appliance.c                               |  68 ++++----
 src/cleanup.c                                 |  26 +--
 src/command.c                                 |  52 +++---
 src/conn-socket.c                             |   8 +-
 src/create.c                                  |  36 ++--
 src/dbdump.c                                  |  20 +--
 src/drives.c                                  |  22 +--
 src/errors.c                                  |  36 ++--
 src/events.c                                  |   6 +-
 src/file.c                                    |  18 +-
 src/filearch.c                                |  22 +--
 src/fuse.c                                    |  20 +--
 src/guestfs-internal-frontend.h               | 110 ++++++------
 src/guestfs-internal.h                        | 242 +++++++++++++-------------
 src/guid.c                                    |   2 +-
 src/handle.c                                  |  50 +++---
 src/info.c                                    |  46 ++---
 src/inspect-apps.c                            |  12 +-
 src/inspect-fs-cd.c                           |  64 +++----
 src/inspect-fs-unix.c                         | 112 ++++++------
 src/inspect-fs-windows.c                      |  26 +--
 src/inspect-fs.c                              |  66 +++----
 src/inspect-icon.c                            |  52 +++---
 src/inspect.c                                 |  64 +++----
 src/journal.c                                 |   2 +-
 src/launch-direct.c                           | 130 +++++++-------
 src/launch-libvirt.c                          |  96 +++++-----
 src/launch-uml.c                              |  48 ++---
 src/launch-unix.c                             |  10 +-
 src/launch.c                                  |  24 +--
 src/libvirt-auth.c                            |   8 +-
 src/libvirt-domain.c                          |  14 +-
 src/listfs.c                                  |  12 +-
 src/lpj.c                                     |  24 +--
 src/match.c                                   |  12 +-
 src/osinfo.c                                  |   6 +-
 src/proto.c                                   |  78 ++++-----
 src/stringsbuf.c                              |  20 +--
 src/test-utils.c                              |  80 ++++-----
 src/tmpdirs.c                                 |  20 +--
 src/utils.c                                   |  26 +--
 tests/c-api/test-backend-settings.c           |   6 +-
 tests/charsets/test-charset-fidelity.c        |  14 +-
 tests/mount-local/test-parallel-mount-local.c |   8 +-
 tests/parallel/test-parallel.c                |   4 +-
 tests/qemu/qemu-boot.c                        |  20 +--
 tests/qemu/qemu-speed-test.c                  |  18 +-
 tests/regressions/rhbz790721.c                |   4 +-
 tests/regressions/rhbz914931.c                |   4 +-
 v2v/utils-c.c                                 |   2 +-
 109 files changed, 1322 insertions(+), 1322 deletions(-)

diff --git a/align/scan.c b/align/scan.c
index 4740581..3b50a75 100644
--- a/align/scan.c
+++ b/align/scan.c
@@ -71,7 +71,7 @@ usage (int status)
 {
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   else {
     fprintf (stdout,
            _("%s: check alignment of virtual machine partitions\n"
@@ -91,8 +91,8 @@ usage (int status)
              "  -V|--version         Display version and exit\n"
              "  -x                   Trace libguestfs API calls\n"
              "For more information, see the manpage %s(1).\n"),
-             guestfs___program_name, guestfs___program_name, guestfs___program_name,
-             guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name,
+             guestfs_int_program_name);
   }
   exit (status);
 }
@@ -149,7 +149,7 @@ main (int argc, char *argv[])
         uuid = 1;
       } else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -168,7 +168,7 @@ main (int argc, char *argv[])
 
     case 'P':
       if (sscanf (optarg, "%zu", &max_threads) != 1) {
-        fprintf (stderr, _("%s: -P option is not numeric\n"), guestfs___program_name);
+        fprintf (stderr, _("%s: -P option is not numeric\n"), guestfs_int_program_name);
         exit (EXIT_FAILURE);
       }
       break;
@@ -226,13 +226,13 @@ main (int argc, char *argv[])
       exit (EXIT_FAILURE);
 #else
     fprintf (stderr, _("%s: compiled without support for libvirt.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
 #endif
   } else {                      /* Single guest. */
     if (uuid) {
       fprintf (stderr, _("%s: --uuid option cannot be used with -a or -d\n"),
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
 
@@ -350,7 +350,7 @@ scan (guestfs_h *g, const char *prefix, FILE *fp)
 static int
 scan_work (guestfs_h *g, size_t i, FILE *fp)
 {
-  struct guestfs___add_libvirt_dom_argv optargs;
+  struct guestfs_int_add_libvirt_dom_argv optargs;
 
   optargs.bitmask =
     GUESTFS___ADD_LIBVIRT_DOM_READONLY_BITMASK |
@@ -358,7 +358,7 @@ scan_work (guestfs_h *g, size_t i, FILE *fp)
   optargs.readonly = 1;
   optargs.readonlydisk = "read";
 
-  if (guestfs___add_libvirt_dom (g, domains[i].dom, &optargs) == -1)
+  if (guestfs_int_add_libvirt_dom (g, domains[i].dom, &optargs) == -1)
     return -1;
 
   if (guestfs_launch (g) == -1)
diff --git a/builder/index-validate.c b/builder/index-validate.c
index 0628a6f..5bb5a2a 100644
--- a/builder/index-validate.c
+++ b/builder/index-validate.c
@@ -39,7 +39,7 @@ extern int do_parse (struct parse_context *context, FILE *in);
 static void
 usage (int exit_status)
 {
-  printf ("%s index\n", guestfs___program_name);
+  printf ("%s index\n", guestfs_int_program_name);
   exit (exit_status);
 }
 
@@ -83,7 +83,7 @@ main (int argc, char *argv[])
         compat_1_24_1 = 1;
       else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -115,20 +115,20 @@ main (int argc, char *argv[])
 
   if (fclose (in) == EOF) {
     fprintf (stderr, _("%s: %s: error closing input file: %m (ignored)\n"),
-             guestfs___program_name, input);
+             guestfs_int_program_name, input);
   }
 
   if (ret != 0) {
     parse_context_free (&context);
     fprintf (stderr, _("%s: '%s' could not be validated, see errors above\n"),
-             guestfs___program_name, input);
+             guestfs_int_program_name, input);
     exit (EXIT_FAILURE);
   }
 
   if (compat_1_24_1 && context.seen_comments) {
     parse_context_free (&context);
     fprintf (stderr, _("%s: %s contains comments which will not work with virt-builder 1.24.1\n"),
-             guestfs___program_name, input);
+             guestfs_int_program_name, input);
     exit (EXIT_FAILURE);
   }
 
@@ -141,7 +141,7 @@ main (int argc, char *argv[])
       if (strchr (sections->name, '_')) {
         parse_context_free (&context);
         fprintf (stderr, _("%s: %s: section [%s] has invalid characters which will not work with virt-builder 1.24.0\n"),
-                 guestfs___program_name, input, sections->name);
+                 guestfs_int_program_name, input, sections->name);
         exit (EXIT_FAILURE);
       }
     }
@@ -152,7 +152,7 @@ main (int argc, char *argv[])
             strchr (fields->key, ']')) {
           parse_context_free (&context);
           fprintf (stderr, _("%s: %s: section [%s], field '%s' has invalid characters which will not work with virt-builder 1.24.0\n"),
-                   guestfs___program_name, input, sections->name, fields->key);
+                   guestfs_int_program_name, input, sections->name, fields->key);
           exit (EXIT_FAILURE);
         }
       }
@@ -161,7 +161,7 @@ main (int argc, char *argv[])
             strchr (fields->key, ',')) {
           parse_context_free (&context);
           fprintf (stderr, _("%s: %s: section [%s], field '%s' has invalid characters which will not work with virt-builder 1.24.1\n"),
-                   guestfs___program_name, input, sections->name, fields->key);
+                   guestfs_int_program_name, input, sections->name, fields->key);
           exit (EXIT_FAILURE);
         }
       }
@@ -172,7 +172,7 @@ main (int argc, char *argv[])
     if (compat_1_24_0 && !seen_sig) {
       parse_context_free (&context);
       fprintf (stderr, _("%s: %s: section [%s] is missing a 'sig' field which will not work with virt-builder 1.24.0\n"),
-               guestfs___program_name, input, sections->name);
+               guestfs_int_program_name, input, sections->name);
       exit (EXIT_FAILURE);
     }
   }
diff --git a/cat/cat.c b/cat/cat.c
index a9de790..cb4bc43 100644
--- a/cat/cat.c
+++ b/cat/cat.c
@@ -51,7 +51,7 @@ usage (int status)
 {
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   else {
     fprintf (stdout,
            _("%s: display files in a virtual machine\n"
@@ -73,8 +73,8 @@ usage (int status)
              "  -V|--version         Display version and exit\n"
              "  -x                   Trace libguestfs API calls\n"
              "For more information, see the manpage %s(1).\n"),
-             guestfs___program_name, guestfs___program_name, guestfs___program_name,
-             guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name,
+             guestfs_int_program_name);
   }
   exit (status);
 }
@@ -136,7 +136,7 @@ main (int argc, char *argv[])
         OPTION_format;
       } else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
diff --git a/cat/filesystems.c b/cat/filesystems.c
index 19b494e..73628ac 100644
--- a/cat/filesystems.c
+++ b/cat/filesystems.c
@@ -85,7 +85,7 @@ usage (int status)
 {
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   else {
     fprintf (stdout,
            _("%s: list filesystems, partitions, block devices, LVM in a VM\n"
@@ -122,8 +122,8 @@ usage (int status)
              "                       Display LVM volume groups\n"
              "  -x                   Trace libguestfs API calls\n"
              "For more information, see the manpage %s(1).\n"),
-             guestfs___program_name, guestfs___program_name, guestfs___program_name,
-             guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name,
+             guestfs_int_program_name);
   }
   exit (status);
 }
@@ -237,7 +237,7 @@ main (int argc, char *argv[])
         output |= OUTPUT_VGS;
       } else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -301,7 +301,7 @@ main (int argc, char *argv[])
    */
   if (human && csv) {
     fprintf (stderr, _("%s: you cannot use -h and --csv options together.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
@@ -808,7 +808,7 @@ parents_of_vg (char *vg)
   if (!pvuuids)
     exit (EXIT_FAILURE);
 
-  n = guestfs___count_strings (pvuuids);
+  n = guestfs_int_count_strings (pvuuids);
 
   ret = malloc ((n + 1) * sizeof (char *));
   if (!ret) {
@@ -889,7 +889,7 @@ write_row (const char *name, const char *type,
   }
   if ((columns & COLUMN_PARENTS)) {
     /* Internally comma-separated field. */
-    parents_str = guestfs___join_strings (",", parents);
+    parents_str = guestfs_int_join_strings (",", parents);
     strings[len++] = parents_str;
   }
   if ((columns & COLUMN_UUID))
diff --git a/cat/log.c b/cat/log.c
index 7c2595b..fa6dbde 100644
--- a/cat/log.c
+++ b/cat/log.c
@@ -60,7 +60,7 @@ usage (int status)
 {
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   else {
     fprintf (stdout,
            _("%s: display log files in a virtual machine\n"
@@ -80,8 +80,8 @@ usage (int status)
              "  -V|--version         Display version and exit\n"
              "  -x                   Trace libguestfs API calls\n"
              "For more information, see the manpage %s(1).\n"),
-             guestfs___program_name, guestfs___program_name, guestfs___program_name,
-             guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name,
+             guestfs_int_program_name);
   }
   exit (status);
 }
@@ -138,7 +138,7 @@ main (int argc, char *argv[])
         OPTION_format;
       } else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -241,7 +241,7 @@ do_log (void)
 
     fprintf (stderr,
              _("%s: Windows Event Log for pre-Vista guests is not supported.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     return -1;
   }
 
@@ -349,7 +349,7 @@ do_log_journal (void)
       if (strftime (buf, sizeof buf, "%b %d %H:%M:%S",
                     localtime_r (&t, &tm)) <= 0) {
         fprintf (stderr, _("%s: could not format journal entry timestamp\n"),
-                 guestfs___program_name);
+                 guestfs_int_program_name);
         errors++;
         continue;
       }
@@ -418,7 +418,7 @@ do_log_windows_evtx (void)
                        "in order to parse Windows Event Logs.  If you cannot install this, then\n"
                        "use virt-copy-out(1) to copy the contents of /Windows/System32/winevt/Logs\n"
                        "from this guest, and examine in a binary file viewer.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     return -1;
   }
 
@@ -434,7 +434,7 @@ do_log_windows_evtx (void)
                             GUESTFS_IS_FILE_OPTS_FOLLOWSYMLINKS, 1,
                             -1) <= 0) {
     fprintf (stderr, _("%s: Windows Event Log file (%s) not found\n"),
-             guestfs___program_name, filename);
+             guestfs_int_program_name, filename);
     return -1;
   }
 
@@ -466,8 +466,8 @@ do_log_windows_evtx (void)
   if (status) {
     char buf[256];
     fprintf (stderr, "%s: %s\n",
-             guestfs___program_name,
-             guestfs___exit_status_to_string (status, "evtxdump.py",
+             guestfs_int_program_name,
+             guestfs_int_exit_status_to_string (status, "evtxdump.py",
                                               buf, sizeof buf));
     return -1;
   }
diff --git a/cat/ls.c b/cat/ls.c
index 8d7dfc9..fe4c4c0 100644
--- a/cat/ls.c
+++ b/cat/ls.c
@@ -81,7 +81,7 @@ usage (int status)
 {
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   else {
     fprintf (stdout,
            _("%s: list files in a virtual machine\n"
@@ -114,8 +114,8 @@ usage (int status)
              "  -V|--version         Display version and exit\n"
              "  -x                   Trace libguestfs API calls\n"
              "For more information, see the manpage %s(1).\n"),
-             guestfs___program_name, guestfs___program_name, guestfs___program_name,
-             guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name,
+             guestfs_int_program_name);
   }
   exit (status);
 }
@@ -226,7 +226,7 @@ main (int argc, char *argv[])
         enable_uids = 1;
       } else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -332,7 +332,7 @@ main (int argc, char *argv[])
       (csv || human || enable_uids || enable_times || enable_extra_stats ||
        checksum)) {
     fprintf (stderr, _("%s: used a flag which can only be combined with -lR mode\nFor more information, read the virt-ls(1) man page.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
@@ -341,7 +341,7 @@ main (int argc, char *argv[])
    */
   if (human && csv) {
     fprintf (stderr, _("%s: you cannot use -h and --csv options together.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
diff --git a/cat/visit.c b/cat/visit.c
index 8588f31..2d474f1 100644
--- a/cat/visit.c
+++ b/cat/visit.c
@@ -100,7 +100,7 @@ _visit (guestfs_h *g, int depth, const char *dir,
 
     if (xattrs->val[xattrp].attrval_len == 0) {
       fprintf (stderr, _("%s: error getting extended attrs for %s %s\n"),
-               guestfs___program_name, dir, names[i]);
+               guestfs_int_program_name, dir, names[i]);
       return -1;
     }
     /* attrval is not \0-terminated. */
@@ -110,7 +110,7 @@ _visit (guestfs_h *g, int depth, const char *dir,
     attrval[xattrs->val[xattrp].attrval_len] = '\0';
     if (sscanf (attrval, "%zu", &nr_xattrs) != 1) {
       fprintf (stderr, _("%s: error: cannot parse xattr count for %s %s\n"),
-               guestfs___program_name, dir, names[i]);
+               guestfs_int_program_name, dir, names[i]);
       return -1;
     }
 
diff --git a/daemon/proto.c b/daemon/proto.c
index c9de36d..a257648 100644
--- a/daemon/proto.c
+++ b/daemon/proto.c
@@ -309,7 +309,7 @@ send_error (int errnum, char *msg)
    * to (char *) because they are defined that way in the XDR structs.
    */
   err.errno_string =
-    (char *) (errnum > 0 ? guestfs___errno_to_string (errnum) : "");
+    (char *) (errnum > 0 ? guestfs_int_errno_to_string (errnum) : "");
   err.error_message = (char *) msg;
 
   if (!xdr_guestfs_message_error (&xdr, &err)) {
diff --git a/df/df.c b/df/df.c
index 0dcf1c9..56df3cb 100644
--- a/df/df.c
+++ b/df/df.c
@@ -92,7 +92,7 @@ df_on_handle (guestfs_h *g, const char *name, const char *uuid, FILE *fp)
 int
 df_work (guestfs_h *g, size_t i, FILE *fp)
 {
-  struct guestfs___add_libvirt_dom_argv optargs;
+  struct guestfs_int_add_libvirt_dom_argv optargs;
 
   optargs.bitmask =
     GUESTFS___ADD_LIBVIRT_DOM_READONLY_BITMASK |
@@ -101,7 +101,7 @@ df_work (guestfs_h *g, size_t i, FILE *fp)
   optargs.readonlydisk = "read";
 
   /* Traditionally we have ignored errors from adding disks in virt-df. */
-  if (guestfs___add_libvirt_dom (g, domains[i].dom, &optargs) == -1)
+  if (guestfs_int_add_libvirt_dom (g, domains[i].dom, &optargs) == -1)
     return 0;
 
   if (guestfs_launch (g) == -1)
diff --git a/df/domains.c b/df/domains.c
index 8943ebc..da488a5 100644
--- a/df/domains.c
+++ b/df/domains.c
@@ -82,7 +82,7 @@ get_all_libvirt_domains (const char *libvirt_uri)
     err = virGetLastError ();
     fprintf (stderr,
              _("%s: could not connect to libvirt (code %d, domain %d): %s\n"),
-             guestfs___program_name, err->code, err->domain, err->message);
+             guestfs_int_program_name, err->code, err->domain, err->message);
     exit (EXIT_FAILURE);
   }
 
@@ -91,7 +91,7 @@ get_all_libvirt_domains (const char *libvirt_uri)
     err = virGetLastError ();
     fprintf (stderr,
              _("%s: could not get number of running domains (code %d, domain %d): %s\n"),
-             guestfs___program_name, err->code, err->domain, err->message);
+             guestfs_int_program_name, err->code, err->domain, err->message);
     exit (EXIT_FAILURE);
   }
 
@@ -101,7 +101,7 @@ get_all_libvirt_domains (const char *libvirt_uri)
     err = virGetLastError ();
     fprintf (stderr,
              _("%s: could not list running domains (code %d, domain %d): %s\n"),
-             guestfs___program_name, err->code, err->domain, err->message);
+             guestfs_int_program_name, err->code, err->domain, err->message);
     exit (EXIT_FAILURE);
   }
 
@@ -112,7 +112,7 @@ get_all_libvirt_domains (const char *libvirt_uri)
     err = virGetLastError ();
     fprintf (stderr,
              _("%s: could not get number of inactive domains (code %d, domain %d): %s\n"),
-             guestfs___program_name, err->code, err->domain, err->message);
+             guestfs_int_program_name, err->code, err->domain, err->message);
     exit (EXIT_FAILURE);
   }
 
@@ -122,7 +122,7 @@ get_all_libvirt_domains (const char *libvirt_uri)
     err = virGetLastError ();
     fprintf (stderr,
              _("%s: could not list inactive domains (code %d, domain %d): %s\n"),
-             guestfs___program_name, err->code, err->domain, err->message);
+             guestfs_int_program_name, err->code, err->domain, err->message);
     exit (EXIT_FAILURE);
   }
 
diff --git a/df/main.c b/df/main.c
index fef1006..c036617 100644
--- a/df/main.c
+++ b/df/main.c
@@ -64,7 +64,7 @@ usage (int status)
 {
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   else {
     fprintf (stdout,
            _("%s: display free space on virtual filesystems\n"
@@ -88,8 +88,8 @@ usage (int status)
              "  -V|--version         Display version and exit\n"
              "  -x                   Trace libguestfs API calls\n"
              "For more information, see the manpage %s(1).\n"),
-             guestfs___program_name, guestfs___program_name, guestfs___program_name,
-             guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name,
+             guestfs_int_program_name);
   }
   exit (status);
 }
@@ -153,7 +153,7 @@ main (int argc, char *argv[])
         uuid = 1;
       } else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -180,7 +180,7 @@ main (int argc, char *argv[])
 
     case 'P':
       if (sscanf (optarg, "%zu", &max_threads) != 1) {
-        fprintf (stderr, _("%s: -P option is not numeric\n"), guestfs___program_name);
+        fprintf (stderr, _("%s: -P option is not numeric\n"), guestfs_int_program_name);
         exit (EXIT_FAILURE);
       }
       break;
@@ -260,7 +260,7 @@ main (int argc, char *argv[])
    */
   if (human && csv) {
     fprintf (stderr, _("%s: you cannot use -h and --csv options together.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
@@ -277,7 +277,7 @@ main (int argc, char *argv[])
     free_domains ();
 #else
     fprintf (stderr, _("%s: compiled without support for libvirt.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
 #endif
   }
diff --git a/df/parallel.c b/df/parallel.c
index f7a628b..fe6d144 100644
--- a/df/parallel.c
+++ b/df/parallel.c
@@ -259,7 +259,7 @@ worker_thread (void *thread_data_vp)
 static void
 thread_failure (const char *fn, int err)
 {
-  fprintf (stderr, "%s: %s: %s\n", guestfs___program_name, fn, strerror (err));
+  fprintf (stderr, "%s: %s: %s\n", guestfs_int_program_name, fn, strerror (err));
 }
 
 #endif /* HAVE_LIBVIRT */
diff --git a/diff/diff.c b/diff/diff.c
index 304ce84..fc7a828 100644
--- a/diff/diff.c
+++ b/diff/diff.c
@@ -89,7 +89,7 @@ usage (int status)
 {
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   else {
     fprintf (stdout,
            _("%s: list differences between virtual machines\n"
@@ -125,8 +125,8 @@ usage (int status)
              "  -x                   Trace libguestfs API calls\n"
              "  --xattrs             Display extended attributes\n"
              "For more information, see the manpage %s(1).\n"),
-             guestfs___program_name, guestfs___program_name, guestfs___program_name,
-             guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name,
+             guestfs_int_program_name);
   }
   exit (status);
 }
@@ -258,7 +258,7 @@ main (int argc, char *argv[])
         enable_xattrs = 1;
       } else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -315,7 +315,7 @@ main (int argc, char *argv[])
   if (drvs == NULL || drvs2 == NULL) {
     fprintf (stderr,
              _("%s: you must specify some -a|-A|-d|-D options, see %s(1)\n"),
-             guestfs___program_name, guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name);
     usage (EXIT_FAILURE);
   }
 
@@ -324,13 +324,13 @@ main (int argc, char *argv[])
    */
   if (human && csv) {
     fprintf (stderr, _("%s: you cannot use -h and --csv options together.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
   if (optind != argc) {
     fprintf (stderr, _("%s: extra arguments on the command line\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     usage (EXIT_FAILURE);
   }
 
@@ -737,7 +737,7 @@ diff (struct file *file1, guestfs_h *g1, struct file *file2, guestfs_h *g2)
     fprintf (stderr, "%s\n", cmd);
   r = system (cmd);
   if (!WIFEXITED (r) || WEXITSTATUS (r) != 0) {
-    fprintf (stderr, _("%s: external diff command failed\n"), guestfs___program_name);
+    fprintf (stderr, _("%s: external diff command failed\n"), guestfs_int_program_name);
     goto out;
   }
 
diff --git a/edit/edit.c b/edit/edit.c
index cc88eb1..1424960 100644
--- a/edit/edit.c
+++ b/edit/edit.c
@@ -61,7 +61,7 @@ usage (int status)
 {
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   else {
     fprintf (stdout,
            _("%s: Edit a file in a virtual machine\n"
@@ -85,8 +85,8 @@ usage (int status)
              "  -V|--version         Display version and exit\n"
              "  -x                   Trace libguestfs API calls\n"
              "For more information, see the manpage %s(1).\n"),
-             guestfs___program_name, guestfs___program_name, guestfs___program_name,
-             guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name,
+             guestfs_int_program_name);
   }
   exit (status);
 }
@@ -153,7 +153,7 @@ main (int argc, char *argv[])
         OPTION_format;
       } else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -165,7 +165,7 @@ main (int argc, char *argv[])
     case 'b':
       if (backup_extension) {
         fprintf (stderr, _("%s: -b option given multiple times\n"),
-                 guestfs___program_name);
+                 guestfs_int_program_name);
         exit (EXIT_FAILURE);
       }
       backup_extension = optarg;
@@ -182,7 +182,7 @@ main (int argc, char *argv[])
     case 'e':
       if (perl_expr) {
         fprintf (stderr, _("%s: -e option given multiple times\n"),
-                 guestfs___program_name);
+                 guestfs_int_program_name);
         exit (EXIT_FAILURE);
       }
       perl_expr = optarg;
diff --git a/examples/guestfs-performance.pod b/examples/guestfs-performance.pod
index 8f395f6..86f35a1 100644
--- a/examples/guestfs-performance.pod
+++ b/examples/guestfs-performance.pod
@@ -496,9 +496,9 @@ example:
  xxxx (+0):	guestfs_create 
  xxxx (+29):	guestfs_set_pgroup g=0x17a9de0 pgroup=0x1
  xxxx (+9):	guestfs_add_drive_opts_argv g=0x17a9de0 [...]
- xxxx (+8):	guestfs___safe_strdup g=0x17a9de0 str=0x7f8a153bed5d
- xxxx (+19):	guestfs___safe_malloc g=0x17a9de0 nbytes=0x38
- xxxx (+5):	guestfs___safe_strdup g=0x17a9de0 str=0x17a9f60
+ xxxx (+8):	guestfs_int_safe_strdup g=0x17a9de0 str=0x7f8a153bed5d
+ xxxx (+19):	guestfs_int_safe_malloc g=0x17a9de0 nbytes=0x38
+ xxxx (+5):	guestfs_int_safe_strdup g=0x17a9de0 str=0x17a9f60
  xxxx (+10):	guestfs_launch g=0x17a9de0
  xxxx (+4):	launch_start 
  [etc]
diff --git a/fish/config.c b/fish/config.c
index cec0ae3..51014bf 100644
--- a/fish/config.c
+++ b/fish/config.c
@@ -57,13 +57,13 @@ read_config_from_file (const char *filename)
     /*
     if (verbose)
       fprintf (stderr, "%s: reading configuration from %s\n",
-               guestfs___program_name, filename);
+               guestfs_int_program_name, filename);
     */
 
     if (config_read (&conf, fp) == CONFIG_FALSE) {
       fprintf (stderr,
                _("%s: %s: line %d: error parsing configuration file: %s\n"),
-               guestfs___program_name, filename, config_error_line (&conf),
+               guestfs_int_program_name, filename, config_error_line (&conf),
                config_error_text (&conf));
       exit (EXIT_FAILURE);
     }
@@ -95,8 +95,8 @@ parse_config (void)
 
     xdg_env = getenv ("XDG_CONFIG_DIRS");
     var = xdg_env != NULL && xdg_env[0] != 0 ? xdg_env : "/etc/xdg";
-    xdg_config_dirs = guestfs___split_string (':', var);
-    xdg_config_dirs_count = guestfs___count_strings (xdg_config_dirs);
+    xdg_config_dirs = guestfs_int_split_string (':', var);
+    xdg_config_dirs_count = guestfs_int_count_strings (xdg_config_dirs);
     for (size_t i = xdg_config_dirs_count; i > 0; --i) {
       CLEANUP_FREE char *path = NULL;
       const char *dir = xdg_config_dirs[i - 1];
@@ -165,7 +165,7 @@ parse_config (void)
   if (verbose)
     fprintf (stderr,
              _("%s: compiled without libconfig, guestfish configuration file ignored\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   */
 }
 
diff --git a/fish/destpaths.c b/fish/destpaths.c
index df1ec00..6b95e2e 100644
--- a/fish/destpaths.c
+++ b/fish/destpaths.c
@@ -108,7 +108,7 @@ complete_dest_paths_generator (const char *text, int state)
   do {									\
     if (strs) {								\
       size_t i;								\
-      size_t n = guestfs___count_strings (strs);                        \
+      size_t n = guestfs_int_count_strings (strs);                        \
                                                                         \
       if ( n > 0 && ! xalloc_oversized (nr_words + n, sizeof (struct word))) { \
         struct word *w;							\
diff --git a/fish/fish.c b/fish/fish.c
index db68804..0a381d3 100644
--- a/fish/fish.c
+++ b/fish/fish.c
@@ -103,7 +103,7 @@ usage (int status)
 {
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   else {
     fprintf (stdout,
            _("%s: guest filesystem shell\n"
@@ -152,9 +152,9 @@ usage (int status)
              "run again without -i and use 'run' + 'list-filesystems' + 'mount' cmds.\n"
              "\n"
              "For more information, see the manpage %s(1).\n"),
-             guestfs___program_name, guestfs___program_name, guestfs___program_name,
-             guestfs___program_name, guestfs___program_name, guestfs___program_name,
-             guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name,
+             guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name,
+             guestfs_int_program_name);
   }
   exit (status);
 }
@@ -251,7 +251,7 @@ main (int argc, char *argv[])
         if (optarg) {
           if (sscanf (optarg, "%d", &remote_control) != 1) {
             fprintf (stderr, _("%s: --listen=PID: PID was not a number: %s\n"),
-                     guestfs___program_name, optarg);
+                     guestfs_int_program_name, optarg);
             exit (EXIT_FAILURE);
           }
         } else {
@@ -259,7 +259,7 @@ main (int argc, char *argv[])
           if (!p || sscanf (p, "%d", &remote_control) != 1) {
             fprintf (stderr, _("%s: remote: $GUESTFISH_PID must be set"
                                " to the PID of the remote process\n"),
-                     guestfs___program_name);
+                     guestfs_int_program_name);
             exit (EXIT_FAILURE);
           }
         }
@@ -289,7 +289,7 @@ main (int argc, char *argv[])
         complete_dest_paths = 0;
       } else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -308,14 +308,14 @@ main (int argc, char *argv[])
 
     case 'D':
       fprintf (stderr, _("%s: warning: -D option is deprecated, use --no-dest-paths instead\n"),
-               guestfs___program_name);
+               guestfs_int_program_name);
       complete_dest_paths = 0;
       break;
 
     case 'f':
       if (file) {
         fprintf (stderr, _("%s: only one -f parameter can be given\n"),
-                 guestfs___program_name);
+                 guestfs_int_program_name);
         exit (EXIT_FAILURE);
       }
       file = optarg;
@@ -512,7 +512,7 @@ main (int argc, char *argv[])
   if (remote_control_listen && remote_control) {
     fprintf (stderr,
              _("%s: cannot use --listen and --remote options at the same time\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
@@ -520,13 +520,13 @@ main (int argc, char *argv[])
     if (optind < argc) {
       fprintf (stderr,
                _("%s: extra parameters on the command line with --listen flag\n"),
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
     if (file) {
       fprintf (stderr,
                _("%s: cannot use --listen and --file options at the same time\n"),
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
     rc_listen ();
@@ -859,7 +859,7 @@ parse_command_line (char *buf, int *exit_on_error_rtn)
       if (p[len+1] && (p[len+1] != ' ' && p[len+1] != '\t')) {
         fprintf (stderr,
                  _("%s: command arguments not separated by whitespace\n"),
-                 guestfs___program_name);
+                 guestfs_int_program_name);
         pcmd.status = -1;
         return pcmd;
       }
@@ -868,14 +868,14 @@ parse_command_line (char *buf, int *exit_on_error_rtn)
       p++;
       len = strcspn (p, "'");
       if (p[len] == '\0') {
-        fprintf (stderr, _("%s: unterminated single quote\n"), guestfs___program_name);
+        fprintf (stderr, _("%s: unterminated single quote\n"), guestfs_int_program_name);
         pcmd.status = -1;
         return pcmd;
       }
       if (p[len+1] && (p[len+1] != ' ' && p[len+1] != '\t')) {
         fprintf (stderr,
                  _("%s: command arguments not separated by whitespace\n"),
-                 guestfs___program_name);
+                 guestfs_int_program_name);
         pcmd.status = -1;
         return pcmd;
       }
@@ -899,7 +899,7 @@ parse_command_line (char *buf, int *exit_on_error_rtn)
         pend = &p[len];
     } else {
       fprintf (stderr, _("%s: internal error parsing string at '%s'\n"),
-               guestfs___program_name, p);
+               guestfs_int_program_name, p);
       abort ();
     }
 
@@ -915,7 +915,7 @@ parse_command_line (char *buf, int *exit_on_error_rtn)
   }
 
   if (i == argv_len) {
-    fprintf (stderr, _("%s: too many arguments\n"), guestfs___program_name);
+    fprintf (stderr, _("%s: too many arguments\n"), guestfs_int_program_name);
     pcmd.status = -1;
     return pcmd;
   }
@@ -991,7 +991,7 @@ parse_quoted_string (char *p)
       default:
       error:
         fprintf (stderr, _("%s: invalid escape sequence in string (starting at offset %d)\n"),
-                 guestfs___program_name, (int) (p - start));
+                 guestfs_int_program_name, (int) (p - start));
         return -1;
       }
       memmove (p+1, p+1+m, strlen (p+1+m) + 1);
@@ -999,7 +999,7 @@ parse_quoted_string (char *p)
   }
 
   if (!*p) {
-    fprintf (stderr, _("%s: unterminated double quote\n"), guestfs___program_name);
+    fprintf (stderr, _("%s: unterminated double quote\n"), guestfs_int_program_name);
     return -1;
   }
 
@@ -1062,7 +1062,7 @@ cmdline (char *argv[], size_t optind, size_t argc)
 
   cmd = argv[optind++];
   if (STREQ (cmd, ":")) {
-    fprintf (stderr, _("%s: empty command on command line\n"), guestfs___program_name);
+    fprintf (stderr, _("%s: empty command on command line\n"), guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
@@ -1191,7 +1191,7 @@ issue_command (const char *cmd, char *argv[], const char *pipecmd,
   }
   if (ferror (stdout)) {
     if (!pipecmd || pipe_error) {
-      fprintf (stderr, "%s: write error%s\n", guestfs___program_name,
+      fprintf (stderr, "%s: write error%s\n", guestfs_int_program_name,
                pipecmd ? " on pipe" : "");
       r = -1;
     }
@@ -1734,13 +1734,13 @@ win_prefix_drive_letter (char drive_letter, const char *path)
     return NULL;
   if (roots[0] == NULL) {
     fprintf (stderr, _("%s: to use Windows drive letters, you must inspect the guest (\"-i\" option or run \"inspect-os\" command)\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     return NULL;
   }
   drives = guestfs_inspect_get_drive_mappings (g, roots[0]);
   if (drives == NULL || drives[0] == NULL) {
     fprintf (stderr, _("%s: to use Windows drive letters, this must be a Windows guest\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     return NULL;
   }
 
@@ -1754,7 +1754,7 @@ win_prefix_drive_letter (char drive_letter, const char *path)
 
   if (device == NULL) {
     fprintf (stderr, _("%s: drive '%c:' not found.  To list available drives do:\n  inspect-get-drive-mappings %s\n"),
-             guestfs___program_name, drive_letter, roots[0]);
+             guestfs_int_program_name, drive_letter, roots[0]);
     return NULL;
   }
 
@@ -1773,7 +1773,7 @@ win_prefix_drive_letter (char drive_letter, const char *path)
 
   if (mountpoint == NULL) {
     fprintf (stderr, _("%s: to access '%c:', mount %s first.  One way to do this is:\n  umount-all\n  mount %s /\n"),
-             guestfs___program_name, drive_letter, device, device);
+             guestfs_int_program_name, drive_letter, device, device);
     return NULL;
   }
 
@@ -1810,7 +1810,7 @@ file_in (const char *arg)
     const char *endmarker = &arg[3];
     if (*endmarker == '\0') {
       fprintf (stderr, "%s: missing end marker in -<< expression\n",
-               guestfs___program_name);
+               guestfs_int_program_name);
       return NULL;
     }
     ret = file_in_heredoc (endmarker);
@@ -1875,7 +1875,7 @@ file_in_heredoc (const char *endmarker)
    * is likely to be an error.
    */
   fprintf (stderr, "%s: end of input reached without finding '%s'\n",
-           guestfs___program_name, endmarker);
+           guestfs_int_program_name, endmarker);
   goto error2;
 
  found_end:
diff --git a/fish/glob.c b/fish/glob.c
index f6da10a..1afb2bb 100644
--- a/fish/glob.c
+++ b/fish/glob.c
@@ -103,7 +103,7 @@ run_glob (const char *cmd, size_t argc, char *argv[])
     }
 
     globs[i] = pp;
-    count[i] = guestfs___count_strings (pp);
+    count[i] = guestfs_int_count_strings (pp);
   }
 
   /* Issue the commands. */
@@ -113,7 +113,7 @@ run_glob (const char *cmd, size_t argc, char *argv[])
  error:
   for (i = 1; i < argc; ++i)
     if (globs[i])
-      guestfs___free_string_list (globs[i]);
+      guestfs_int_free_string_list (globs[i]);
   return r;
 }
 
@@ -170,23 +170,23 @@ expand_devicename (guestfs_h *g, const char *device)
   pp = guestfs_list_devices (g);
   if (pp == NULL) goto error;
   if (add_strings_matching (pp, device, &ret, &size) == -1) goto error;
-  guestfs___free_string_list (pp);
+  guestfs_int_free_string_list (pp);
 
   pp = guestfs_list_partitions (g);
   if (pp == NULL) goto error;
   if (add_strings_matching (pp, device, &ret, &size) == -1) goto error;
-  guestfs___free_string_list (pp);
+  guestfs_int_free_string_list (pp);
 
   pp = guestfs_list_md_devices (g);
   if (pp == NULL) goto error;
   if (add_strings_matching (pp, device, &ret, &size) == -1) goto error;
-  guestfs___free_string_list (pp);
+  guestfs_int_free_string_list (pp);
 
   if (guestfs_feature_available (g, (char **) lvm2)) {
     pp = guestfs_lvs (g);
     if (pp == NULL) goto error;
     if (add_strings_matching (pp, device, &ret, &size) == -1) goto error;
-    guestfs___free_string_list (pp);
+    guestfs_int_free_string_list (pp);
     pp = NULL;
   }
 
@@ -197,9 +197,9 @@ expand_devicename (guestfs_h *g, const char *device)
 
  error:
   if (pp)
-    guestfs___free_string_list (pp);
+    guestfs_int_free_string_list (pp);
   if (ret)
-    guestfs___free_string_list (ret);
+    guestfs_int_free_string_list (ret);
 
   return NULL;
 }
diff --git a/fish/inspect.c b/fish/inspect.c
index bd12b91..eb5ecc6 100644
--- a/fish/inspect.c
+++ b/fish/inspect.c
@@ -60,7 +60,7 @@ inspect_mount_handle (guestfs_h *g)
 {
   if (live) {
     fprintf (stderr, _("%s: don't use --live and -i options together\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
@@ -86,8 +86,8 @@ inspect_mount_handle (guestfs_h *g)
         "If using other virt tools, this disk image won't work\n"
         "with these tools.  Use the guestfish equivalent commands\n"
         "(see the virt tool manual page).\n"),
-             guestfs___program_name);
-    guestfs___free_string_list (roots);
+             guestfs_int_program_name);
+    guestfs_int_free_string_list (roots);
     exit (EXIT_FAILURE);
   }
 
@@ -107,8 +107,8 @@ inspect_mount_handle (guestfs_h *g)
         "If using other virt tools, multi-boot operating systems won't work\n"
         "with these tools.  Use the guestfish equivalent commands\n"
         "(see the virt tool manual page).\n"),
-             guestfs___program_name);
-    guestfs___free_string_list (roots);
+             guestfs_int_program_name);
+    guestfs_int_free_string_list (roots);
     exit (EXIT_FAILURE);
   }
 
@@ -132,7 +132,7 @@ inspect_mount_root (guestfs_h *g, const char *root)
   /* Sort by key length, shortest key first, so that we end up
    * mounting the filesystems in the correct order.
    */
-  qsort (mountpoints, guestfs___count_strings (mountpoints) / 2,
+  qsort (mountpoints, guestfs_int_count_strings (mountpoints) / 2,
          2 * sizeof (char *),
          compare_keys_len);
 
@@ -156,7 +156,7 @@ inspect_mount_root (guestfs_h *g, const char *root)
 
   if (mount_errors)
     fprintf (stderr, _("%s: some filesystems could not be mounted (ignored)\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
 }
 
 /* This function is called only if the above function was called,
@@ -178,7 +178,7 @@ print_inspect_prompt (void)
     return;
 
   /* Sort by key. */
-  qsort (mountpoints, guestfs___count_strings (mountpoints) / 2,
+  qsort (mountpoints, guestfs_int_count_strings (mountpoints) / 2,
          2 * sizeof (char *),
          compare_keys);
 
diff --git a/fish/man.c b/fish/man.c
index 6c2b052..21f2422 100644
--- a/fish/man.c
+++ b/fish/man.c
@@ -55,7 +55,7 @@ run_man (const char *cmd, size_t argc, char *argv[])
     char status_string[80];
 
     fprintf (stderr, "%s\n",
-             guestfs___exit_status_to_string (r, "man",
+             guestfs_int_exit_status_to_string (r, "man",
                                               status_string,
                                               sizeof status_string));
     return -1;
diff --git a/fish/options.c b/fish/options.c
index 8b12fd6..4aff4f5 100644
--- a/fish/options.c
+++ b/fish/options.c
@@ -105,7 +105,7 @@ add_drives_handle (guestfs_h *g, struct drv *drv, char next_drive)
   if (next_drive > 'z') {
     fprintf (stderr,
              _("%s: too many drives added on the command line\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
@@ -269,19 +269,19 @@ display_mountpoints_on_failure (const char *mp_device,
     return;
 
   fprintf (stderr, _("%s: '%s' could not be mounted.\n"),
-           guestfs___program_name, mp_device);
+           guestfs_int_program_name, mp_device);
 
   if (user_supplied_options)
     fprintf (stderr, _("%s: Check mount(8) man page to ensure options '%s'\n"
                        "%s: are supported by the filesystem that is being mounted.\n"),
-             guestfs___program_name, user_supplied_options, guestfs___program_name);
+             guestfs_int_program_name, user_supplied_options, guestfs_int_program_name);
 
   fprintf (stderr, _("%s: Did you mean to mount one of these filesystems?\n"),
-           guestfs___program_name);
+           guestfs_int_program_name);
 
   for (i = 0; fses[i] != NULL; i += 2) {
     CLEANUP_FREE char *p = guestfs_canonical_device_name (g, fses[i]);
-    fprintf (stderr, "%s: \t%s (%s)\n", guestfs___program_name,
+    fprintf (stderr, "%s: \t%s (%s)\n", guestfs_int_program_name,
              p ? p : fses[i], fses[i+1]);
   }
 }
@@ -304,7 +304,7 @@ free_drives (struct drv *drv)
   case drv_uri:
     free (drv->uri.path);
     free (drv->uri.protocol);
-    guestfs___free_string_list (drv->uri.server);
+    guestfs_int_free_string_list (drv->uri.server);
     free (drv->uri.username);
     free (drv->uri.password);
     break;
diff --git a/fish/options.h b/fish/options.h
index 93fb560..033bb3c 100644
--- a/fish/options.h
+++ b/fish/options.h
@@ -218,7 +218,7 @@ extern void display_long_options (const struct option *) __attribute__((noreturn
   {                                                                     \
     struct guestfs_version *v = guestfs_version (g);                    \
     printf ("%s %"PRIi64".%"PRIi64".%"PRIi64"%s\n",                     \
-            guestfs___program_name,                                               \
+            guestfs_int_program_name,                                               \
             v->major, v->minor, v->release, v->extra);                  \
     exit (EXIT_SUCCESS);                                                \
   }
@@ -226,7 +226,7 @@ extern void display_long_options (const struct option *) __attribute__((noreturn
 #define OPTION_w                                                        \
   if (read_only) {                                                      \
     fprintf (stderr, _("%s: cannot mix --ro and --rw options\n"),       \
-             guestfs___program_name);                                             \
+             guestfs_int_program_name);                                             \
     exit (EXIT_FAILURE);                                                \
   }
 
@@ -238,7 +238,7 @@ extern void display_long_options (const struct option *) __attribute__((noreturn
     if (!format_consumed) {                                             \
       fprintf (stderr,                                                  \
                _("%s: --format parameter must appear before -a parameter\n"), \
-               guestfs___program_name);                                           \
+               guestfs_int_program_name);                                           \
       exit (EXIT_FAILURE);                                              \
     }                                                                   \
   } while (0)
diff --git a/fish/uri.c b/fish/uri.c
index 80e0235..593e62a 100644
--- a/fish/uri.c
+++ b/fish/uri.c
@@ -110,7 +110,7 @@ parse (const char *arg, char **path_ret, char **protocol_ret,
   uri = xmlParseURI (arg);
   if (!uri) {
     fprintf (stderr, _("%s: --add: could not parse URI '%s'\n"),
-             guestfs___program_name, arg);
+             guestfs_int_program_name, arg);
     return -1;
   }
 
@@ -121,7 +121,7 @@ parse (const char *arg, char **path_ret, char **protocol_ret,
   if (uri->scheme == NULL || STREQ (uri->scheme, "")) {
     /* Probably can never happen. */
     fprintf (stderr, _("%s: %s: scheme of URI is NULL or empty\n"),
-             guestfs___program_name, arg);
+             guestfs_int_program_name, arg);
     return -1;
   }
 
@@ -129,14 +129,14 @@ parse (const char *arg, char **path_ret, char **protocol_ret,
 
   if (uri->server && STRNEQ (uri->server, "") && socket) {
     fprintf (stderr, _("%s: %s: cannot both a server name and a socket query parameter\n"),
-             guestfs___program_name, arg);
+             guestfs_int_program_name, arg);
     return -1;
   }
 
   /* Is this needed? XXX
   if (socket && socket[0] != '/') {
     fprintf (stderr, _("%s: --add %s: socket query parameter must be an absolute path\n"),
-             guestfs___program_name, arg);
+             guestfs_int_program_name, arg);
     return -1;
   }
   */
@@ -162,7 +162,7 @@ parse (const char *arg, char **path_ret, char **protocol_ret,
         if (*password_ret == NULL) {
           perror ("strdup: password");
           free (*protocol_ret);
-          guestfs___free_string_list (*server_ret);
+          guestfs_int_free_string_list (*server_ret);
           return -1;
         }
       }
@@ -173,7 +173,7 @@ parse (const char *arg, char **path_ret, char **protocol_ret,
       perror ("strdup: username");
       free (*password_ret);
       free (*protocol_ret);
-      guestfs___free_string_list (*server_ret);
+      guestfs_int_free_string_list (*server_ret);
       return -1;
     }
   }
@@ -195,7 +195,7 @@ parse (const char *arg, char **path_ret, char **protocol_ret,
   if (*path_ret == NULL) {
     perror ("strdup: path");
     free (*protocol_ret);
-    guestfs___free_string_list (*server_ret);
+    guestfs_int_free_string_list (*server_ret);
     free (*username_ret);
     free (*password_ret);
     return -1;
diff --git a/fish/windows.c b/fish/windows.c
index 63c5cae..738841b 100644
--- a/fish/windows.c
+++ b/fish/windows.c
@@ -104,7 +104,7 @@ mount_drive_letter (guestfs_h *g, char drive_letter, const char *root,
     guestfs_inspect_get_drive_mappings (g, root);
   if (drives == NULL || drives[0] == NULL) {
     fprintf (stderr, _("%s: to use Windows drive letters, this must be a Windows guest\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
@@ -118,7 +118,7 @@ mount_drive_letter (guestfs_h *g, char drive_letter, const char *root,
 
   if (device == NULL) {
     fprintf (stderr, _("%s: drive '%c:' not found.\n"),
-             guestfs___program_name, drive_letter);
+             guestfs_int_program_name, drive_letter);
     exit (EXIT_FAILURE);
   }
 
diff --git a/format/format.c b/format/format.c
index 06c138c..b0f1ddf 100644
--- a/format/format.c
+++ b/format/format.c
@@ -63,7 +63,7 @@ usage (int status)
 
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n%s\n"),
-             guestfs___program_name, warning);
+             guestfs_int_program_name, warning);
   else {
     fprintf (stdout,
            _("%s: erase and make a blank disk\n"
@@ -88,7 +88,7 @@ usage (int status)
              "For more information, see the manpage %s(1).\n"
              "\n"
              "%s\n\n"),
-             guestfs___program_name, warning, guestfs___program_name, guestfs___program_name,
+             guestfs_int_program_name, warning, guestfs_int_program_name, guestfs_int_program_name,
              warning);
   }
   exit (status);
@@ -146,7 +146,7 @@ main (int argc, char *argv[])
           filesystem = NULL;
         else if (optarg[0] == '-') { /* eg: --filesystem --lvm */
           fprintf (stderr, _("%s: no filesystem was specified\n"),
-                   guestfs___program_name);
+                   guestfs_int_program_name);
           exit (EXIT_FAILURE);
         } else
           filesystem = optarg;
@@ -154,7 +154,7 @@ main (int argc, char *argv[])
         if (vg || lv) {
           fprintf (stderr,
                    _("%s: --lvm option cannot be given multiple times\n"),
-                   guestfs___program_name);
+                   guestfs_int_program_name);
           exit (EXIT_FAILURE);
         }
         if (optarg == NULL) {
@@ -179,7 +179,7 @@ main (int argc, char *argv[])
         label = optarg;
       } else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -272,7 +272,7 @@ main (int argc, char *argv[])
                  "may mean there is some sort of partition table or disk\n"
                  "data which we are unable to remove.  If you think this\n"
                  "is a bug, please file a bug at http://libguestfs.org/\n"),
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
   }
@@ -310,7 +310,7 @@ parse_vg_lv (const char *lvm)
   } else {
   cannot_parse:
     fprintf (stderr, _("%s: cannot parse --lvm option (%s)\n"),
-             guestfs___program_name, lvm);
+             guestfs_int_program_name, lvm);
     exit (EXIT_FAILURE);
   }
 
diff --git a/fuse/guestmount.c b/fuse/guestmount.c
index abb93c0..e3e60b5 100644
--- a/fuse/guestmount.c
+++ b/fuse/guestmount.c
@@ -88,7 +88,7 @@ static void __attribute__((noreturn))
 fuse_help (void)
 {
   static struct fuse_operations null_operations;
-  const char *tmp_argv[] = { guestfs___program_name, "--help", NULL };
+  const char *tmp_argv[] = { guestfs_int_program_name, "--help", NULL };
   fuse_main (2, (char **) tmp_argv, &null_operations, NULL);
   exit (EXIT_SUCCESS);
 }
@@ -98,7 +98,7 @@ usage (int status)
 {
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   else {
     fprintf (stdout,
            _("%s: FUSE module for libguestfs\n"
@@ -131,7 +131,7 @@ usage (int status)
              "  -w|--rw              Mount read-write\n"
              "  -x|--trace           Trace guestfs API calls\n"
              ),
-             guestfs___program_name, guestfs___program_name, guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name);
   }
   exit (status);
 }
@@ -242,12 +242,12 @@ main (int argc, char *argv[])
       } else if (STREQ (long_options[option_index].name, "fd")) {
         if (sscanf (optarg, "%d", &pipe_fd) != 1 || pipe_fd < 0) {
           fprintf (stderr, _("%s: unable to parse --fd option value: %s\n"),
-                   guestfs___program_name, optarg);
+                   guestfs_int_program_name, optarg);
           exit (EXIT_FAILURE);
         }
       } else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -317,7 +317,7 @@ main (int argc, char *argv[])
     if (!drvs || !(mps || inspector)) {
       fprintf (stderr,
                _("%s: must have at least one -a/-d and at least one -m/-i option\n"),
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
   } else {
@@ -327,14 +327,14 @@ main (int argc, char *argv[])
     if (read_only) {
       fprintf (stderr,
                _("%s: --live is not compatible with --ro option\n"),
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
 
     if (inspector) {
       fprintf (stderr,
                _("%s: --live is not compatible with -i option\n"),
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
 
@@ -349,14 +349,14 @@ main (int argc, char *argv[])
     if (count_d != 1) {
       fprintf (stderr,
                _("%s: with --live, you must use exactly one -d option\n"),
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
 
     if (count_other != 0) {
       fprintf (stderr,
                _("%s: --live is not compatible with -a option\n"),
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
   }
@@ -365,7 +365,7 @@ main (int argc, char *argv[])
   if (optind+1 != argc) {
     fprintf (stderr,
              _("%s: you must specify a mountpoint in the host filesystem\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
diff --git a/fuse/guestunmount.c b/fuse/guestunmount.c
index 3df481b..0da3e82 100644
--- a/fuse/guestunmount.c
+++ b/fuse/guestunmount.c
@@ -50,7 +50,7 @@ usage (int status)
 {
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   else {
     fprintf (stdout,
            _("%s: clean up a mounted filesystem\n"
@@ -66,7 +66,7 @@ usage (int status)
              "  -v|--verbose         Verbose messages\n"
              "  -V|--version         Display version and exit\n"
              ),
-             guestfs___program_name, guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name);
   }
   exit (status);
 }
@@ -109,7 +109,7 @@ main (int argc, char *argv[])
       if (STREQ (long_options[option_index].name, "fd")) {
         if (sscanf (optarg, "%d", &fd) != 1 || fd < 0) {
           fprintf (stderr, _("%s: cannot parse fd option '%s'\n"),
-                   guestfs___program_name, optarg);
+                   guestfs_int_program_name, optarg);
           exit (EXIT_FAILURE);
         }
       } else if (STREQ (long_options[option_index].name, "no-retry")) {
@@ -117,12 +117,12 @@ main (int argc, char *argv[])
       } else if (STREQ (long_options[option_index].name, "retry")) {
         if (sscanf (optarg, "%zu", &retries) != 1 || retries >= 64) {
           fprintf (stderr, _("%s: cannot parse retries option or value is too large '%s'\n"),
-                   guestfs___program_name, optarg);
+                   guestfs_int_program_name, optarg);
           exit (EXIT_FAILURE);
         }
       } else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -151,7 +151,7 @@ main (int argc, char *argv[])
   if (optind+1 != argc) {
     fprintf (stderr,
              _("%s: you must specify a mountpoint in the host filesystem\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
@@ -206,7 +206,7 @@ main (int argc, char *argv[])
   /* fusermount failed after N retries */
   if (!quiet) {
     fprintf (stderr, _("%s: failed to unmount %s: %s\n"),
-             guestfs___program_name, mountpoint, error);
+             guestfs_int_program_name, mountpoint, error);
     do_fuser (mountpoint);
   }
   free (error);
@@ -217,7 +217,7 @@ main (int argc, char *argv[])
  not_mounted:
   if (!quiet)
     fprintf (stderr, _("%s: %s is not mounted: %s\n"),
-             guestfs___program_name, mountpoint, error);
+             guestfs_int_program_name, mountpoint, error);
 
   free (error);
 
diff --git a/fuse/test-guestmount-fd.c b/fuse/test-guestmount-fd.c
index f969cf1..54a230d 100644
--- a/fuse/test-guestmount-fd.c
+++ b/fuse/test-guestmount-fd.c
@@ -50,9 +50,9 @@ main (int argc, char *argv[])
 
   /* Allow the test to be skipped. */
   skip = getenv ("SKIP_TEST_GUESTMOUNT_FD");
-  if (skip && guestfs___is_true (skip) > 0) {
+  if (skip && guestfs_int_is_true (skip) > 0) {
     fprintf (stderr, "%s: test skipped because environment variable set.\n",
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (77);
   }
 
@@ -117,7 +117,7 @@ main (int argc, char *argv[])
   }
   if (r == 0) {
     fprintf (stderr, "%s: unexpected end of file on pipe fd.\n",
-             guestfs___program_name);
+             guestfs_int_program_name);
     ignore_value (rmdir (MOUNTPOINT));
     exit (EXIT_FAILURE);
   }
@@ -125,7 +125,7 @@ main (int argc, char *argv[])
   /* Check that the test image was mounted. */
   if (access (TEST_FILE, R_OK) == -1) {
     fprintf (stderr, "%s: test failed because test image is not mounted and ready.",
-             guestfs___program_name);
+             guestfs_int_program_name);
     ignore_value (rmdir (MOUNTPOINT));
     exit (EXIT_FAILURE);
   }
@@ -135,8 +135,8 @@ main (int argc, char *argv[])
   if (r != 0) {
     char status_string[80];
 
-    fprintf (stderr, "%s: test failed: %s\n", guestfs___program_name,
-             guestfs___exit_status_to_string (r, GUESTUNMOUNT_BINARY,
+    fprintf (stderr, "%s: test failed: %s\n", guestfs_int_program_name,
+             guestfs_int_exit_status_to_string (r, GUESTUNMOUNT_BINARY,
                                               status_string,
                                               sizeof status_string));
     ignore_value (rmdir (MOUNTPOINT));
@@ -156,8 +156,8 @@ main (int argc, char *argv[])
     char status_string[80];
 
     fprintf (stderr, "%s: test failed: %s\n",
-             guestfs___program_name,
-             guestfs___exit_status_to_string (status, GUESTMOUNT_BINARY,
+             guestfs_int_program_name,
+             guestfs_int_exit_status_to_string (status, GUESTMOUNT_BINARY,
                                               status_string,
                                               sizeof status_string));
     ignore_value (rmdir (MOUNTPOINT));
diff --git a/fuse/test-guestunmount-fd.c b/fuse/test-guestunmount-fd.c
index 9ddc842..1addf09 100644
--- a/fuse/test-guestunmount-fd.c
+++ b/fuse/test-guestunmount-fd.c
@@ -83,8 +83,8 @@ main (int argc, char *argv[])
   if (r != 0) {
     char status_string[80];
 
-    fprintf (stderr, "%s: test failed: %s\n", guestfs___program_name,
-             guestfs___exit_status_to_string (r, "guestunmount",
+    fprintf (stderr, "%s: test failed: %s\n", guestfs_int_program_name,
+             guestfs_int_exit_status_to_string (r, "guestunmount",
                                               status_string,
                                               sizeof status_string));
     exit (EXIT_FAILURE);
@@ -105,8 +105,8 @@ main (int argc, char *argv[])
     char status_string[80];
 
     fprintf (stderr, "%s: test failed: guestunmount didn't return status code 2; %s\n",
-             guestfs___program_name,
-             guestfs___exit_status_to_string (status, "guestunmount",
+             guestfs_int_program_name,
+             guestfs_int_exit_status_to_string (status, "guestunmount",
                                               status_string,
                                               sizeof status_string));
     exit (EXIT_FAILURE);
diff --git a/generator/c.ml b/generator/c.ml
index 1fa05ab..9b3bbce 100644
--- a/generator/c.ml
+++ b/generator/c.ml
@@ -819,9 +819,9 @@ and generate_internal_frontend_cleanups_h () =
   List.iter (
     fun { s_name = name } ->
       pr "#define CLEANUP_FREE_%s \\\n" (String.uppercase name);
-      pr "  __attribute__((cleanup(guestfs___cleanup_free_%s)))\n" name;
+      pr "  __attribute__((cleanup(guestfs_int_cleanup_free_%s)))\n" name;
       pr "#define CLEANUP_FREE_%s_LIST \\\n" (String.uppercase name);
-      pr "  __attribute__((cleanup(guestfs___cleanup_free_%s_list)))\n" name
+      pr "  __attribute__((cleanup(guestfs_int_cleanup_free_%s_list)))\n" name
   ) structs;
 
   pr "#else /* !HAVE_ATTRIBUTE_CLEANUP */\n";
@@ -843,9 +843,9 @@ and generate_internal_frontend_cleanups_h () =
 
   List.iter (
     fun { s_name = name } ->
-      pr "extern void guestfs___cleanup_free_%s (void *ptr);\n"
+      pr "extern void guestfs_int_cleanup_free_%s (void *ptr);\n"
         name;
-      pr "extern void guestfs___cleanup_free_%s_list (void *ptr);\n"
+      pr "extern void guestfs_int_cleanup_free_%s_list (void *ptr);\n"
         name
   ) structs;
 
@@ -1192,14 +1192,14 @@ and generate_client_structs_cleanup () =
   List.iter (
     fun { s_name = typ } ->
       pr "void\n";
-      pr "guestfs___cleanup_free_%s (void *ptr)\n" typ;
+      pr "guestfs_int_cleanup_free_%s (void *ptr)\n" typ;
       pr "{\n";
       pr "  guestfs_free_%s (* (struct guestfs_%s **) ptr);\n" typ typ;
       pr "}\n";
       pr "\n";
 
       pr "void\n";
-      pr "guestfs___cleanup_free_%s_list (void *ptr)\n" typ;
+      pr "guestfs_int_cleanup_free_%s_list (void *ptr)\n" typ;
       pr "{\n";
       pr "  guestfs_free_%s_list (* (struct guestfs_%s_list **) ptr);\n"
         typ typ;
@@ -1232,7 +1232,7 @@ and generate_client_actions hash () =
 
   (* Generate code for enter events. *)
   let enter_event shortname =
-    pr "  guestfs___call_callbacks_message (g, GUESTFS_EVENT_ENTER,\n";
+    pr "  guestfs_int_call_callbacks_message (g, GUESTFS_EVENT_ENTER,\n";
     pr "                                    \"%s\", %d);\n"
       shortname (String.length shortname)
   in
@@ -1349,7 +1349,7 @@ and generate_client_actions hash () =
     List.iter (
       function
       | GUID n ->
-          pr "  if (!guestfs___validate_guid (%s)) {\n" n;
+          pr "  if (!guestfs_int_validate_guid (%s)) {\n" n;
           pr "    error (g, \"%%s: %%s: parameter is not a valid GUID\",\n";
           pr "           \"%s\", \"%s\");\n" c_name n;
           let errcode =
@@ -1398,7 +1398,7 @@ and generate_client_actions hash () =
       pr "\n"
     );
 
-    pr "    guestfs___trace_open (&trace_buffer);\n";
+    pr "    guestfs_int_trace_open (&trace_buffer);\n";
 
     pr "    fprintf (trace_buffer.fp, \"%%s\", \"%s\");\n" name;
 
@@ -1440,7 +1440,7 @@ and generate_client_actions hash () =
           pr "    fprintf (trace_buffer.fp, \" %%\" PRIi64, %s);\n" n
       | BufferIn n ->                   (* RHBZ#646822 *)
           pr "    fputc (' ', trace_buffer.fp);\n";
-          pr "    guestfs___print_BufferIn (trace_buffer.fp, %s, %s_size);\n" n n
+          pr "    guestfs_int_print_BufferIn (trace_buffer.fp, %s, %s_size);\n" n n
       | Pointer (t, n) ->
           pr "    fprintf (trace_buffer.fp, \" (%s)%%p\", %s);\n" t n
     ) args;
@@ -1471,7 +1471,7 @@ and generate_client_actions hash () =
         pr "    }\n"
     ) optargs;
 
-    pr "    guestfs___trace_send_line (g, &trace_buffer);\n";
+    pr "    guestfs_int_trace_send_line (g, &trace_buffer);\n";
     pr "  }\n";
     pr "\n";
   in
@@ -1490,7 +1490,7 @@ and generate_client_actions hash () =
       pr "\n"
     );
 
-    pr "%s  guestfs___trace_open (&trace_buffer);\n" indent;
+    pr "%s  guestfs_int_trace_open (&trace_buffer);\n" indent;
 
     pr "%s  fprintf (trace_buffer.fp, \"%%s = \", \"%s\");\n" indent name;
 
@@ -1505,7 +1505,7 @@ and generate_client_actions hash () =
          pr "%s  fprintf (trace_buffer.fp, \"\\\"%%s\\\"\", %s != NULL ? %s : \"NULL\");\n"
            indent rv rv
      | RBufferOut _ ->
-         pr "%s  guestfs___print_BufferOut (trace_buffer.fp, %s, *size_r);\n" indent rv
+         pr "%s  guestfs_int_print_BufferOut (trace_buffer.fp, %s, *size_r);\n" indent rv
      | RStringList _ | RHashtable _ ->
          pr "%s  fputs (\"[\", trace_buffer.fp);\n" indent;
          pr "%s  for (i = 0; %s[i]; ++i) {\n" indent rv;
@@ -1526,7 +1526,7 @@ and generate_client_actions hash () =
          pr "%s  fprintf (trace_buffer.fp, \"<struct guestfs_%s_list *>\");\n"
            indent typ (* XXX *)
     );
-    pr "%s  guestfs___trace_send_line (g, &trace_buffer);\n" indent;
+    pr "%s  guestfs_int_trace_send_line (g, &trace_buffer);\n" indent;
     pr "%s}\n" indent;
     pr "\n";
   in
@@ -1536,7 +1536,7 @@ and generate_client_actions hash () =
 
     pr "%sif (trace_flag)\n" indent;
 
-    pr "%s  guestfs___trace (g, \"%%s = %%s (error)\",\n" indent;
+    pr "%s  guestfs_int_trace (g, \"%%s = %%s (error)\",\n" indent;
     pr "%s                   \"%s\", \"%s\");\n"
       indent name (string_of_errcode errcode)
   in
@@ -1720,7 +1720,7 @@ and generate_client_actions hash () =
     ) args;
 
     (* This is a daemon_function so check the appliance is up. *)
-    pr "  if (guestfs___check_appliance_up (g, \"%s\") == -1) {\n" name;
+    pr "  if (guestfs_int_check_appliance_up (g, \"%s\") == -1) {\n" name;
     trace_return_error ~indent:4 name style errcode;
     pr "    return %s;\n" (string_of_errcode errcode);
     pr "  }\n";
@@ -1728,7 +1728,7 @@ and generate_client_actions hash () =
 
     (* Send the main header and arguments. *)
     if args_passed_to_daemon = [] && optargs = [] then (
-      pr "  serial = guestfs___send (g, GUESTFS_PROC_%s, progress_hint, 0,\n"
+      pr "  serial = guestfs_int_send (g, GUESTFS_PROC_%s, progress_hint, 0,\n"
         (String.uppercase name);
       pr "                           NULL, NULL);\n"
     ) else (
@@ -1790,7 +1790,7 @@ and generate_client_actions hash () =
           )
       ) optargs;
 
-      pr "  serial = guestfs___send (g, GUESTFS_PROC_%s,\n"
+      pr "  serial = guestfs_int_send (g, GUESTFS_PROC_%s,\n"
         (String.uppercase name);
       pr "                           progress_hint, %s,\n"
         (if optargs <> [] then "optargs->bitmask" else "0");
@@ -1808,11 +1808,11 @@ and generate_client_actions hash () =
     List.iter (
       function
       | FileIn n ->
-        pr "  r = guestfs___send_file (g, %s);\n" n;
+        pr "  r = guestfs_int_send_file (g, %s);\n" n;
         pr "  if (r == -1) {\n";
         trace_return_error ~indent:4 name style errcode;
         pr "    /* daemon will send an error reply which we discard */\n";
-        pr "    guestfs___recv_discard (g, \"%s\");\n" name;
+        pr "    guestfs_int_recv_discard (g, \"%s\");\n" name;
         pr "    return %s;\n" (string_of_errcode errcode);
         pr "  }\n";
         pr "  if (r == -2) /* daemon cancelled */\n";
@@ -1828,7 +1828,7 @@ and generate_client_actions hash () =
     pr "  memset (&err, 0, sizeof err);\n";
     if has_ret then pr "  memset (&ret, 0, sizeof ret);\n";
     pr "\n";
-    pr "  r = guestfs___recv (g, \"%s\", &hdr, &err,\n        " name;
+    pr "  r = guestfs_int_recv (g, \"%s\", &hdr, &err,\n        " name;
     if not has_ret then
       pr "NULL, NULL"
     else
@@ -1841,7 +1841,7 @@ and generate_client_actions hash () =
     pr "  }\n";
     pr "\n";
 
-    pr "  if (guestfs___check_reply_header (g, &hdr, GUESTFS_PROC_%s, serial) == -1) {\n"
+    pr "  if (guestfs_int_check_reply_header (g, &hdr, GUESTFS_PROC_%s, serial) == -1) {\n"
       (String.uppercase name);
     trace_return_error ~indent:4 name style errcode;
     pr "    return %s;\n" (string_of_errcode errcode);
@@ -1853,12 +1853,12 @@ and generate_client_actions hash () =
     pr "\n";
     trace_return_error ~indent:4 name style errcode;
     pr "    if (err.errno_string[0] != '\\0')\n";
-    pr "      errnum = guestfs___string_to_errno (err.errno_string);\n";
+    pr "      errnum = guestfs_int_string_to_errno (err.errno_string);\n";
     pr "    if (errnum <= 0)\n";
     pr "      error (g, \"%%s: %%s\", \"%s\", err.error_message);\n"
       name;
     pr "    else\n";
-    pr "      guestfs___error_errno (g, errnum, \"%%s: %%s\", \"%s\",\n"
+    pr "      guestfs_int_error_errno (g, errnum, \"%%s: %%s\", \"%s\",\n"
       name;
     pr "                           err.error_message);\n";
     pr "    free (err.error_message);\n";
@@ -1871,7 +1871,7 @@ and generate_client_actions hash () =
     List.iter (
       function
       | FileOut n ->
-        pr "  if (guestfs___recv_file (g, %s) == -1) {\n" n;
+        pr "  if (guestfs_int_recv_file (g, %s) == -1) {\n" n;
         trace_return_error ~indent:4 name style errcode;
         pr "    return %s;\n" (string_of_errcode errcode);
         pr "  }\n";
@@ -2177,13 +2177,13 @@ and generate_linker_script () =
     (* Unofficial parts of the API: the bindings code use these
      * functions, so it is useful to export them.
      *)
-    "guestfs___safe_calloc";
-    "guestfs___safe_malloc";
-    "guestfs___safe_strdup";
-    "guestfs___safe_memdup";
+    "guestfs_int_safe_calloc";
+    "guestfs_int_safe_malloc";
+    "guestfs_int_safe_strdup";
+    "guestfs_int_safe_memdup";
 
     (* Used only by virt-df and virt-alignment-scan. *)
-    "guestfs___add_libvirt_dom";
+    "guestfs_int_add_libvirt_dom";
   ] in
   let functions =
     List.flatten (
diff --git a/generator/erlang.ml b/generator/erlang.ml
index f0c9c6a..bc80e71 100644
--- a/generator/erlang.ml
+++ b/generator/erlang.ml
@@ -397,7 +397,7 @@ extern int64_t get_int64 (ETERM *term);
             let uc_n = String.uppercase n in
             pr "  if ((optargs_s.bitmask & %s_%s_BITMASK))\n"
               c_optarg_prefix uc_n;
-            pr "    guestfs___free_string_list ((char **) optargs_s.%s);\n" n
+            pr "    guestfs_int_free_string_list ((char **) optargs_s.%s);\n" n
       ) optargs;
 
       (match errcode_of_ret ret with
@@ -430,7 +430,7 @@ extern int64_t get_int64 (ETERM *term);
            pr "  return rt;\n"
        | RStringList _ ->
            pr "  ETERM *rt = make_string_list (r);\n";
-           pr "  guestfs___free_string_list (r);\n\n";
+           pr "  guestfs_int_free_string_list (r);\n\n";
            pr "  return rt;\n"
        | RStruct (_, typ) ->
            pr "  ETERM *rt = make_%s (r);\n" typ;
@@ -442,7 +442,7 @@ extern int64_t get_int64 (ETERM *term);
            pr "  return rt;\n"
        | RHashtable _ ->
            pr "  ETERM *rt = make_table (r);\n";
-           pr "  guestfs___free_string_list (r);\n";
+           pr "  guestfs_int_free_string_list (r);\n";
            pr "  return rt;\n"
        | RBufferOut _ ->
            pr "  ETERM *rt = erl_mk_estring (r, size);\n";
diff --git a/generator/errnostring.ml b/generator/errnostring.ml
index 098c564..fa29816 100644
--- a/generator/errnostring.ml
+++ b/generator/errnostring.ml
@@ -216,7 +216,7 @@ let generate_errnostring_h () =
  *
  * NOTE: It is an error to call this function with errnum == 0.
  */
-extern const char *guestfs___errno_to_string (int errnum);
+extern const char *guestfs_int_errno_to_string (int errnum);
 
 /* Convert string representation of an error (eg. \"EIO\") to the errno
  * value (EIO).  As for the function above, this only works for a
@@ -224,11 +224,11 @@ extern const char *guestfs___errno_to_string (int errnum);
  * system, EINVAL is returned (all POSIX-conforming systems must
  * support EINVAL).
  */
-extern int guestfs___string_to_errno (const char *errnostr);
+extern int guestfs_int_string_to_errno (const char *errnostr);
 
 /* Private structure and function used by the perfect hash implementation. */
 struct errnostring_entry { char *name; int errnum; };
-extern const struct errnostring_entry *guestfs___string_to_errno_lookup (register const char *str, register unsigned int len);
+extern const struct errnostring_entry *guestfs_int_string_to_errno_lookup (register const char *str, register unsigned int len);
 
 #endif /* GUESTFS_ERRNOSTRING_H_ */
 "
@@ -262,7 +262,7 @@ static const char *errno_to_string[] = {
   (sizeof errno_to_string / sizeof errno_to_string[0])
 
 const char *
-guestfs___errno_to_string (int errnum)
+guestfs_int_errno_to_string (int errnum)
 {
   /* See function documentation. */
   if (errnum == 0)
@@ -276,10 +276,10 @@ guestfs___errno_to_string (int errnum)
 }
 
 int
-guestfs___string_to_errno (const char *errnostr)
+guestfs_int_string_to_errno (const char *errnostr)
 {
   const struct errnostring_entry *v =
-    guestfs___string_to_errno_lookup (errnostr, strlen (errnostr));
+    guestfs_int_string_to_errno_lookup (errnostr, strlen (errnostr));
   if (v /* not necessary to check v->name != NULL here */)
     return v->errnum;
   else
@@ -292,7 +292,7 @@ let generate_errnostring_gperf () =
 
   pr "\
 %%language=ANSI-C
-%%define lookup-function-name guestfs___string_to_errno_lookup
+%%define lookup-function-name guestfs_int_string_to_errno_lookup
 %%readonly-tables
 %%null-strings
 
@@ -312,7 +312,7 @@ let generate_errnostring_gperf () =
    * we are going to include E_ macros directly in the C output of
    * gperf.  To avoid this causing errors, we include macros to define
    * unknown errors as EINVAL (see specification of
-   * guestfs___string_to_errno above).  Note this only affects the
+   * guestfs_int_string_to_errno above).  Note this only affects the
    * single output file containing gperf-generated code.
    *)
   List.iter (
diff --git a/generator/fish.ml b/generator/fish.ml
index fce7c92..0146fb4 100644
--- a/generator/fish.ml
+++ b/generator/fish.ml
@@ -482,11 +482,11 @@ Guestfish will prompt for these separately."
             pr "    input_lineno++;\n";
             pr "  if (%s == NULL) goto out_%s;\n" name name
         | Bool name ->
-            pr "  switch (guestfs___is_true (argv[i++])) {\n";
+            pr "  switch (guestfs_int_is_true (argv[i++])) {\n";
             pr "    case -1:\n";
             pr "      fprintf (stderr,\n";
             pr "               _(\"%%s: '%%s': invalid boolean value, use 'true' or 'false'\\n\"),\n";
-            pr "               guestfs___program_name, argv[i-1]);\n";
+            pr "               guestfs_int_program_name, argv[i-1]);\n";
             pr "      goto out_%s;\n" name;
             pr "    case 0:  %s = 0; break;\n" name;
             pr "    default: %s = 1;\n" name;
@@ -525,11 +525,11 @@ Guestfish will prompt for these separately."
             pr "if (STRPREFIX (argv[i], \"%s:\")) {\n" n;
             (match argt with
              | OBool n ->
-                 pr "      switch (guestfs___is_true (&argv[i][%d])) {\n" (len+1);
+                 pr "      switch (guestfs_int_is_true (&argv[i][%d])) {\n" (len+1);
                  pr "        case -1:\n";
                  pr "          fprintf (stderr,\n";
                  pr "                   _(\"%%s: '%%s': invalid boolean value, use 'true' or 'false'\\n\"),\n";
-                 pr "                   guestfs___program_name, &argv[i][%d]);\n" (len+1);
+                 pr "                   guestfs_int_program_name, &argv[i][%d]);\n" (len+1);
                  pr "          goto out;\n";
                  pr "        case 0:  optargs_s.%s = 0; break;\n" n;
                  pr "        default: optargs_s.%s = 1;\n" n;
@@ -630,7 +630,7 @@ Guestfish will prompt for these separately."
            pr "  if (r == NULL) goto out;\n";
            pr "  ret = 0;\n";
            pr "  print_strings (r);\n";
-           pr "  guestfs___free_string_list (r);\n"
+           pr "  guestfs_int_free_string_list (r);\n"
        | RStruct (_, typ) ->
            pr "  if (r == NULL) goto out;\n";
            pr "  ret = 0;\n";
@@ -645,7 +645,7 @@ Guestfish will prompt for these separately."
            pr "  if (r == NULL) goto out;\n";
            pr "  ret = 0;\n";
            pr "  print_table (r);\n";
-           pr "  guestfs___free_string_list (r);\n"
+           pr "  guestfs_int_free_string_list (r);\n"
        | RBufferOut _ ->
            pr "  if (r == NULL) goto out;\n";
            pr "  if (full_write (1, r, size) != size) {\n";
@@ -668,7 +668,7 @@ Guestfish will prompt for these separately."
           pr "  if ((optargs_s.bitmask & %s_%s_BITMASK) &&\n"
             c_optarg_prefix uc_n;
           pr "      optargs_s.%s != NULL)\n" n;
-          pr "    guestfs___free_string_list ((char **) optargs_s.%s);\n" n
+          pr "    guestfs_int_free_string_list ((char **) optargs_s.%s);\n" n
         | OBool _ | OInt _ | OInt64 _ | OString _ -> ()
       ) (List.rev optargs);
       List.iter (
@@ -688,7 +688,7 @@ Guestfish will prompt for these separately."
             pr "  free_file_in (%s);\n" name;
             pr " out_%s:\n" name
         | StringList name | DeviceList name ->
-            pr "  guestfs___free_string_list (%s);\n" name;
+            pr "  guestfs_int_free_string_list (%s);\n" name;
             pr " out_%s:\n" name
         | Pointer _ -> assert false
       ) (List.rev args);
diff --git a/generator/java.ml b/generator/java.ml
index e9c5949..39231ad0 100644
--- a/generator/java.ml
+++ b/generator/java.ml
@@ -689,7 +689,7 @@ Java_com_redhat_et_libguestfs_GuestFS__1set_1event_1callback
     return -1;
   }
 
-  data = guestfs___safe_malloc (g, sizeof *data);
+  data = guestfs_int_safe_malloc (g, sizeof *data);
   (*env)->GetJavaVM (env, &data->jvm);
   data->method = method;
 
@@ -768,7 +768,7 @@ get_all_event_callbacks (guestfs_h *g, size_t *len_rtn)
   }
 
   /* Copy them into the return array. */
-  r = guestfs___safe_malloc (g, sizeof (struct callback_data *) * (*len_rtn));
+  r = guestfs_int_safe_malloc (g, sizeof (struct callback_data *) * (*len_rtn));
 
   i = 0;
   data = guestfs_first_private (g, &key);
@@ -953,7 +953,7 @@ get_all_event_callbacks (guestfs_h *g, size_t *len_rtn)
             pr "  %s_size = (*env)->GetArrayLength (env, j%s);\n" n n
         | StringList n | DeviceList n ->
             pr "  %s_len = (*env)->GetArrayLength (env, j%s);\n" n n;
-            pr "  %s = guestfs___safe_malloc (g, sizeof (char *) * (%s_len+1));\n" n n;
+            pr "  %s = guestfs_int_safe_malloc (g, sizeof (char *) * (%s_len+1));\n" n n;
             pr "  for (i = 0; i < %s_len; ++i) {\n" n;
             pr "    jobject o = (*env)->GetObjectArrayElement (env, j%s, i);\n"
               n;
@@ -979,7 +979,7 @@ get_all_event_callbacks (guestfs_h *g, size_t *len_rtn)
                 n n
           | OStringList n ->
             pr "  %s_len = (*env)->GetArrayLength (env, j%s);\n" n n;
-            pr "  %s = guestfs___safe_malloc (g, sizeof (char *) * (%s_len+1));\n" n n;
+            pr "  %s = guestfs_int_safe_malloc (g, sizeof (char *) * (%s_len+1));\n" n n;
             pr "  for (i = 0; i < %s_len; ++i) {\n" n;
             pr "    jobject o = (*env)->GetObjectArrayElement (env, j%s, i);\n"
               n;
diff --git a/generator/lua.ml b/generator/lua.ml
index 5d5619c..7e0708f 100644
--- a/generator/lua.ml
+++ b/generator/lua.ml
@@ -597,10 +597,10 @@ guestfs_lua_delete_event_callback (lua_State *L)
         pr "  free (r);\n"
       | RStringList _ ->
         pr "  push_string_list (L, r);\n";
-        pr "  guestfs___free_string_list (r);\n"
+        pr "  guestfs_int_free_string_list (r);\n"
       | RHashtable _ ->
         pr "  push_table (L, r);\n";
-        pr "  guestfs___free_string_list (r);\n"
+        pr "  guestfs_int_free_string_list (r);\n"
       | RStruct (_, typ) ->
         pr "  push_%s (L, r);\n" typ;
         pr "  guestfs_free_%s (r);\n" typ
diff --git a/generator/ocaml.ml b/generator/ocaml.ml
index bd27f7a..a0101d5 100644
--- a/generator/ocaml.ml
+++ b/generator/ocaml.ml
@@ -522,14 +522,14 @@ copy_table (char * const * argv)
         | Key n
         | GUID n ->
             (* Copy strings in case the GC moves them: RHBZ#604691 *)
-            pr "  char *%s = guestfs___safe_strdup (g, String_val (%sv));\n" n n
+            pr "  char *%s = guestfs_int_safe_strdup (g, String_val (%sv));\n" n n
         | OptString n ->
             pr "  char *%s =\n" n;
             pr "    %sv != Val_int (0) ?\n" n;
-            pr "      guestfs___safe_strdup (g, String_val (Field (%sv, 0))) : NULL;\n" n
+            pr "      guestfs_int_safe_strdup (g, String_val (Field (%sv, 0))) : NULL;\n" n
         | BufferIn n ->
             pr "  size_t %s_size = caml_string_length (%sv);\n" n n;
-            pr "  char *%s = guestfs___safe_memdup (g, String_val (%sv), %s_size);\n" n n n
+            pr "  char *%s = guestfs_int_safe_memdup (g, String_val (%sv), %s_size);\n" n n n
         | StringList n | DeviceList n ->
             pr "  char **%s = ocaml_guestfs_strings_val (g, %sv);\n" n n
         | Bool n ->
@@ -558,7 +558,7 @@ copy_table (char * const * argv)
              | OInt _ -> pr "Int_val (Field (%sv, 0))" n
              | OInt64 _ -> pr "Int64_val (Field (%sv, 0))" n
              | OString _ ->
-                 pr "guestfs___safe_strdup (g, String_val (Field (%sv, 0)))" n
+                 pr "guestfs_int_safe_strdup (g, String_val (Field (%sv, 0)))" n
              | OStringList n ->
                  pr "ocaml_guestfs_strings_val (g, Field (%sv, 0))\n" n
             );
@@ -608,7 +608,7 @@ copy_table (char * const * argv)
         | Key n | GUID n ->
             pr "  free (%s);\n" n
         | StringList n | DeviceList n ->
-            pr "  guestfs___free_string_list (%s);\n" n;
+            pr "  guestfs_int_free_string_list (%s);\n" n;
         | Bool _ | Int _ | Int64 _ | Pointer _ -> ()
       ) args;
       List.iter (
@@ -619,7 +619,7 @@ copy_table (char * const * argv)
             pr "    free ((char *) optargs_s.%s);\n" n
         | OStringList n ->
             pr "  if (%sv != Val_int (0))\n" n;
-            pr "    guestfs___free_string_list ((char **) optargs_s.%s);\n" n;
+            pr "    guestfs_int_free_string_list ((char **) optargs_s.%s);\n" n;
       ) optargs;
 
       (match errcode_of_ret ret with
diff --git a/generator/perl.ml b/generator/perl.ml
index 3da45fd..29d9ccc 100644
--- a/generator/perl.ml
+++ b/generator/perl.ml
@@ -176,7 +176,7 @@ get_all_event_callbacks (guestfs_h *g, size_t *len_rtn)
   }
 
   /* Copy them into the return array. */
-  r = guestfs___safe_malloc (g, sizeof (SV *) * (*len_rtn));
+  r = guestfs_int_safe_malloc (g, sizeof (SV *) * (*len_rtn));
 
   i = 0;
   cb = guestfs_first_private (g, &key);
@@ -476,7 +476,7 @@ PREINIT:
                pr "          /* Note av_len returns index of final element. */\n";
                pr "          len = av_len (av) + 1;\n";
                pr "\n";
-               pr "          r = guestfs___safe_malloc (g, (len+1) * sizeof (char *));\n";
+               pr "          r = guestfs_int_safe_malloc (g, (len+1) * sizeof (char *));\n";
                pr "          for (i = 0; i < len; ++i) {\n";
                pr "            svp = av_fetch (av, i, 0);\n";
                pr "            r[i] = SvPV_nolen (*svp);\n";
diff --git a/generator/python.ml b/generator/python.ml
index 07e87d2..626ddb4 100644
--- a/generator/python.ml
+++ b/generator/python.ml
@@ -475,7 +475,7 @@ put_table (char * const * const argv)
            pr "  free (r);\n"
        | RStringList _ ->
            pr "  py_r = put_string_list (r);\n";
-           pr "  guestfs___free_string_list (r);\n"
+           pr "  guestfs_int_free_string_list (r);\n"
        | RStruct (_, typ) ->
            pr "  py_r = put_%s (r);\n" typ;
            pr "  guestfs_free_%s (r);\n" typ
@@ -484,7 +484,7 @@ put_table (char * const * const argv)
            pr "  guestfs_free_%s_list (r);\n" typ
        | RHashtable n ->
            pr "  py_r = put_table (r);\n";
-           pr "  guestfs___free_string_list (r);\n"
+           pr "  guestfs_int_free_string_list (r);\n"
        | RBufferOut _ ->
            pr "#ifdef HAVE_PYSTRING_ASSTRING\n";
            pr "  py_r = PyString_FromStringAndSize (r, size);\n";
diff --git a/generator/ruby.ml b/generator/ruby.ml
index 88762ca..87c8b42 100644
--- a/generator/ruby.ml
+++ b/generator/ruby.ml
@@ -274,7 +274,7 @@ ruby_set_event_callback (VALUE gv, VALUE cbv, VALUE event_bitmaskv)
 
   event_bitmask = NUM2ULL (event_bitmaskv);
 
-  root = guestfs___safe_malloc (g, sizeof *root);
+  root = guestfs_int_safe_malloc (g, sizeof *root);
   *root = cbv;
 
   eh = guestfs_set_event_callback (g, ruby_event_callback_wrapper,
@@ -445,7 +445,7 @@ get_all_event_callbacks (guestfs_h *g, size_t *len_rtn)
   }
 
   /* Copy them into the return array. */
-  r = guestfs___safe_malloc (g, sizeof (VALUE *) * (*len_rtn));
+  r = guestfs_int_safe_malloc (g, sizeof (VALUE *) * (*len_rtn));
 
   i = 0;
   root = guestfs_first_private (g, &key);
diff --git a/generator/types.ml b/generator/types.ml
index 63aa235..0c189bc 100644
--- a/generator/types.ml
+++ b/generator/types.ml
@@ -187,7 +187,7 @@ and argt =
     (* const char * which represents a GUID string.
      *
      * It cannot be NULL, and it will be validated using
-     * guestfs___validate_guid.
+     * guestfs_int_validate_guid.
      *)
   | GUID of string
 
diff --git a/generator/xdr.ml b/generator/xdr.ml
index 257702a..78fab03 100644
--- a/generator/xdr.ml
+++ b/generator/xdr.ml
@@ -256,7 +256,7 @@ struct guestfs_chunk {
  *
  * Notes:
  *
- * (1) guestfs___recv_from_daemon assumes the XDR-encoded
+ * (1) guestfs_int_recv_from_daemon assumes the XDR-encoded
  * structure is 24 bytes long.
  *
  * (2) daemon/proto.c:async_safe_send_pulse assumes the progress
diff --git a/inspector/inspector.c b/inspector/inspector.c
index a9709c1..6a0f553 100644
--- a/inspector/inspector.c
+++ b/inspector/inspector.c
@@ -65,7 +65,7 @@ usage (int status)
 {
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   else {
     fprintf (stdout,
            _("%s: display information about a virtual machine\n"
@@ -86,8 +86,8 @@ usage (int status)
              "  -x                   Trace libguestfs API calls\n"
              "  --xpath query        Perform an XPath query\n"
              "For more information, see the manpage %s(1).\n"),
-             guestfs___program_name, guestfs___program_name, guestfs___program_name,
-             guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name,
+             guestfs_int_program_name);
   }
   exit (status);
 }
@@ -147,7 +147,7 @@ main (int argc, char *argv[])
         xpath = optarg;
       } else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -240,7 +240,7 @@ main (int argc, char *argv[])
   if (xpath) {
     if (drvs != NULL) {
       fprintf (stderr, _("%s: cannot use --xpath together with other options.\n"),
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
 
@@ -274,7 +274,7 @@ main (int argc, char *argv[])
     CLEANUP_FREE_STRING_LIST char **roots = guestfs_inspect_os (g);
     if (roots == NULL) {
       fprintf (stderr, _("%s: no operating system could be detected inside this disk image.\n\nThis may be because the file is not a disk image, or is not a virtual machine\nimage, or because the OS type is not understood by libguestfs.\n\nNOTE for Red Hat Enterprise Linux 6 users: for Windows guest support you must\ninstall the separate libguestfs-winsupport package.\n\nIf you feel this is an error, please file a bug report including as much\ninformation about the disk image as possible.\n"),
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
 
@@ -289,7 +289,7 @@ main (int argc, char *argv[])
 #define XMLERROR(code,e) do {                                           \
     if ((e) == (code)) {                                                \
       fprintf (stderr, _("%s: XML write error at \"%s\": %m\n"),        \
-               #e, guestfs___program_name);                                       \
+               #e, guestfs_int_program_name);                                       \
       exit (EXIT_FAILURE);                                              \
     }                                                                   \
   } while (0)
@@ -301,7 +301,7 @@ output (char **roots)
   if (ob == NULL) {
     fprintf (stderr,
              _("%s: xmlOutputBufferCreateFd: failed to open stdout\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
@@ -310,7 +310,7 @@ output (char **roots)
   if (xo == NULL) {
     fprintf (stderr,
              _("%s: xmlNewTextWriter: failed to create libxml2 writer\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
@@ -549,7 +549,7 @@ output_mountpoints (xmlTextWriterPtr xo, char *root)
   /* Sort by key length, shortest key first, and then name, so the
    * output is stable.
    */
-  qsort (mountpoints, guestfs___count_strings (mountpoints) / 2,
+  qsort (mountpoints, guestfs_int_count_strings (mountpoints) / 2,
          2 * sizeof (char *),
          compare_keys_len);
 
@@ -584,7 +584,7 @@ output_filesystems (xmlTextWriterPtr xo, char *root)
     exit (EXIT_FAILURE);
 
   /* Sort by name so the output is stable. */
-  qsort (filesystems, guestfs___count_strings (filesystems), sizeof (char *),
+  qsort (filesystems, guestfs_int_count_strings (filesystems), sizeof (char *),
          compare_keys);
 
   XMLERROR (-1, xmlTextWriterStartElement (xo, BAD_CAST "filesystems"));
@@ -648,7 +648,7 @@ output_drive_mappings (xmlTextWriterPtr xo, char *root)
 
   /* Sort by key. */
   qsort (drive_mappings,
-         guestfs___count_strings (drive_mappings) / 2, 2 * sizeof (char *),
+         guestfs_int_count_strings (drive_mappings) / 2, 2 * sizeof (char *),
          compare_keys_nocase);
 
   XMLERROR (-1, xmlTextWriterStartElement (xo, BAD_CAST "drive_mappings"));
@@ -768,21 +768,21 @@ do_xpath (const char *query)
 
   doc = xmlReadFd (STDIN_FILENO, NULL, "utf8", 0);
   if (doc == NULL) {
-    fprintf (stderr, _("%s: unable to parse XML from stdin\n"), guestfs___program_name);
+    fprintf (stderr, _("%s: unable to parse XML from stdin\n"), guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
   xpathCtx = xmlXPathNewContext (doc);
   if (xpathCtx == NULL) {
     fprintf (stderr, _("%s: unable to create new XPath context\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
   xpathObj = xmlXPathEvalExpression (BAD_CAST query, xpathCtx);
   if (xpathObj == NULL) {
     fprintf (stderr, _("%s: unable to evaluate XPath expression\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
@@ -794,26 +794,26 @@ do_xpath (const char *query)
 
     saveCtx = xmlSaveToFd (STDOUT_FILENO, NULL, XML_SAVE_NO_DECL);
     if (saveCtx == NULL) {
-      fprintf (stderr, _("%s: xmlSaveToFd failed\n"), guestfs___program_name);
+      fprintf (stderr, _("%s: xmlSaveToFd failed\n"), guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
 
     for (i = 0; i < (size_t) nodes->nodeNr; ++i) {
       CLEANUP_XMLFREEDOC xmlDocPtr wrdoc = xmlNewDoc (BAD_CAST "1.0");
       if (wrdoc == NULL) {
-        fprintf (stderr, _("%s: xmlNewDoc failed\n"), guestfs___program_name);
+        fprintf (stderr, _("%s: xmlNewDoc failed\n"), guestfs_int_program_name);
         exit (EXIT_FAILURE);
       }
       wrnode = xmlCopyNode (nodes->nodeTab[i], 1);
       if (wrnode == NULL) {
-        fprintf (stderr, _("%s: xmlCopyNode failed\n"), guestfs___program_name);
+        fprintf (stderr, _("%s: xmlCopyNode failed\n"), guestfs_int_program_name);
         exit (EXIT_FAILURE);
       }
 
       xmlDocSetRootElement (wrdoc, wrnode);
 
       if (xmlSaveDoc (saveCtx, wrdoc) == -1) {
-        fprintf (stderr, _("%s: xmlSaveDoc failed\n"), guestfs___program_name);
+        fprintf (stderr, _("%s: xmlSaveDoc failed\n"), guestfs_int_program_name);
         exit (EXIT_FAILURE);
       }
     }
diff --git a/make-fs/make-fs.c b/make-fs/make-fs.c
index 22658fb..128d51e 100644
--- a/make-fs/make-fs.c
+++ b/make-fs/make-fs.c
@@ -71,7 +71,7 @@ usage (int status)
 {
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   else {
     fprintf (stdout,
            _("%s: make a filesystem from a tar archive or files\n"
@@ -92,8 +92,8 @@ usage (int status)
              "  -V|--version           Display version and exit\n"
              "  -x                     Trace libguestfs API calls\n"
              "For more information, see the manpage %s(1).\n"),
-             guestfs___program_name, guestfs___program_name, guestfs___program_name, guestfs___program_name,
-             guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name,
+             guestfs_int_program_name);
   }
   exit (status);
 }
@@ -140,7 +140,7 @@ main (int argc, char *argv[])
           partition = optarg;
       } else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -179,7 +179,7 @@ main (int argc, char *argv[])
 
   if (optind + 2 != argc) {
     fprintf (stderr, _("%s: missing input and output arguments on the command line\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     usage (EXIT_FAILURE);
   }
 
@@ -197,7 +197,7 @@ check_ntfs_available (void)
   if (STREQ (type, "ntfs") &&
       guestfs_feature_available (g, (char **) ntfs_features) == 0) {
     fprintf (stderr, _("%s: NTFS support was disabled when libguestfs was compiled\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     return -1;
   }
 
@@ -246,7 +246,7 @@ exec_command (char **argv, const char *file)
       return -1;
     }
     if (!WIFEXITED (status) || WEXITSTATUS (status) != 0) {
-      fprintf (stderr, _("%s: %s command failed\n"), guestfs___program_name, argv[0]);
+      fprintf (stderr, _("%s: %s command failed\n"), guestfs_int_program_name, argv[0]);
       return -1;
     }
     return 0;
@@ -303,7 +303,7 @@ exec_command_count_output (char **argv, uint64_t *bytes_rtn)
       return -1;
     }
     if (!WIFEXITED (status) || WEXITSTATUS (status) != 0) {
-      fprintf (stderr, _("%s: %s command failed\n"), guestfs___program_name, argv[0]);
+      fprintf (stderr, _("%s: %s command failed\n"), guestfs_int_program_name, argv[0]);
       return -1;
     }
     return 0;
@@ -428,7 +428,7 @@ estimate_input (const char *input, uint64_t *estimate_rtn, char **ifmt_rtn)
 
     if (sscanf (line, "%" SCNu64, estimate_rtn) != 1) {
       fprintf (stderr, _("%s: cannot parse the output of 'du' command: %s\n"),
-               guestfs___program_name, line);
+               guestfs_int_program_name, line);
       return -1;
     }
   }
@@ -463,7 +463,7 @@ estimate_input (const char *input, uint64_t *estimate_rtn, char **ifmt_rtn)
 
     if (strstr (line, "tar archive") == NULL) {
       fprintf (stderr, _("%s: %s: input is not a directory, tar archive or compressed tar archive\n"),
-               guestfs___program_name, input);
+               guestfs_int_program_name, input);
       return -1;
     }
 
@@ -494,7 +494,7 @@ estimate_input (const char *input, uint64_t *estimate_rtn, char **ifmt_rtn)
       }
       else {
         fprintf (stderr, _("%s: %s: unknown compressed input format (%s)\n"),
-                 guestfs___program_name, input, line);
+                 guestfs_int_program_name, input, line);
         return -1;
       }
 
@@ -617,7 +617,7 @@ parse_size (const char *str, uint64_t estimate, uint64_t *size_rtn)
   if (xerr != LONGINT_OK) {
     fprintf (stderr,
              _("%s: %s: invalid size parameter '%s' (%s returned %d)\n"),
-             guestfs___program_name, "parse_size", str, "xstrtoull", xerr);
+             guestfs_int_program_name, "parse_size", str, "xstrtoull", xerr);
     return -1;
   }
 
@@ -759,7 +759,7 @@ do_make_fs (const char *input, const char *output_str)
     if (r == -1) {
       /* Provide more guidance in the error message (RHBZ#823883). */
       fprintf (stderr, "%s: 'mkfs' (create filesystem) operation failed.\n",
-               guestfs___program_name);
+               guestfs_int_program_name);
       if (STREQ (type, "fat"))
         fprintf (stderr, "Instead of 'fat', try 'vfat' (long filenames) or 'msdos' (short filenames).\n");
       else
@@ -816,7 +816,7 @@ do_make_fs (const char *input, const char *output_str)
       return -1;
     }
     if (!WIFEXITED (status) || WEXITSTATUS (status) != 0) {
-      fprintf (stderr, _("%s: subprocess failed\n"), guestfs___program_name);
+      fprintf (stderr, _("%s: subprocess failed\n"), guestfs_int_program_name);
       return -1;
     }
   }
diff --git a/mllib/uri-c.c b/mllib/uri-c.c
index 2ce4021..f69ab66 100644
--- a/mllib/uri-c.c
+++ b/mllib/uri-c.c
@@ -62,7 +62,7 @@ virt_resize_parse_uri (value argv /* arg value, not an array! */)
   /* server : string array option */
   if (uri.server) {
     ssv = caml_copy_string_array ((const char **) uri.server);
-    guestfs___free_string_list (uri.server);
+    guestfs_int_free_string_list (uri.server);
     ov = caml_alloc (1, 0);
     Store_field (ov, 0, ssv);
   }
diff --git a/ocaml/guestfs-c.c b/ocaml/guestfs-c.c
index 7fbe221..0ebb84c 100644
--- a/ocaml/guestfs-c.c
+++ b/ocaml/guestfs-c.c
@@ -179,7 +179,7 @@ ocaml_guestfs_create (value environmentv, value close_on_exitv, value unitv)
   /* Store the OCaml handle into the C handle.  This is only so we can
    * map the C handle to the OCaml handle in event_callback_wrapper.
    */
-  v = guestfs___safe_malloc (g, sizeof *v);
+  v = guestfs_int_safe_malloc (g, sizeof *v);
   *v = gv;
   /* XXX This global root is generational, but we cannot rely on every
    * user having the OCaml 3.11 version which supports this.
@@ -212,9 +212,9 @@ ocaml_guestfs_strings_val (guestfs_h *g, value sv)
   char **r;
   size_t i;
 
-  r = guestfs___safe_malloc (g, sizeof (char *) * (Wosize_val (sv) + 1));
+  r = guestfs_int_safe_malloc (g, sizeof (char *) * (Wosize_val (sv) + 1));
   for (i = 0; i < Wosize_val (sv); ++i)
-    r[i] = guestfs___safe_strdup (g, String_val (Field (sv, i)));
+    r[i] = guestfs_int_safe_strdup (g, String_val (Field (sv, i)));
   r[i] = NULL;
 
   CAMLreturnT (char **, r);
@@ -246,7 +246,7 @@ ocaml_guestfs_set_event_callback (value gv, value closure, value events)
 
   event_bitmask = event_bitmask_of_event_list (events);
 
-  value *root = guestfs___safe_malloc (g, sizeof *root);
+  value *root = guestfs_int_safe_malloc (g, sizeof *root);
   *root = closure;
 
   eh = guestfs_set_event_callback (g, event_callback_wrapper,
@@ -329,7 +329,7 @@ get_all_event_callbacks (guestfs_h *g, size_t *len_rtn)
   }
 
   /* Copy them into the return array. */
-  r = guestfs___safe_malloc (g, sizeof (value *) * (*len_rtn));
+  r = guestfs_int_safe_malloc (g, sizeof (value *) * (*len_rtn));
 
   i = 0;
   root = guestfs_first_private (g, &key);
diff --git a/p2v/config.c b/p2v/config.c
index abc91be..495bca2 100644
--- a/p2v/config.c
+++ b/p2v/config.c
@@ -67,13 +67,13 @@ copy_config (struct config *old)
   if (c->guestname)
     c->guestname = strdup (c->guestname);
   if (c->disks)
-    c->disks = guestfs___copy_string_list (c->disks);
+    c->disks = guestfs_int_copy_string_list (c->disks);
   if (c->removable)
-    c->removable = guestfs___copy_string_list (c->removable);
+    c->removable = guestfs_int_copy_string_list (c->removable);
   if (c->interfaces)
-    c->interfaces = guestfs___copy_string_list (c->interfaces);
+    c->interfaces = guestfs_int_copy_string_list (c->interfaces);
   if (c->network_map)
-    c->network_map = guestfs___copy_string_list (c->network_map);
+    c->network_map = guestfs_int_copy_string_list (c->network_map);
   if (c->output)
     c->output = strdup (c->output);
   if (c->output_connection)
@@ -93,10 +93,10 @@ free_config (struct config *c)
   free (c->username);
   free (c->password);
   free (c->guestname);
-  guestfs___free_string_list (c->disks);
-  guestfs___free_string_list (c->removable);
-  guestfs___free_string_list (c->interfaces);
-  guestfs___free_string_list (c->network_map);
+  guestfs_int_free_string_list (c->disks);
+  guestfs_int_free_string_list (c->removable);
+  guestfs_int_free_string_list (c->interfaces);
+  guestfs_int_free_string_list (c->network_map);
   free (c->output);
   free (c->output_connection);
   free (c->output_format);
diff --git a/p2v/conversion.c b/p2v/conversion.c
index e281e45..4ebdfc4 100644
--- a/p2v/conversion.c
+++ b/p2v/conversion.c
@@ -102,7 +102,7 @@ start_conversion (struct config *config,
   int ret = -1;
   int status;
   size_t i, len;
-  size_t nr_disks = guestfs___count_strings (config->disks);
+  size_t nr_disks = guestfs_int_count_strings (config->disks);
   struct data_conn data_conns[nr_disks];
   CLEANUP_FREE char *remote_dir = NULL, *libvirt_xml = NULL;
   time_t now;
@@ -193,7 +193,7 @@ start_conversion (struct config *config,
     exit (EXIT_FAILURE);
   }
   len = strlen (remote_dir);
-  guestfs___random_string (&remote_dir[len-8], 8);
+  guestfs_int_random_string (&remote_dir[len-8], 8);
   if (notify_ui)
     notify_ui (NOTIFY_LOG_DIR, remote_dir);
 
@@ -203,7 +203,7 @@ start_conversion (struct config *config,
     goto out;
 
 #if DEBUG_STDERR
-  fprintf (stderr, "%s: libvirt XML:\n%s", guestfs___program_name, libvirt_xml);
+  fprintf (stderr, "%s: libvirt XML:\n%s", guestfs_int_program_name, libvirt_xml);
 #endif
 
   /* Open the control connection and start conversion */
@@ -668,7 +668,7 @@ generate_libvirt_xml (struct config *config, struct data_conn *data_conns)
         if (config->disks[i][0] == '/') {
         target_sd:
           memcpy (target_dev, "sd", 2);
-          guestfs___drive_name (i, &target_dev[2]);
+          guestfs_int_drive_name (i, &target_dev[2]);
         } else {
           if (strlen (config->disks[i]) <= sizeof (target_dev) - 1)
             strcpy (target_dev, config->disks[i]);
diff --git a/p2v/gui.c b/p2v/gui.c
index 4d9363e..5065560 100644
--- a/p2v/gui.c
+++ b/p2v/gui.c
@@ -109,7 +109,7 @@ create_connection_dialog (struct config *config)
   char port_str[64];
 
   conn_dlg = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (conn_dlg), guestfs___program_name);
+  gtk_window_set_title (GTK_WINDOW (conn_dlg), guestfs_int_program_name);
   gtk_window_set_resizable (GTK_WINDOW (conn_dlg), FALSE);
 
   /* The main dialog area. */
@@ -343,7 +343,7 @@ static void
 about_button_clicked (GtkWidget *w, gpointer data)
 {
   gtk_show_about_dialog (GTK_WINDOW (conn_dlg),
-                         "program-name", guestfs___program_name,
+                         "program-name", guestfs_int_program_name,
                          "version", PACKAGE_VERSION,
                          "copyright", "\u00A9 2009-2014 Red Hat Inc.",
                          "comments", "Convert a physical machine to use KVM",
@@ -414,7 +414,7 @@ create_conversion_dialog (struct config *config)
   char memory_str[64];
 
   conv_dlg = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (conv_dlg), guestfs___program_name);
+  gtk_window_set_title (GTK_WINDOW (conv_dlg), guestfs_int_program_name);
   gtk_window_set_resizable (GTK_WINDOW (conv_dlg), FALSE);
   /* XXX It would be nice not to have to set this explicitly, but
    * if we don't then Gtk chooses a very small window.
@@ -940,15 +940,15 @@ set_from_ui_generic (char **all, char ***ret, GtkTreeView *list)
   size_t i, j;
 
   if (all == NULL) {
-    guestfs___free_string_list (*ret);
+    guestfs_int_free_string_list (*ret);
     *ret = NULL;
     return;
   }
 
   model = gtk_tree_view_get_model (list);
 
-  guestfs___free_string_list (*ret);
-  *ret = malloc ((1 + guestfs___count_strings (all)) * sizeof (char *));
+  guestfs_int_free_string_list (*ret);
+  *ret = malloc ((1 + guestfs_int_count_strings (all)) * sizeof (char *));
   if (*ret == NULL) {
     perror ("malloc");
     exit (EXIT_FAILURE);
@@ -1001,7 +1001,7 @@ set_network_map_from_ui (struct config *config)
   size_t i, j;
 
   if (all_interfaces == NULL) {
-    guestfs___free_string_list (config->network_map);
+    guestfs_int_free_string_list (config->network_map);
     config->network_map = NULL;
     return;
   }
@@ -1009,9 +1009,9 @@ set_network_map_from_ui (struct config *config)
   list = GTK_TREE_VIEW (interfaces_list);
   model = gtk_tree_view_get_model (list);
 
-  guestfs___free_string_list (config->network_map);
+  guestfs_int_free_string_list (config->network_map);
   config->network_map =
-    malloc ((1 + guestfs___count_strings (all_interfaces))
+    malloc ((1 + guestfs_int_count_strings (all_interfaces))
             * sizeof (char *));
   if (config->network_map == NULL) {
     perror ("malloc");
@@ -1065,7 +1065,7 @@ static void
 create_running_dialog (void)
 {
   run_dlg = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (run_dlg), guestfs___program_name);
+  gtk_window_set_title (GTK_WINDOW (run_dlg), guestfs_int_program_name);
   gtk_window_set_resizable (GTK_WINDOW (run_dlg), FALSE);
 
   /* The main dialog area. */
@@ -1219,7 +1219,7 @@ start_conversion_clicked (GtkWidget *w, gpointer data)
   set_disks_from_ui (config);
 
   /* The list of disks must be non-empty. */
-  if (config->disks == NULL || guestfs___count_strings (config->disks) == 0) {
+  if (config->disks == NULL || guestfs_int_count_strings (config->disks) == 0) {
     dlg = gtk_message_dialog_new (GTK_WINDOW (conv_dlg),
                                   GTK_DIALOG_DESTROY_WITH_PARENT,
                                   GTK_MESSAGE_ERROR,
@@ -1360,7 +1360,7 @@ notify_ui_callback (int type, const char *data)
   default:
     fprintf (stderr,
              "%s: unknown message during conversion: type=%d data=%s\n",
-             guestfs___program_name, type, data);
+             guestfs_int_program_name, type, data);
   }
 
   gdk_threads_leave ();
diff --git a/p2v/kernel.c b/p2v/kernel.c
index 8333cf3..481ac78 100644
--- a/p2v/kernel.c
+++ b/p2v/kernel.c
@@ -52,7 +52,7 @@ kernel_configuration (struct config *config, const char *cmdline)
     r += 5+4;
     if (sscanf (r, "%d", &config->port) != 1) {
       fprintf (stderr, "%s: cannot parse p2v.port from kernel command line",
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
   }
@@ -84,7 +84,7 @@ kernel_configuration (struct config *config, const char *cmdline)
     const char *err = get_ssh_error ();
 
     fprintf (stderr, "%s: error opening control connection to %s:%d: %s\n",
-             guestfs___program_name, config->server, config->port, err);
+             guestfs_int_program_name, config->server, config->port, err);
     exit (EXIT_FAILURE);
   }
 
@@ -101,7 +101,7 @@ kernel_configuration (struct config *config, const char *cmdline)
     r += 5+5;
     if (sscanf (r, "%d", &config->vcpus) != 1) {
       fprintf (stderr, "%s: cannot parse p2v.vcpus from kernel command line\n",
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
   }
@@ -113,7 +113,7 @@ kernel_configuration (struct config *config, const char *cmdline)
     r += 5+6;
     if (sscanf (r, "%" SCNu64 "%c", &config->memory, mem_code) != 1) {
       fprintf (stderr, "%s: cannot parse p2v.memory from kernel command line\n",
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
     config->memory *= 1024;
@@ -123,7 +123,7 @@ kernel_configuration (struct config *config, const char *cmdline)
       config->memory *= 1024;
     if (mem_code[0] != 'M' && mem_code[0] != 'G') {
       fprintf (stderr, "%s: p2v.memory on kernel command line must be followed by 'G' or 'M'\n",
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
   }
@@ -135,8 +135,8 @@ kernel_configuration (struct config *config, const char *cmdline)
     r += 5+5;
     len = strcspn (r, " ");
     t = strndup (r, len);
-    guestfs___free_string_list (config->disks);
-    config->disks = guestfs___split_string (',', t);
+    guestfs_int_free_string_list (config->disks);
+    config->disks = guestfs_int_split_string (',', t);
   }
 
   r = strstr (cmdline, "p2v.removable=");
@@ -146,8 +146,8 @@ kernel_configuration (struct config *config, const char *cmdline)
     r += 5+9;
     len = strcspn (r, " ");
     t = strndup (r, len);
-    guestfs___free_string_list (config->removable);
-    config->removable = guestfs___split_string (',', t);
+    guestfs_int_free_string_list (config->removable);
+    config->removable = guestfs_int_split_string (',', t);
   }
 
   r = strstr (cmdline, "p2v.interfaces=");
@@ -157,8 +157,8 @@ kernel_configuration (struct config *config, const char *cmdline)
     r += 5+10;
     len = strcspn (r, " ");
     t = strndup (r, len);
-    guestfs___free_string_list (config->interfaces);
-    config->interfaces = guestfs___split_string (',', t);
+    guestfs_int_free_string_list (config->interfaces);
+    config->interfaces = guestfs_int_split_string (',', t);
   }
 
   r = strstr (cmdline, "p2v.network=");
@@ -168,8 +168,8 @@ kernel_configuration (struct config *config, const char *cmdline)
     r += 5+7;
     len = strcspn (r, " ");
     t = strndup (r, len);
-    guestfs___free_string_list (config->network_map);
-    config->network_map = guestfs___split_string (',', t);
+    guestfs_int_free_string_list (config->network_map);
+    config->network_map = guestfs_int_split_string (',', t);
   }
 
   r = strstr (cmdline, "p2v.o=");
@@ -217,7 +217,7 @@ kernel_configuration (struct config *config, const char *cmdline)
     const char *err = get_conversion_error ();
 
     fprintf (stderr, "%s: error during conversion: %s\n",
-             guestfs___program_name, err);
+             guestfs_int_program_name, err);
     exit (EXIT_FAILURE);
   }
 }
@@ -227,7 +227,7 @@ notify_ui_callback (int type, const char *data)
 {
   switch (type) {
   case NOTIFY_LOG_DIR:
-    printf ("%s: remote log directory location: %s\n", guestfs___program_name, data);
+    printf ("%s: remote log directory location: %s\n", guestfs_int_program_name, data);
     break;
 
   case NOTIFY_REMOTE_MESSAGE:
@@ -235,11 +235,11 @@ notify_ui_callback (int type, const char *data)
     break;
 
   case NOTIFY_STATUS:
-    printf ("%s: %s\n", guestfs___program_name, data);
+    printf ("%s: %s\n", guestfs_int_program_name, data);
     break;
 
   default:
     printf ("%s: unknown message during conversion: type=%d data=%s\n",
-            guestfs___program_name, type, data);
+            guestfs_int_program_name, type, data);
   }
 }
diff --git a/p2v/main.c b/p2v/main.c
index 4e11c0a..6d71dd4 100644
--- a/p2v/main.c
+++ b/p2v/main.c
@@ -63,7 +63,7 @@ usage (int status)
 {
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   else {
     fprintf (stdout,
            _("%s: Convert a physical machine to use KVM\n"
@@ -76,7 +76,7 @@ usage (int status)
              "  -v|--verbose           Verbose messages\n"
              "  -V|--version           Display version and exit\n"
              "For more information, see the manpage %s(1).\n"),
-             guestfs___program_name, guestfs___program_name, guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name);
   }
   exit (status);
 }
@@ -124,7 +124,7 @@ main (int argc, char *argv[])
       }
       else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -134,7 +134,7 @@ main (int argc, char *argv[])
       break;
 
     case 'V':
-      printf ("%s %s\n", guestfs___program_name, PACKAGE_VERSION);
+      printf ("%s %s\n", guestfs_int_program_name, PACKAGE_VERSION);
       exit (EXIT_SUCCESS);
 
     case HELP_OPTION:
@@ -147,7 +147,7 @@ main (int argc, char *argv[])
 
   if (optind != argc) {
     fprintf (stderr, _("%s: unused arguments on the command line\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
     usage (EXIT_FAILURE);
   }
 
@@ -197,7 +197,7 @@ set_config_defaults (struct config *config)
   if (gethostname (hostname, sizeof hostname) == -1) {
     perror ("gethostname");
     /* Generate a simple random name. */
-    if (guestfs___random_string (hostname, 8) == -1) {
+    if (guestfs_int_random_string (hostname, 8) == -1) {
       perror ("/dev/urandom");
       exit (EXIT_FAILURE);
     }
@@ -259,12 +259,12 @@ set_config_defaults (struct config *config)
     config->flags = 0;
 
   find_all_disks ();
-  config->disks = guestfs___copy_string_list (all_disks);
+  config->disks = guestfs_int_copy_string_list (all_disks);
   if (all_removable)
-    config->removable = guestfs___copy_string_list (all_removable);
+    config->removable = guestfs_int_copy_string_list (all_removable);
   find_all_interfaces ();
   if (all_interfaces)
-    config->interfaces = guestfs___copy_string_list (all_interfaces);
+    config->interfaces = guestfs_int_copy_string_list (all_interfaces);
 
   /* Default output drops the guest onto /var/tmp on the conversion
    * server, a hopefully safe default.
@@ -429,7 +429,7 @@ find_all_disks (void)
 
   if (all_disks == NULL) {
     fprintf (stderr, "%s: error: no non-removable disks were discovered on this machine.\n",
-             guestfs___program_name);
+             guestfs_int_program_name);
     fprintf (stderr, "virt-p2v looked in /sys/block.\n");
     fprintf (stderr, "This is a fatal error and virt-p2v cannot continue.\n");
     exit (EXIT_FAILURE);
diff --git a/p2v/ssh.c b/p2v/ssh.c
index 3c1d2f7..9a596ab 100644
--- a/p2v/ssh.c
+++ b/p2v/ssh.c
@@ -162,7 +162,7 @@ start_ssh (struct config *config, char **extra_args, int wait_prompt)
   /* Create the ssh argument array. */
   nr_args = 0;
   if (extra_args != NULL)
-    nr_args = guestfs___count_strings (extra_args);
+    nr_args = guestfs_int_count_strings (extra_args);
 
   nr_args += 11;
   args = malloc (sizeof (char *) * nr_args);
@@ -248,7 +248,7 @@ start_ssh (struct config *config, char **extra_args, int wait_prompt)
     const char *matched;
     int r;
 
-    if (guestfs___random_string (magic, 8) == -1) {
+    if (guestfs_int_random_string (magic, 8) == -1) {
       set_ssh_error ("random_string: %m");
       mexp_close (h);
       return NULL;
@@ -372,7 +372,7 @@ test_connection (struct config *config)
       sscanf (release_str, "%d", &v2v_release);
 #if DEBUG_STDERR
       fprintf (stderr, "%s: remote virt-v2v version: %d.%d.%d\n",
-               guestfs___program_name, v2v_major, v2v_minor, v2v_release);
+               guestfs_int_program_name, v2v_major, v2v_minor, v2v_release);
 #endif
       /* This is an internal error.  Need to check this here so we
        * don't confuse it with the no-version case below.
@@ -551,7 +551,7 @@ add_option (const char *type, char ***drivers, const char *name, size_t len)
   if (*drivers == NULL)
     n = 0;
   else
-    n = guestfs___count_strings (*drivers);
+    n = guestfs_int_count_strings (*drivers);
 
   n++;
 
@@ -570,7 +570,7 @@ add_option (const char *type, char ***drivers, const char *name, size_t len)
 
 #if DEBUG_STDERR
   fprintf (stderr, "%s: remote virt-v2v supports %s driver %s\n",
-           guestfs___program_name, type, (*drivers)[n-1]);
+           guestfs_int_program_name, type, (*drivers)[n-1]);
 #endif
 }
 
@@ -696,7 +696,7 @@ start_remote_connection (struct config *config,
   mexp_h *h;
   char magic[9];
 
-  if (guestfs___random_string (magic, 8) == -1) {
+  if (guestfs_int_random_string (magic, 8) == -1) {
     perror ("random_string");
     return NULL;
   }
diff --git a/po-docs/ja.po b/po-docs/ja.po
index 75781a0..c7d67a0 100644
--- a/po-docs/ja.po
+++ b/po-docs/ja.po
@@ -13941,9 +13941,9 @@ msgid ""
 " xxxx (+0):\tguestfs_create \n"
 " xxxx (+29):\tguestfs_set_pgroup g=0x17a9de0 pgroup=0x1\n"
 " xxxx (+9):\tguestfs_add_drive_opts_argv g=0x17a9de0 [...]\n"
-" xxxx (+8):\tguestfs___safe_strdup g=0x17a9de0 str=0x7f8a153bed5d\n"
-" xxxx (+19):\tguestfs___safe_malloc g=0x17a9de0 nbytes=0x38\n"
-" xxxx (+5):\tguestfs___safe_strdup g=0x17a9de0 str=0x17a9f60\n"
+" xxxx (+8):\tguestfs_int_safe_strdup g=0x17a9de0 str=0x7f8a153bed5d\n"
+" xxxx (+19):\tguestfs_int_safe_malloc g=0x17a9de0 nbytes=0x38\n"
+" xxxx (+5):\tguestfs_int_safe_strdup g=0x17a9de0 str=0x17a9f60\n"
 " xxxx (+10):\tguestfs_launch g=0x17a9de0\n"
 " xxxx (+4):\tlaunch_start \n"
 " [etc]\n"
diff --git a/po-docs/libguestfs-docs.pot b/po-docs/libguestfs-docs.pot
index f76ed4e..1f1fb8c 100644
--- a/po-docs/libguestfs-docs.pot
+++ b/po-docs/libguestfs-docs.pot
@@ -12289,9 +12289,9 @@ msgid ""
 " xxxx (+0):\tguestfs_create \n"
 " xxxx (+29):\tguestfs_set_pgroup g=0x17a9de0 pgroup=0x1\n"
 " xxxx (+9):\tguestfs_add_drive_opts_argv g=0x17a9de0 [...]\n"
-" xxxx (+8):\tguestfs___safe_strdup g=0x17a9de0 str=0x7f8a153bed5d\n"
-" xxxx (+19):\tguestfs___safe_malloc g=0x17a9de0 nbytes=0x38\n"
-" xxxx (+5):\tguestfs___safe_strdup g=0x17a9de0 str=0x17a9f60\n"
+" xxxx (+8):\tguestfs_int_safe_strdup g=0x17a9de0 str=0x7f8a153bed5d\n"
+" xxxx (+19):\tguestfs_int_safe_malloc g=0x17a9de0 nbytes=0x38\n"
+" xxxx (+5):\tguestfs_int_safe_strdup g=0x17a9de0 str=0x17a9f60\n"
 " xxxx (+10):\tguestfs_launch g=0x17a9de0\n"
 " xxxx (+4):\tlaunch_start \n"
 " [etc]\n"
diff --git a/po-docs/uk.po b/po-docs/uk.po
index 65fe216..ab16832 100644
--- a/po-docs/uk.po
+++ b/po-docs/uk.po
@@ -14067,9 +14067,9 @@ msgid ""
 " xxxx (+0):\tguestfs_create \n"
 " xxxx (+29):\tguestfs_set_pgroup g=0x17a9de0 pgroup=0x1\n"
 " xxxx (+9):\tguestfs_add_drive_opts_argv g=0x17a9de0 [...]\n"
-" xxxx (+8):\tguestfs___safe_strdup g=0x17a9de0 str=0x7f8a153bed5d\n"
-" xxxx (+19):\tguestfs___safe_malloc g=0x17a9de0 nbytes=0x38\n"
-" xxxx (+5):\tguestfs___safe_strdup g=0x17a9de0 str=0x17a9f60\n"
+" xxxx (+8):\tguestfs_int_safe_strdup g=0x17a9de0 str=0x7f8a153bed5d\n"
+" xxxx (+19):\tguestfs_int_safe_malloc g=0x17a9de0 nbytes=0x38\n"
+" xxxx (+5):\tguestfs_int_safe_strdup g=0x17a9de0 str=0x17a9f60\n"
 " xxxx (+10):\tguestfs_launch g=0x17a9de0\n"
 " xxxx (+4):\tlaunch_start \n"
 " [etc]\n"
@@ -14078,9 +14078,9 @@ msgstr ""
 " xxxx (+0):\tguestfs_create \n"
 " xxxx (+29):\tguestfs_set_pgroup g=0x17a9de0 pgroup=0x1\n"
 " xxxx (+9):\tguestfs_add_drive_opts_argv g=0x17a9de0 [...]\n"
-" xxxx (+8):\tguestfs___safe_strdup g=0x17a9de0 str=0x7f8a153bed5d\n"
-" xxxx (+19):\tguestfs___safe_malloc g=0x17a9de0 nbytes=0x38\n"
-" xxxx (+5):\tguestfs___safe_strdup g=0x17a9de0 str=0x17a9f60\n"
+" xxxx (+8):\tguestfs_int_safe_strdup g=0x17a9de0 str=0x7f8a153bed5d\n"
+" xxxx (+19):\tguestfs_int_safe_malloc g=0x17a9de0 nbytes=0x38\n"
+" xxxx (+5):\tguestfs_int_safe_strdup g=0x17a9de0 str=0x17a9f60\n"
 " xxxx (+10):\tguestfs_launch g=0x17a9de0\n"
 " xxxx (+4):\tlaunch_start \n"
 " [etc]\n"
diff --git a/python/guestfs-py-byhand.c b/python/guestfs-py-byhand.c
index b071f81..cc16cb7 100644
--- a/python/guestfs-py-byhand.c
+++ b/python/guestfs-py-byhand.c
@@ -251,7 +251,7 @@ get_all_event_callbacks (guestfs_h *g, size_t *len_rtn)
   }
 
   /* Copy them into the return array. */
-  r = guestfs___safe_malloc (g, sizeof (PyObject *) * (*len_rtn));
+  r = guestfs_int_safe_malloc (g, sizeof (PyObject *) * (*len_rtn));
 
   i = 0;
   cb = guestfs_first_private (g, &key);
diff --git a/rescue/rescue.c b/rescue/rescue.c
index 541e42b..4eb6b00 100644
--- a/rescue/rescue.c
+++ b/rescue/rescue.c
@@ -54,7 +54,7 @@ usage (int status)
 {
   if (status != EXIT_SUCCESS)
     fprintf (stderr, _("Try `%s --help' for more information.\n"),
-             guestfs___program_name);
+             guestfs_int_program_name);
   else {
     fprintf (stdout,
            _("%s: Run a rescue shell on a virtual machine\n"
@@ -81,8 +81,8 @@ usage (int status)
              "  -w|--rw              Mount read-write\n"
              "  -x                   Trace libguestfs API calls\n"
              "For more information, see the manpage %s(1).\n"),
-             guestfs___program_name, guestfs___program_name, guestfs___program_name,
-             guestfs___program_name);
+             guestfs_int_program_name, guestfs_int_program_name, guestfs_int_program_name,
+             guestfs_int_program_name);
   }
   exit (status);
 }
@@ -157,12 +157,12 @@ main (int argc, char *argv[])
       } else if (STREQ (long_options[option_index].name, "smp")) {
         if (sscanf (optarg, "%d", &smp) != 1) {
           fprintf (stderr, _("%s: could not parse --smp parameter '%s'\n"),
-                   guestfs___program_name, optarg);
+                   guestfs_int_program_name, optarg);
           exit (EXIT_FAILURE);
         }
         if (smp < 1) {
           fprintf (stderr, _("%s: --smp parameter '%s' should be >= 1\n"),
-                   guestfs___program_name, optarg);
+                   guestfs_int_program_name, optarg);
           exit (EXIT_FAILURE);
         }
       } else if (STREQ (long_options[option_index].name, "suggest")) {
@@ -175,20 +175,20 @@ main (int argc, char *argv[])
           if (sscanf (optarg, "%d", &n) != 1) {
             fprintf (stderr,
                      _("%s: could not parse --scratch parameter '%s'\n"),
-                     guestfs___program_name, optarg);
+                     guestfs_int_program_name, optarg);
             exit (EXIT_FAILURE);
           }
           if (n < 1) {
             fprintf (stderr,
                      _("%s: --scratch parameter '%s' should be >= 1\n"),
-                     guestfs___program_name, optarg);
+                     guestfs_int_program_name, optarg);
             exit (EXIT_FAILURE);
           }
           add_scratch_disks (n, &drvs);
         }
       } else {
         fprintf (stderr, _("%s: unknown long option: %s (%d)\n"),
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -208,7 +208,7 @@ main (int argc, char *argv[])
     case 'm':
       if (sscanf (optarg, "%d", &memsize) != 1) {
         fprintf (stderr, _("%s: could not parse memory size '%s'\n"),
-                 guestfs___program_name, optarg);
+                 guestfs_int_program_name, optarg);
         exit (EXIT_FAILURE);
       }
       break;
@@ -316,7 +316,7 @@ main (int argc, char *argv[])
           STRPREFIX (backend, "libvirt:")) {
         fprintf (stderr, _("%s: warning: virt-rescue doesn't work with the libvirt backend\n"
                            "at the moment.  As a workaround, forcing backend = 'direct'.\n"),
-                 guestfs___program_name);
+                 guestfs_int_program_name);
         if (guestfs_set_backend (g, "direct") == -1)
           exit (EXIT_FAILURE);
       }
@@ -443,7 +443,7 @@ do_suggestion (struct drv *drvs)
     /* Sort by key length, shortest key first, so that we end up
      * mounting the filesystems in the correct order.
      */
-    qsort (mps, guestfs___count_strings (mps) / 2, 2 * sizeof (char *),
+    qsort (mps, guestfs_int_count_strings (mps) / 2, 2 * sizeof (char *),
            compare_keys_len);
 
     for (j = 0; mps[j] != NULL; j += 2)
diff --git a/src/actions-support.c b/src/actions-support.c
index c3bd863..49be5fd 100644
--- a/src/actions-support.c
+++ b/src/actions-support.c
@@ -33,7 +33,7 @@
 
 /* Check the return message from a call for validity. */
 int
-guestfs___check_reply_header (guestfs_h *g,
+guestfs_int_check_reply_header (guestfs_h *g,
                               const struct guestfs_message_header *hdr,
                               unsigned int proc_nr, unsigned int serial)
 {
@@ -65,7 +65,7 @@ guestfs___check_reply_header (guestfs_h *g,
 
 /* Check the appliance is up when running a daemon_function. */
 int
-guestfs___check_appliance_up (guestfs_h *g, const char *caller)
+guestfs_int_check_appliance_up (guestfs_h *g, const char *caller)
 {
   if (g->state == CONFIG || g->state == LAUNCHING) {
     error (g, "%s: call launch before using this function\n(in guestfish, don't forget to use the 'run' command)",
@@ -77,7 +77,7 @@ guestfs___check_appliance_up (guestfs_h *g, const char *caller)
 
 /* Convenience wrapper for tracing. */
 void
-guestfs___trace_open (struct trace_buffer *tb)
+guestfs_int_trace_open (struct trace_buffer *tb)
 {
   tb->buf = NULL;
   tb->len = 0;
@@ -94,12 +94,12 @@ guestfs___trace_open (struct trace_buffer *tb)
 }
 
 void
-guestfs___trace_send_line (guestfs_h *g, struct trace_buffer *tb)
+guestfs_int_trace_send_line (guestfs_h *g, struct trace_buffer *tb)
 {
   if (tb->opened) {
     fclose (tb->fp);
     tb->fp = NULL;
-    guestfs___call_callbacks_message (g, GUESTFS_EVENT_TRACE, tb->buf, tb->len);
+    guestfs_int_call_callbacks_message (g, GUESTFS_EVENT_TRACE, tb->buf, tb->len);
     free (tb->buf);
     tb->buf = NULL;
   }
diff --git a/src/alloc.c b/src/alloc.c
index a7acdd3..dfe5e78 100644
--- a/src/alloc.c
+++ b/src/alloc.c
@@ -31,7 +31,7 @@
 #include "guestfs-internal.h"
 
 void *
-guestfs___safe_malloc (guestfs_h *g, size_t nbytes)
+guestfs_int_safe_malloc (guestfs_h *g, size_t nbytes)
 {
   void *ptr = malloc (nbytes);
   if (nbytes > 0 && !ptr) g->abort_cb ();
@@ -64,7 +64,7 @@ guestfs___safe_malloc (guestfs_h *g, size_t nbytes)
 /* Allocate zeroed memory for N elements of S bytes, with error
    checking.  S must be nonzero.  */
 void *
-guestfs___safe_calloc (guestfs_h *g, size_t n, size_t s)
+guestfs_int_safe_calloc (guestfs_h *g, size_t n, size_t s)
 {
   /* From gnulib's calloc function in xmalloc.c.  */
   void *p;
@@ -79,7 +79,7 @@ guestfs___safe_calloc (guestfs_h *g, size_t n, size_t s)
 }
 
 void *
-guestfs___safe_realloc (guestfs_h *g, void *ptr, size_t nbytes)
+guestfs_int_safe_realloc (guestfs_h *g, void *ptr, size_t nbytes)
 {
   void *p = realloc (ptr, nbytes);
   if (nbytes > 0 && !p) g->abort_cb ();
@@ -87,7 +87,7 @@ guestfs___safe_realloc (guestfs_h *g, void *ptr, size_t nbytes)
 }
 
 char *
-guestfs___safe_strdup (guestfs_h *g, const char *str)
+guestfs_int_safe_strdup (guestfs_h *g, const char *str)
 {
   char *s = strdup (str);
   if (!s) g->abort_cb ();
@@ -95,7 +95,7 @@ guestfs___safe_strdup (guestfs_h *g, const char *str)
 }
 
 char *
-guestfs___safe_strndup (guestfs_h *g, const char *str, size_t n)
+guestfs_int_safe_strndup (guestfs_h *g, const char *str, size_t n)
 {
   char *s = strndup (str, n);
   if (!s) g->abort_cb ();
@@ -103,7 +103,7 @@ guestfs___safe_strndup (guestfs_h *g, const char *str, size_t n)
 }
 
 void *
-guestfs___safe_memdup (guestfs_h *g, const void *ptr, size_t size)
+guestfs_int_safe_memdup (guestfs_h *g, const void *ptr, size_t size)
 {
   void *p = malloc (size);
   if (!p) g->abort_cb ();
@@ -112,7 +112,7 @@ guestfs___safe_memdup (guestfs_h *g, const void *ptr, size_t size)
 }
 
 char *
-guestfs___safe_asprintf (guestfs_h *g, const char *fs, ...)
+guestfs_int_safe_asprintf (guestfs_h *g, const char *fs, ...)
 {
   va_list args;
   char *msg;
diff --git a/src/appliance.c b/src/appliance.c
index 5fa47f2..f371f3d 100644
--- a/src/appliance.c
+++ b/src/appliance.c
@@ -99,7 +99,7 @@ static int run_supermin_build (guestfs_h *g, const char *lockfile, const char *a
  * subdirectory.
  */
 int
-guestfs___build_appliance (guestfs_h *g,
+guestfs_int_build_appliance (guestfs_h *g,
                            char **kernel_rtn,
                            char **dtb_rtn,
                            char **initrd_rtn,
@@ -261,17 +261,17 @@ build_supermin_appliance (guestfs_h *g,
 
   (void) utimes (cachedir, NULL);
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "begin building supermin appliance");
+    guestfs_int_print_timestamped_message (g, "begin building supermin appliance");
 
   /* Build the appliance if it needs to be built. */
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "run supermin");
+    guestfs_int_print_timestamped_message (g, "run supermin");
 
   if (run_supermin_build (g, lockfile, appliancedir, supermin_path) == -1)
     return -1;
 
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "finished building supermin appliance");
+    guestfs_int_print_timestamped_message (g, "finished building supermin appliance");
 
   /* Return the appliance filenames. */
   *kernel = safe_malloc (g, len);
@@ -323,7 +323,7 @@ run_supermin_build (guestfs_h *g,
                     const char *appliancedir,
                     const char *supermin_path)
 {
-  CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
   int r;
 #if 0                           /* not supported in supermin 5 yet XXX */
   uid_t uid = getuid ();
@@ -333,39 +333,39 @@ run_supermin_build (guestfs_h *g,
   int pass_u_g_args = uid != euid || gid != egid;
 #endif
 
-  guestfs___cmd_add_arg (cmd, SUPERMIN);
-  guestfs___cmd_add_arg (cmd, "--build");
+  guestfs_int_cmd_add_arg (cmd, SUPERMIN);
+  guestfs_int_cmd_add_arg (cmd, "--build");
   if (g->verbose)
-    guestfs___cmd_add_arg (cmd, "--verbose");
-  guestfs___cmd_add_arg (cmd, "--if-newer");
-  guestfs___cmd_add_arg (cmd, "--lock");
-  guestfs___cmd_add_arg (cmd, lockfile);
+    guestfs_int_cmd_add_arg (cmd, "--verbose");
+  guestfs_int_cmd_add_arg (cmd, "--if-newer");
+  guestfs_int_cmd_add_arg (cmd, "--lock");
+  guestfs_int_cmd_add_arg (cmd, lockfile);
 #if 0
   if (pass_u_g_args) {
-    guestfs___cmd_add_arg (cmd, "-u");
-    guestfs___cmd_add_arg_format (cmd, "%d", euid);
-    guestfs___cmd_add_arg (cmd, "-g");
-    guestfs___cmd_add_arg_format (cmd, "%d", egid);
+    guestfs_int_cmd_add_arg (cmd, "-u");
+    guestfs_int_cmd_add_arg_format (cmd, "%d", euid);
+    guestfs_int_cmd_add_arg (cmd, "-g");
+    guestfs_int_cmd_add_arg_format (cmd, "%d", egid);
   }
 #endif
-  guestfs___cmd_add_arg (cmd, "--copy-kernel");
-  guestfs___cmd_add_arg (cmd, "-f");
-  guestfs___cmd_add_arg (cmd, "ext2");
-  guestfs___cmd_add_arg (cmd, "--host-cpu");
-  guestfs___cmd_add_arg (cmd, host_cpu);
+  guestfs_int_cmd_add_arg (cmd, "--copy-kernel");
+  guestfs_int_cmd_add_arg (cmd, "-f");
+  guestfs_int_cmd_add_arg (cmd, "ext2");
+  guestfs_int_cmd_add_arg (cmd, "--host-cpu");
+  guestfs_int_cmd_add_arg (cmd, host_cpu);
 #ifdef DTB_WILDCARD
-  guestfs___cmd_add_arg (cmd, "--dtb");
-  guestfs___cmd_add_arg (cmd, DTB_WILDCARD);
+  guestfs_int_cmd_add_arg (cmd, "--dtb");
+  guestfs_int_cmd_add_arg (cmd, DTB_WILDCARD);
 #endif
-  guestfs___cmd_add_arg_format (cmd, "%s/supermin.d", supermin_path);
-  guestfs___cmd_add_arg (cmd, "-o");
-  guestfs___cmd_add_arg (cmd, appliancedir);
+  guestfs_int_cmd_add_arg_format (cmd, "%s/supermin.d", supermin_path);
+  guestfs_int_cmd_add_arg (cmd, "-o");
+  guestfs_int_cmd_add_arg (cmd, appliancedir);
 
-  r = guestfs___cmd_run (cmd);
+  r = guestfs_int_cmd_run (cmd);
   if (r == -1)
     return -1;
   if (!WIFEXITED (r) || WEXITSTATUS (r) != 0) {
-    guestfs___external_command_failed (g, r, SUPERMIN, NULL);
+    guestfs_int_external_command_failed (g, r, SUPERMIN, NULL);
     return -1;
   }
 
@@ -481,11 +481,11 @@ dir_contains_files (const char *dir, ...)
  * error).
  */
 int
-guestfs___get_uefi (guestfs_h *g, char **code, char **vars)
+guestfs_int_get_uefi (guestfs_h *g, char **code, char **vars)
 {
   if (access (AAVMF_DIR "/AAVMF_CODE.fd", R_OK) == 0 &&
       access (AAVMF_DIR "/AAVMF_VARS.fd", R_OK) == 0) {
-    CLEANUP_CMD_CLOSE struct command *copycmd = guestfs___new_command (g);
+    CLEANUP_CMD_CLOSE struct command *copycmd = guestfs_int_new_command (g);
     char *varst;
     int r;
 
@@ -494,10 +494,10 @@ guestfs___get_uefi (guestfs_h *g, char **code, char **vars)
      * inside UEFI.
      */
     varst = safe_asprintf (g, "%s/AAVMF_VARS.fd.%d", g->tmpdir, ++g->unique);
-    guestfs___cmd_add_arg (copycmd, "cp");
-    guestfs___cmd_add_arg (copycmd, AAVMF_DIR "/AAVMF_VARS.fd");
-    guestfs___cmd_add_arg (copycmd, varst);
-    r = guestfs___cmd_run (copycmd);
+    guestfs_int_cmd_add_arg (copycmd, "cp");
+    guestfs_int_cmd_add_arg (copycmd, AAVMF_DIR "/AAVMF_VARS.fd");
+    guestfs_int_cmd_add_arg (copycmd, varst);
+    r = guestfs_int_cmd_run (copycmd);
     if (r == -1 || !WIFEXITED (r) || WEXITSTATUS (r) != 0) {
       free (varst);
       return -1;
@@ -516,7 +516,7 @@ guestfs___get_uefi (guestfs_h *g, char **code, char **vars)
 #else /* !__aarch64__ */
 
 int
-guestfs___get_uefi (guestfs_h *g, char **code, char **vars)
+guestfs_int_get_uefi (guestfs_h *g, char **code, char **vars)
 {
   *code = *vars = NULL;
   return 0;
diff --git a/src/cleanup.c b/src/cleanup.c
index 60e660f..71c26ec 100644
--- a/src/cleanup.c
+++ b/src/cleanup.c
@@ -38,19 +38,19 @@
  */
 
 void
-guestfs___cleanup_free (void *ptr)
+guestfs_int_cleanup_free (void *ptr)
 {
   free (* (void **) ptr);
 }
 
 void
-guestfs___cleanup_free_string_list (char ***ptr)
+guestfs_int_cleanup_free_string_list (char ***ptr)
 {
-  guestfs___free_string_list (*ptr);
+  guestfs_int_free_string_list (*ptr);
 }
 
 void
-guestfs___cleanup_hash_free (void *ptr)
+guestfs_int_cleanup_hash_free (void *ptr)
 {
   Hash_table *h = * (Hash_table **) ptr;
 
@@ -59,7 +59,7 @@ guestfs___cleanup_hash_free (void *ptr)
 }
 
 void
-guestfs___cleanup_unlink_free (char **ptr)
+guestfs_int_cleanup_unlink_free (char **ptr)
 {
   char *filename = *ptr;
 
@@ -70,7 +70,7 @@ guestfs___cleanup_unlink_free (char **ptr)
 }
 
 void
-guestfs___cleanup_xmlBufferFree (void *ptr)
+guestfs_int_cleanup_xmlBufferFree (void *ptr)
 {
   xmlBufferPtr xb = * (xmlBufferPtr *) ptr;
 
@@ -79,7 +79,7 @@ guestfs___cleanup_xmlBufferFree (void *ptr)
 }
 
 void
-guestfs___cleanup_xmlFreeDoc (void *ptr)
+guestfs_int_cleanup_xmlFreeDoc (void *ptr)
 {
   xmlDocPtr doc = * (xmlDocPtr *) ptr;
 
@@ -88,7 +88,7 @@ guestfs___cleanup_xmlFreeDoc (void *ptr)
 }
 
 void
-guestfs___cleanup_xmlFreeURI (void *ptr)
+guestfs_int_cleanup_xmlFreeURI (void *ptr)
 {
   xmlURIPtr uri = * (xmlURIPtr *) ptr;
 
@@ -97,7 +97,7 @@ guestfs___cleanup_xmlFreeURI (void *ptr)
 }
 
 void
-guestfs___cleanup_xmlFreeTextWriter (void *ptr)
+guestfs_int_cleanup_xmlFreeTextWriter (void *ptr)
 {
   xmlTextWriterPtr xo = * (xmlTextWriterPtr *) ptr;
 
@@ -106,7 +106,7 @@ guestfs___cleanup_xmlFreeTextWriter (void *ptr)
 }
 
 void
-guestfs___cleanup_xmlXPathFreeContext (void *ptr)
+guestfs_int_cleanup_xmlXPathFreeContext (void *ptr)
 {
   xmlXPathContextPtr ctx = * (xmlXPathContextPtr *) ptr;
 
@@ -115,7 +115,7 @@ guestfs___cleanup_xmlXPathFreeContext (void *ptr)
 }
 
 void
-guestfs___cleanup_xmlXPathFreeObject (void *ptr)
+guestfs_int_cleanup_xmlXPathFreeObject (void *ptr)
 {
   xmlXPathObjectPtr obj = * (xmlXPathObjectPtr *) ptr;
 
@@ -124,7 +124,7 @@ guestfs___cleanup_xmlXPathFreeObject (void *ptr)
 }
 
 void
-guestfs___cleanup_fclose (void *ptr)
+guestfs_int_cleanup_fclose (void *ptr)
 {
   FILE *f = * (FILE **) ptr;
 
@@ -133,7 +133,7 @@ guestfs___cleanup_fclose (void *ptr)
 }
 
 void
-guestfs___cleanup_pclose (void *ptr)
+guestfs_int_cleanup_pclose (void *ptr)
 {
   FILE *f = * (FILE **) ptr;
 
diff --git a/src/command.c b/src/command.c
index 4bb469b..2e003ea 100644
--- a/src/command.c
+++ b/src/command.c
@@ -24,13 +24,13 @@
  * (1) Create a new command handle:
  *
  *   struct command *cmd;
- *   cmd = guestfs___new_command (g);
+ *   cmd = guestfs_int_new_command (g);
  *
  * (2) EITHER add arguments:
  *
- *   guestfs___cmd_add_arg (cmd, "qemu-img");
- *   guestfs___cmd_add_arg (cmd, "info");
- *   guestfs___cmd_add_arg (cmd, filename);
+ *   guestfs_int_cmd_add_arg (cmd, "qemu-img");
+ *   guestfs_int_cmd_add_arg (cmd, "info");
+ *   guestfs_int_cmd_add_arg (cmd, filename);
  *
  * NB: You don't need to add a NULL argument at the end.
  *
@@ -39,8 +39,8 @@
  * commands, with the added safety of allowing args to be quoted
  * properly).
  *
- *   guestfs___cmd_add_string_unquoted (cmd, "qemu-img info ");
- *   guestfs___cmd_add_string_quoted (cmd, filename);
+ *   guestfs_int_cmd_add_string_unquoted (cmd, "qemu-img info ");
+ *   guestfs_int_cmd_add_string_quoted (cmd, filename);
  *
  * (4) Set various flags, such as whether you want to capture
  * errors in the regular libguestfs error log.
@@ -49,14 +49,14 @@
  * loops over the output, and then does a waitpid and returns the
  * exit status of the command.
  *
- *   r = guestfs___cmd_run (cmd);
+ *   r = guestfs_int_cmd_run (cmd);
  *   if (r == -1)
  *     // error
  *   // else test r using the WIF* functions
  *
  * (6) Close the handle:
  *
- *   guestfs___cmd_close (cmd);
+ *   guestfs_int_cmd_close (cmd);
  *
  * (or use CLEANUP_CMD_CLOSE).
  */
@@ -138,7 +138,7 @@ struct command
 
 /* Create a new command handle. */
 struct command *
-guestfs___new_command (guestfs_h *g)
+guestfs_int_new_command (guestfs_h *g)
 {
   struct command *cmd;
 
@@ -158,7 +158,7 @@ add_arg_no_strdup (struct command *cmd, char *arg)
   assert (cmd->style != COMMAND_STYLE_SYSTEM);
   cmd->style = COMMAND_STYLE_EXECV;
 
-  guestfs___add_string_nodup (cmd->g, &cmd->argv, arg);
+  guestfs_int_add_string_nodup (cmd->g, &cmd->argv, arg);
 }
 
 static void
@@ -169,13 +169,13 @@ add_arg (struct command *cmd, const char *arg)
 }
 
 void
-guestfs___cmd_add_arg (struct command *cmd, const char *arg)
+guestfs_int_cmd_add_arg (struct command *cmd, const char *arg)
 {
   add_arg (cmd, arg);
 }
 
 void
-guestfs___cmd_add_arg_format (struct command *cmd, const char *fs, ...)
+guestfs_int_cmd_add_arg_format (struct command *cmd, const char *fs, ...)
 {
   va_list args;
   char *arg;
@@ -211,7 +211,7 @@ add_string (struct command *cmd, const char *str, size_t len)
 }
 
 void
-guestfs___cmd_add_string_unquoted (struct command *cmd, const char *str)
+guestfs_int_cmd_add_string_unquoted (struct command *cmd, const char *str)
 {
   add_string (cmd, str, strlen (str));
 }
@@ -221,7 +221,7 @@ guestfs___cmd_add_string_unquoted (struct command *cmd, const char *str)
  * single argument to a system(3)-style command string.
  */
 void
-guestfs___cmd_add_string_quoted (struct command *cmd, const char *str)
+guestfs_int_cmd_add_string_quoted (struct command *cmd, const char *str)
 {
   add_string (cmd, "\"", 1);
 
@@ -255,7 +255,7 @@ guestfs___cmd_add_string_quoted (struct command *cmd, const char *str)
  * the length field in the callback.
  */
 void
-guestfs___cmd_set_stdout_callback (struct command *cmd,
+guestfs_int_cmd_set_stdout_callback (struct command *cmd,
                                    cmd_stdout_callback stdout_callback,
                                    void *stdout_data, unsigned flags)
 {
@@ -284,7 +284,7 @@ guestfs___cmd_set_stdout_callback (struct command *cmd,
  * sense to combine them.
  */
 void
-guestfs___cmd_set_stderr_to_stdout (struct command *cmd)
+guestfs_int_cmd_set_stderr_to_stdout (struct command *cmd)
 {
   cmd->stderr_to_stdout = true;
 }
@@ -294,7 +294,7 @@ guestfs___cmd_set_stderr_to_stdout (struct command *cmd)
  * usually undesirable.
  */
 void
-guestfs___cmd_clear_capture_errors (struct command *cmd)
+guestfs_int_cmd_clear_capture_errors (struct command *cmd)
 {
   cmd->capture_errors = false;
 }
@@ -303,7 +303,7 @@ guestfs___cmd_clear_capture_errors (struct command *cmd)
  * single fds to be sent to child process.
  */
 void
-guestfs___cmd_clear_close_files (struct command *cmd)
+guestfs_int_cmd_clear_close_files (struct command *cmd)
 {
   cmd->close_files = false;
 }
@@ -317,7 +317,7 @@ finish_command (struct command *cmd)
 {
   switch (cmd->style) {
   case COMMAND_STYLE_EXECV:
-    guestfs___end_stringsbuf (cmd->g, &cmd->argv);
+    guestfs_int_end_stringsbuf (cmd->g, &cmd->argv);
     break;
 
   case COMMAND_STYLE_SYSTEM:
@@ -474,7 +474,7 @@ run_command (struct command *cmd)
     if (WIFEXITED (r))
       _exit (WEXITSTATUS (r));
     fprintf (stderr, "%s\n",
-             guestfs___exit_status_to_string (r, cmd->string.str,
+             guestfs_int_exit_status_to_string (r, cmd->string.str,
                                               status_string,
                                               sizeof status_string));
     _exit (EXIT_FAILURE);
@@ -537,7 +537,7 @@ loop (struct command *cmd)
       /* Read output and send it to the log. */
       n = read (cmd->errorfd, buf, sizeof buf);
       if (n > 0)
-        guestfs___call_callbacks_message (cmd->g, GUESTFS_EVENT_APPLIANCE,
+        guestfs_int_call_callbacks_message (cmd->g, GUESTFS_EVENT_APPLIANCE,
                                           buf, n);
       else if (n == 0) {
         if (close (cmd->errorfd) == -1)
@@ -608,7 +608,7 @@ wait_command (struct command *cmd)
  * On error: Calls error(g) and returns -1.
  */
 int
-guestfs___cmd_run (struct command *cmd)
+guestfs_int_cmd_run (struct command *cmd)
 {
   finish_command (cmd);
 
@@ -625,7 +625,7 @@ guestfs___cmd_run (struct command *cmd)
 }
 
 void
-guestfs___cmd_close (struct command *cmd)
+guestfs_int_cmd_close (struct command *cmd)
 {
   if (!cmd)
     return;
@@ -636,7 +636,7 @@ guestfs___cmd_close (struct command *cmd)
     break;
 
   case COMMAND_STYLE_EXECV:
-    guestfs___free_stringsbuf (&cmd->argv);
+    guestfs_int_free_stringsbuf (&cmd->argv);
     break;
 
   case COMMAND_STYLE_SYSTEM:
@@ -659,9 +659,9 @@ guestfs___cmd_close (struct command *cmd)
 }
 
 void
-guestfs___cleanup_cmd_close (struct command **ptr)
+guestfs_int_cleanup_cmd_close (struct command **ptr)
 {
-  guestfs___cmd_close (*ptr);
+  guestfs_int_cmd_close (*ptr);
 }
 
 /* Deal with buffering stdout for the callback. */
diff --git a/src/conn-socket.c b/src/conn-socket.c
index fe3ca04..3ead48f 100644
--- a/src/conn-socket.c
+++ b/src/conn-socket.c
@@ -92,7 +92,7 @@ accept_connection (guestfs_h *g, struct connection *connv)
     }
 
     if (r == 0) {               /* timeout reached */
-      guestfs___launch_timeout (g);
+      guestfs_int_launch_timeout (g);
       return -1;
     }
 
@@ -341,7 +341,7 @@ handle_log_message (guestfs_h *g,
   }
 
   /* It's an actual log message, send it upwards. */
-  guestfs___log_message_callback (g, buf, n);
+  guestfs_int_log_message_callback (g, buf, n);
 
 #ifdef VALGRIND_DAEMON
   /* Find the canary printed by appliance/init if valgrinding of the
@@ -399,7 +399,7 @@ static struct connection_ops ops = {
  * free_connection.
  */
 struct connection *
-guestfs___new_conn_socket_listening (guestfs_h *g,
+guestfs_int_new_conn_socket_listening (guestfs_h *g,
                                      int daemon_accept_sock,
                                      int console_sock)
 {
@@ -438,7 +438,7 @@ guestfs___new_conn_socket_listening (guestfs_h *g,
  * and promises not to call accept_connection.
  */
 struct connection *
-guestfs___new_conn_socket_connected (guestfs_h *g,
+guestfs_int_new_conn_socket_connected (guestfs_h *g,
                                      int daemon_sock,
                                      int console_sock)
 {
diff --git a/src/create.c b/src/create.c
index 0cfe6be..f438bdc 100644
--- a/src/create.c
+++ b/src/create.c
@@ -245,7 +245,7 @@ disk_create_qcow2 (guestfs_h *g, const char *orig_filename, int64_t size,
   const char *compat = NULL;
   int clustersize = -1;
   CLEANUP_FREE_STRINGSBUF DECLARE_STRINGSBUF (optionsv);
-  CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
   int r;
 
   /* If the filename is something like "file:foo" then qemu-img will
@@ -292,40 +292,40 @@ disk_create_qcow2 (guestfs_h *g, const char *orig_filename, int64_t size,
   }
 
   /* Assemble the qemu-img command line. */
-  guestfs___cmd_add_arg (cmd, "qemu-img");
-  guestfs___cmd_add_arg (cmd, "create");
-  guestfs___cmd_add_arg (cmd, "-f");
-  guestfs___cmd_add_arg (cmd, "qcow2");
+  guestfs_int_cmd_add_arg (cmd, "qemu-img");
+  guestfs_int_cmd_add_arg (cmd, "create");
+  guestfs_int_cmd_add_arg (cmd, "-f");
+  guestfs_int_cmd_add_arg (cmd, "qcow2");
 
   /* -o parameter. */
   if (backingfile) {
     CLEANUP_FREE char *p = qemu_escape_param (g, backingfile);
-    guestfs___add_sprintf (g, &optionsv, "backing_file=%s", p);
+    guestfs_int_add_sprintf (g, &optionsv, "backing_file=%s", p);
   }
   if (backingformat)
-    guestfs___add_sprintf (g, &optionsv, "backing_fmt=%s", backingformat);
+    guestfs_int_add_sprintf (g, &optionsv, "backing_fmt=%s", backingformat);
   if (preallocation)
-    guestfs___add_sprintf (g, &optionsv, "preallocation=%s", preallocation);
+    guestfs_int_add_sprintf (g, &optionsv, "preallocation=%s", preallocation);
   if (compat)
-    guestfs___add_sprintf (g, &optionsv, "compat=%s", compat);
+    guestfs_int_add_sprintf (g, &optionsv, "compat=%s", compat);
   if (clustersize >= 0)
-    guestfs___add_sprintf (g, &optionsv, "cluster_size=%d", clustersize);
-  guestfs___end_stringsbuf (g, &optionsv);
+    guestfs_int_add_sprintf (g, &optionsv, "cluster_size=%d", clustersize);
+  guestfs_int_end_stringsbuf (g, &optionsv);
 
   if (optionsv.size > 1) {
-    CLEANUP_FREE char *options = guestfs___join_strings (",", optionsv.argv);
-    guestfs___cmd_add_arg (cmd, "-o");
-    guestfs___cmd_add_arg (cmd, options);
+    CLEANUP_FREE char *options = guestfs_int_join_strings (",", optionsv.argv);
+    guestfs_int_cmd_add_arg (cmd, "-o");
+    guestfs_int_cmd_add_arg (cmd, options);
   }
 
   /* Complete the command line. */
-  guestfs___cmd_add_arg (cmd, filename);
+  guestfs_int_cmd_add_arg (cmd, filename);
   if (size >= 0)
-    guestfs___cmd_add_arg_format (cmd, "%" PRIi64, size);
+    guestfs_int_cmd_add_arg_format (cmd, "%" PRIi64, size);
 
-  r = guestfs___cmd_run (cmd);
+  r = guestfs_int_cmd_run (cmd);
   if (!WIFEXITED (r) || WEXITSTATUS (r) != 0) {
-    guestfs___external_command_failed (g, r, "qemu-img", orig_filename);
+    guestfs_int_external_command_failed (g, r, "qemu-img", orig_filename);
     return -1;
   }
 
diff --git a/src/dbdump.c b/src/dbdump.c
index 684b2cf..9583254 100644
--- a/src/dbdump.c
+++ b/src/dbdump.c
@@ -43,7 +43,7 @@ static void read_db_dump_line (guestfs_h *g, void *datav, const char *line, size
 static unsigned char *convert_hex_to_binary (guestfs_h *g, const char *hex, size_t hexlen, size_t *binlen_rtn);
 
 struct cb_data {
-  guestfs___db_dump_callback callback;
+  guestfs_int_db_dump_callback callback;
   void *opaque;
   enum { reading_header,
          reading_key, reading_value,
@@ -58,12 +58,12 @@ struct cb_data {
  * database format.
  */
 int
-guestfs___read_db_dump (guestfs_h *g,
+guestfs_int_read_db_dump (guestfs_h *g,
                         const char *dumpfile, void *opaque,
-                        guestfs___db_dump_callback callback)
+                        guestfs_int_db_dump_callback callback)
 {
   struct cb_data data;
-  CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
   int r;
 
   data.callback = callback;
@@ -71,18 +71,18 @@ guestfs___read_db_dump (guestfs_h *g,
   data.state = reading_header;
   data.key = NULL;
 
-  guestfs___cmd_add_arg (cmd, DB_DUMP);
-  guestfs___cmd_add_arg (cmd, "-k");
-  guestfs___cmd_add_arg (cmd, dumpfile);
-  guestfs___cmd_set_stdout_callback (cmd, read_db_dump_line, &data, 0);
+  guestfs_int_cmd_add_arg (cmd, DB_DUMP);
+  guestfs_int_cmd_add_arg (cmd, "-k");
+  guestfs_int_cmd_add_arg (cmd, dumpfile);
+  guestfs_int_cmd_set_stdout_callback (cmd, read_db_dump_line, &data, 0);
 
-  r = guestfs___cmd_run (cmd);
+  r = guestfs_int_cmd_run (cmd);
   free (data.key);
 
   if (r == -1)
     return -1;
   if (!WIFEXITED (r) || WEXITSTATUS (r) != 0) {
-    guestfs___external_command_failed (g, r, DB_DUMP, NULL);
+    guestfs_int_external_command_failed (g, r, DB_DUMP, NULL);
     return -1;
   }
   if (data.state != reading_finished) {
diff --git a/src/drives.c b/src/drives.c
index 34cf07a..356293e 100644
--- a/src/drives.c
+++ b/src/drives.c
@@ -459,7 +459,7 @@ create_drive_dev_null (guestfs_h *g,
     return NULL;
   }
 
-  if (guestfs___lazy_make_tmpdir (g) == -1)
+  if (guestfs_int_lazy_make_tmpdir (g) == -1)
     return NULL;
 
   /* Because we create a special file, there is no point forcing qemu
@@ -514,7 +514,7 @@ free_drive_struct (struct drive *drv)
 }
 
 const char *
-guestfs___drive_protocol_to_string (enum drive_protocol protocol)
+guestfs_int_drive_protocol_to_string (enum drive_protocol protocol)
 {
   switch (protocol) {
   case drive_protocol_file: return "file";
@@ -545,7 +545,7 @@ drive_to_string (guestfs_h *g, const struct drive *drv)
      drv->readonly ? " readonly" : "",
      drv->src.format ? " format=" : "",
      drv->src.format ? : "",
-     guestfs___drive_protocol_to_string (drv->src.protocol),
+     guestfs_int_drive_protocol_to_string (drv->src.protocol),
      drv->iface ? " iface=" : "",
      drv->iface ? : "",
      drv->name ? " name=" : "",
@@ -586,7 +586,7 @@ add_drive_to_handle (guestfs_h *g, struct drive *d)
 
 /* Called during launch to add a dummy slot to g->drives. */
 void
-guestfs___add_dummy_appliance_drive (guestfs_h *g)
+guestfs_int_add_dummy_appliance_drive (guestfs_h *g)
 {
   struct drive *drv;
 
@@ -596,7 +596,7 @@ guestfs___add_dummy_appliance_drive (guestfs_h *g)
 
 /* Free up all the drives in the handle. */
 void
-guestfs___free_drives (guestfs_h *g)
+guestfs_int_free_drives (guestfs_h *g)
 {
   struct drive *drv;
   size_t i;
@@ -745,7 +745,7 @@ parse_servers (guestfs_h *g, char *const *strs,
                struct drive_server **servers_rtn)
 {
   size_t i;
-  size_t n = guestfs___count_strings (strs);
+  size_t n = guestfs_int_count_strings (strs);
   struct drive_server *servers;
 
   if (n == 0) {
@@ -1051,7 +1051,7 @@ guestfs__add_drive_scratch (guestfs_h *g, int64_t size,
    * because everything in g->tmpdir is 'rm -rf'd when the handle is
    * closed.
    */
-  if (guestfs___lazy_make_tmpdir (g) == -1)
+  if (guestfs_int_lazy_make_tmpdir (g) == -1)
     return -1;
   filename = safe_asprintf (g, "%s/scratch.%d", g->tmpdir, ++g->unique);
 
@@ -1127,13 +1127,13 @@ guestfs__remove_drive (guestfs_h *g, const char *label)
  * added atomicly.  Only used by guestfs_add_domain.
  */
 size_t
-guestfs___checkpoint_drives (guestfs_h *g)
+guestfs_int_checkpoint_drives (guestfs_h *g)
 {
   return g->nr_drives;
 }
 
 void
-guestfs___rollback_drives (guestfs_h *g, size_t old_i)
+guestfs_int_rollback_drives (guestfs_h *g, size_t old_i)
 {
   size_t i;
 
@@ -1153,10 +1153,10 @@ guestfs__debug_drives (guestfs_h *g)
   struct drive *drv;
 
   ITER_DRIVES (g, i, drv) {
-    guestfs___add_string_nodup (g, &ret, drive_to_string (g, drv));
+    guestfs_int_add_string_nodup (g, &ret, drive_to_string (g, drv));
   }
 
-  guestfs___end_stringsbuf (g, &ret);
+  guestfs_int_end_stringsbuf (g, &ret);
 
   return ret.argv;              /* caller frees */
 }
diff --git a/src/errors.c b/src/errors.c
index c51c4fa..bcc0909 100644
--- a/src/errors.c
+++ b/src/errors.c
@@ -54,7 +54,7 @@ set_last_error (guestfs_h *g, int errnum, const char *msg)
  * not important for end users then it should be a debug message.
  */
 void
-guestfs___warning (guestfs_h *g, const char *fs, ...)
+guestfs_int_warning (guestfs_h *g, const char *fs, ...)
 {
   va_list args;
   CLEANUP_FREE char *msg = NULL;
@@ -66,12 +66,12 @@ guestfs___warning (guestfs_h *g, const char *fs, ...)
 
   if (len < 0) return;
 
-  guestfs___call_callbacks_message (g, GUESTFS_EVENT_WARNING, msg, len);
+  guestfs_int_call_callbacks_message (g, GUESTFS_EVENT_WARNING, msg, len);
 }
 
 /* Debug messages. */
 void
-guestfs___debug (guestfs_h *g, const char *fs, ...)
+guestfs_int_debug (guestfs_h *g, const char *fs, ...)
 {
   va_list args;
   CLEANUP_FREE char *msg = NULL;
@@ -90,7 +90,7 @@ guestfs___debug (guestfs_h *g, const char *fs, ...)
 
   if (len < 0) return;
 
-  guestfs___call_callbacks_message (g, GUESTFS_EVENT_LIBRARY, msg, len);
+  guestfs_int_call_callbacks_message (g, GUESTFS_EVENT_LIBRARY, msg, len);
 }
 
 /* Call trace messages.  These are enabled by setting g->trace, and
@@ -98,7 +98,7 @@ guestfs___debug (guestfs_h *g, const char *fs, ...)
  * in src/actions.c
  */
 void
-guestfs___trace (guestfs_h *g, const char *fs, ...)
+guestfs_int_trace (guestfs_h *g, const char *fs, ...)
 {
   va_list args;
   CLEANUP_FREE char *msg = NULL;
@@ -110,11 +110,11 @@ guestfs___trace (guestfs_h *g, const char *fs, ...)
 
   if (len < 0) return;
 
-  guestfs___call_callbacks_message (g, GUESTFS_EVENT_TRACE, msg, len);
+  guestfs_int_call_callbacks_message (g, GUESTFS_EVENT_TRACE, msg, len);
 }
 
 void
-guestfs___error_errno (guestfs_h *g, int errnum, const char *fs, ...)
+guestfs_int_error_errno (guestfs_h *g, int errnum, const char *fs, ...)
 {
   va_list args;
   CLEANUP_FREE char *msg = NULL;
@@ -134,7 +134,7 @@ guestfs___error_errno (guestfs_h *g, int errnum, const char *fs, ...)
 }
 
 void
-guestfs___perrorf (guestfs_h *g, const char *fs, ...)
+guestfs_int_perrorf (guestfs_h *g, const char *fs, ...)
 {
   va_list args;
   CLEANUP_FREE char *msg = NULL;
@@ -216,13 +216,13 @@ guestfs_pop_error_handler (guestfs_h *g)
     g->error_cb_stack = next_stack;
   }
   else
-    guestfs___init_error_handler (g);
+    guestfs_int_init_error_handler (g);
 }
 
 static void default_error_cb (guestfs_h *g, void *data, const char *msg);
 
 void
-guestfs___init_error_handler (guestfs_h *g)
+guestfs_int_init_error_handler (guestfs_h *g)
 {
   g->error_cb = default_error_cb;
   g->error_cb_data = NULL;
@@ -238,7 +238,7 @@ default_error_cb (guestfs_h *g, void *data, const char *msg)
  * usually contain large amounts of binary data (RHBZ#646822).
  */
 void
-guestfs___print_BufferIn (FILE *out, const char *buf, size_t buf_size)
+guestfs_int_print_BufferIn (FILE *out, const char *buf, size_t buf_size)
 {
   size_t i;
   size_t orig_size = buf_size;
@@ -263,9 +263,9 @@ guestfs___print_BufferIn (FILE *out, const char *buf, size_t buf_size)
 }
 
 void
-guestfs___print_BufferOut (FILE *out, const char *buf, size_t buf_size)
+guestfs_int_print_BufferOut (FILE *out, const char *buf, size_t buf_size)
 {
-  guestfs___print_BufferIn (out, buf, buf_size);
+  guestfs_int_print_BufferIn (out, buf, buf_size);
 }
 
 /* Some standard error messages for common failures. */
@@ -276,7 +276,7 @@ guestfs___print_BufferOut (FILE *out, const char *buf, size_t buf_size)
  * available to debug launch problems.
  */
 void
-guestfs___launch_failed_error (guestfs_h *g)
+guestfs_int_launch_failed_error (guestfs_h *g)
 {
   if (g->verbose)
     error (g, _("guestfs_launch failed, see earlier error messages"));
@@ -291,7 +291,7 @@ guestfs___launch_failed_error (guestfs_h *g)
 
 /* As above, but for crashes that occur after launch. */
 void
-guestfs___unexpected_close_error (guestfs_h *g)
+guestfs_int_unexpected_close_error (guestfs_h *g)
 {
   if (g->verbose)
     error (g, _("appliance closed the connection unexpectedly, see earlier error messages"));
@@ -305,7 +305,7 @@ guestfs___unexpected_close_error (guestfs_h *g)
 
 /* As above, but for appliance kernel hanging. */
 void
-guestfs___launch_timeout (guestfs_h *g)
+guestfs_int_launch_timeout (guestfs_h *g)
 {
   if (g->verbose)
     error (g, _("appliance launch timed out, see earlier error messages"));
@@ -319,13 +319,13 @@ guestfs___launch_timeout (guestfs_h *g)
 
 /* External command failed. */
 void
-guestfs___external_command_failed (guestfs_h *g, int status,
+guestfs_int_external_command_failed (guestfs_h *g, int status,
                                    const char *cmd_name, const char *extra)
 {
   size_t len = 80 + strlen (cmd_name);
   char status_string[len];
 
-  guestfs___exit_status_to_string (status, cmd_name, status_string, len);
+  guestfs_int_exit_status_to_string (status, cmd_name, status_string, len);
 
   if (g->verbose) {
     if (!extra)
diff --git a/src/events.c b/src/events.c
index 21c610f..51b9948 100644
--- a/src/events.c
+++ b/src/events.c
@@ -94,7 +94,7 @@ guestfs_delete_event_callback (guestfs_h *g, int event_handle)
 /* Functions to generate an event with various payloads. */
 
 void
-guestfs___call_callbacks_void (guestfs_h *g, uint64_t event)
+guestfs_int_call_callbacks_void (guestfs_h *g, uint64_t event)
 {
   size_t i;
 
@@ -108,7 +108,7 @@ guestfs___call_callbacks_void (guestfs_h *g, uint64_t event)
 }
 
 void
-guestfs___call_callbacks_message (guestfs_h *g, uint64_t event,
+guestfs_int_call_callbacks_message (guestfs_h *g, uint64_t event,
                                   const char *buf, size_t buf_len)
 {
   size_t i, count = 0;
@@ -208,7 +208,7 @@ guestfs___call_callbacks_message (guestfs_h *g, uint64_t event,
 }
 
 void
-guestfs___call_callbacks_array (guestfs_h *g, uint64_t event,
+guestfs_int_call_callbacks_array (guestfs_h *g, uint64_t event,
                                 const uint64_t *array, size_t array_len)
 {
   size_t i;
diff --git a/src/file.c b/src/file.c
index 91f7947..854e7cc 100644
--- a/src/file.c
+++ b/src/file.c
@@ -88,7 +88,7 @@ guestfs__read_file (guestfs_h *g, const char *path, size_t *size_r)
   char *ret = NULL;
   struct stat statbuf;
 
-  if (guestfs___lazy_make_tmpdir (g) == -1)
+  if (guestfs_int_lazy_make_tmpdir (g) == -1)
     goto err;
 
   tmpfile = safe_asprintf (g, "%s/cat%d", g->tmpdir, ++g->unique);
@@ -215,7 +215,7 @@ guestfs__find (guestfs_h *g, const char *directory)
   char **ret = NULL;
   size_t i, count, size;
 
-  if (guestfs___lazy_make_tmpdir (g) == -1)
+  if (guestfs_int_lazy_make_tmpdir (g) == -1)
     goto err;
 
   tmpfile = safe_asprintf (g, "%s/find%d", g->tmpdir, ++g->unique);
@@ -319,7 +319,7 @@ write_or_append (guestfs_h *g, const char *path,
       (!append ? guestfs_internal_write : guestfs_internal_write_append)
       (g, path, content, size);
 
-  if (guestfs___lazy_make_tmpdir (g) == -1)
+  if (guestfs_int_lazy_make_tmpdir (g) == -1)
     goto err;
 
   /* Write the content out to a temporary file. */
@@ -382,7 +382,7 @@ guestfs__write_append (guestfs_h *g, const char *path,
 struct guestfs_statns_list *
 guestfs__lstatnslist (guestfs_h *g, const char *dir, char * const*names)
 {
-  size_t len = guestfs___count_strings (names);
+  size_t len = guestfs_int_count_strings (names);
   size_t old_len;
   struct guestfs_statns_list *ret;
 
@@ -424,7 +424,7 @@ guestfs__lstatnslist (guestfs_h *g, const char *dir, char * const*names)
 struct guestfs_xattr_list *
 guestfs__lxattrlist (guestfs_h *g, const char *dir, char *const *names)
 {
-  size_t len = guestfs___count_strings (names);
+  size_t len = guestfs_int_count_strings (names);
   size_t i, old_len;
   struct guestfs_xattr_list *ret;
 
@@ -472,7 +472,7 @@ guestfs__lxattrlist (guestfs_h *g, const char *dir, char *const *names)
 char **
 guestfs__readlinklist (guestfs_h *g, const char *dir, char *const *names)
 {
-  size_t len = guestfs___count_strings (names);
+  size_t len = guestfs_int_count_strings (names);
   size_t old_len, ret_len = 0;
   char **ret = NULL;
 
@@ -489,13 +489,13 @@ guestfs__readlinklist (guestfs_h *g, const char *dir, char *const *names)
 
     if (links == NULL) {
       if (ret)
-        guestfs___free_string_list (ret);
+        guestfs_int_free_string_list (ret);
       return NULL;
     }
 
     /* Append links to ret. */
     old_len = ret_len;
-    ret_len += guestfs___count_strings (links);
+    ret_len += guestfs_int_count_strings (links);
     ret = safe_realloc (g, ret, ret_len * sizeof (char *));
     memcpy (&ret[old_len], links, (ret_len-old_len) * sizeof (char *));
   }
@@ -517,7 +517,7 @@ guestfs__ls (guestfs_h *g, const char *directory)
   char **ret = NULL;
   size_t i, count, size;
 
-  if (guestfs___lazy_make_tmpdir (g) == -1)
+  if (guestfs_int_lazy_make_tmpdir (g) == -1)
     goto err;
 
   tmpfile = safe_asprintf (g, "%s/ls%d", g->tmpdir, ++g->unique);
diff --git a/src/filearch.c b/src/filearch.c
index 18f5918..7591ff8 100644
--- a/src/filearch.c
+++ b/src/filearch.c
@@ -203,7 +203,7 @@ cpio_arch (guestfs_h *g, const char *file, const char *path)
 {
   CLEANUP_FREE char *tmpdir = guestfs_get_tmpdir (g), *dir = NULL;
   CLEANUP_FREE char *initrd = NULL;
-  CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
   char *ret = NULL;
   const char *method;
   int64_t size;
@@ -240,21 +240,21 @@ cpio_arch (guestfs_h *g, const char *file, const char *path)
     goto out;
 
   /* Construct a command to extract named binaries from the initrd file. */
-  guestfs___cmd_add_string_unquoted (cmd, "cd ");
-  guestfs___cmd_add_string_quoted   (cmd, dir);
-  guestfs___cmd_add_string_unquoted (cmd, " && ");
-  guestfs___cmd_add_string_unquoted (cmd, method);
-  guestfs___cmd_add_string_unquoted (cmd, " initrd | cpio --quiet -id");
+  guestfs_int_cmd_add_string_unquoted (cmd, "cd ");
+  guestfs_int_cmd_add_string_quoted   (cmd, dir);
+  guestfs_int_cmd_add_string_unquoted (cmd, " && ");
+  guestfs_int_cmd_add_string_unquoted (cmd, method);
+  guestfs_int_cmd_add_string_unquoted (cmd, " initrd | cpio --quiet -id");
   for (i = 0; initrd_binaries[i] != NULL; ++i) {
-    guestfs___cmd_add_string_unquoted (cmd, " ");
-    guestfs___cmd_add_string_quoted (cmd, initrd_binaries[i]);
+    guestfs_int_cmd_add_string_unquoted (cmd, " ");
+    guestfs_int_cmd_add_string_quoted (cmd, initrd_binaries[i]);
   }
 
-  r = guestfs___cmd_run (cmd);
+  r = guestfs_int_cmd_run (cmd);
   if (r == -1)
     goto out;
   if (!WIFEXITED (r) || WEXITSTATUS (r) != 0) {
-    guestfs___external_command_failed (g, r, "cpio", path);
+    guestfs_int_external_command_failed (g, r, "cpio", path);
     goto out;
   }
 
@@ -273,7 +273,7 @@ cpio_arch (guestfs_h *g, const char *file, const char *path)
   error (g, "file_architecture: could not determine architecture of cpio archive");
 
  out:
-  guestfs___recursive_remove_dir (g, dir);
+  guestfs_int_recursive_remove_dir (g, dir);
 
   return ret;
 }
diff --git a/src/fuse.c b/src/fuse.c
index 08a8784..f8d148b 100644
--- a/src/fuse.c
+++ b/src/fuse.c
@@ -992,7 +992,7 @@ guestfs__mount_local (guestfs_h *g, const char *localmountpoint,
   arg_error:
     perrorf (g, _("fuse_opt_add_arg: %s"), localmountpoint);
     fuse_opt_free_args (&args);
-    guestfs___free_fuse (g);
+    guestfs_int_free_fuse (g);
     return -1;
   }
 
@@ -1009,7 +1009,7 @@ guestfs__mount_local (guestfs_h *g, const char *localmountpoint,
   if (ch == NULL) {
     perrorf (g, _("fuse_mount: %s"), localmountpoint);
     fuse_opt_free_args (&args);
-    guestfs___free_fuse (g);
+    guestfs_int_free_fuse (g);
     return -1;
   }
 
@@ -1028,7 +1028,7 @@ guestfs__mount_local (guestfs_h *g, const char *localmountpoint,
     perrorf (g, _("fuse_new: %s"), localmountpoint);
     fuse_unmount (localmountpoint, ch);
     fuse_opt_free_args (&args);
-    guestfs___free_fuse (g);
+    guestfs_int_free_fuse (g);
     return -1;
   }
 
@@ -1079,7 +1079,7 @@ guestfs__mount_local_run (guestfs_h *g)
 
   debug (g, "%s: leaving fuse_loop", __func__);
 
-  guestfs___free_fuse (g);
+  guestfs_int_free_fuse (g);
   gl_lock_lock (mount_local_lock);
   g->localmountpoint = NULL;
   gl_lock_unlock (mount_local_lock);
@@ -1091,7 +1091,7 @@ guestfs__mount_local_run (guestfs_h *g)
 }
 
 void
-guestfs___free_fuse (guestfs_h *g)
+guestfs_int_free_fuse (guestfs_h *g)
 {
   if (g->fuse)
     fuse_destroy (g->fuse);     /* also closes the channel */
@@ -1130,11 +1130,11 @@ guestfs__umount_local (guestfs_h *g,
   }
 
   /* Run guestunmount --retry=... localmountpoint. */
-  cmd = guestfs___new_command (g);
-  guestfs___cmd_add_arg (cmd, "guestunmount");
-  guestfs___cmd_add_arg (cmd, retry);
-  guestfs___cmd_add_arg (cmd, localmountpoint);
-  r = guestfs___cmd_run (cmd);
+  cmd = guestfs_int_new_command (g);
+  guestfs_int_cmd_add_arg (cmd, "guestunmount");
+  guestfs_int_cmd_add_arg (cmd, retry);
+  guestfs_int_cmd_add_arg (cmd, localmountpoint);
+  r = guestfs_int_cmd_run (cmd);
   if (r == -1)
     return -1;
   if (WIFEXITED (r) && WEXITSTATUS (r) == EXIT_SUCCESS)
diff --git a/src/guestfs-internal-frontend.h b/src/guestfs-internal-frontend.h
index 9316421..6456045 100644
--- a/src/guestfs-internal-frontend.h
+++ b/src/guestfs-internal-frontend.h
@@ -36,27 +36,27 @@
 #define N_(str) dgettext(PACKAGE, (str))
 
 #ifdef HAVE_ATTRIBUTE_CLEANUP
-#define CLEANUP_FREE __attribute__((cleanup(guestfs___cleanup_free)))
+#define CLEANUP_FREE __attribute__((cleanup(guestfs_int_cleanup_free)))
 #define CLEANUP_FREE_STRING_LIST                                \
-  __attribute__((cleanup(guestfs___cleanup_free_string_list)))
+  __attribute__((cleanup(guestfs_int_cleanup_free_string_list)))
 #define CLEANUP_HASH_FREE                               \
-  __attribute__((cleanup(guestfs___cleanup_hash_free)))
+  __attribute__((cleanup(guestfs_int_cleanup_hash_free)))
 #define CLEANUP_UNLINK_FREE                                     \
-  __attribute__((cleanup(guestfs___cleanup_unlink_free)))
+  __attribute__((cleanup(guestfs_int_cleanup_unlink_free)))
 #define CLEANUP_XMLBUFFERFREE                                   \
-  __attribute__((cleanup(guestfs___cleanup_xmlBufferFree)))
+  __attribute__((cleanup(guestfs_int_cleanup_xmlBufferFree)))
 #define CLEANUP_XMLFREEDOC                                      \
-  __attribute__((cleanup(guestfs___cleanup_xmlFreeDoc)))
+  __attribute__((cleanup(guestfs_int_cleanup_xmlFreeDoc)))
 #define CLEANUP_XMLFREEURI                                              \
-  __attribute__((cleanup(guestfs___cleanup_xmlFreeURI)))
+  __attribute__((cleanup(guestfs_int_cleanup_xmlFreeURI)))
 #define CLEANUP_XMLFREETEXTWRITER                               \
-  __attribute__((cleanup(guestfs___cleanup_xmlFreeTextWriter)))
+  __attribute__((cleanup(guestfs_int_cleanup_xmlFreeTextWriter)))
 #define CLEANUP_XMLXPATHFREECONTEXT                                     \
-  __attribute__((cleanup(guestfs___cleanup_xmlXPathFreeContext)))
+  __attribute__((cleanup(guestfs_int_cleanup_xmlXPathFreeContext)))
 #define CLEANUP_XMLXPATHFREEOBJECT                                      \
-  __attribute__((cleanup(guestfs___cleanup_xmlXPathFreeObject)))
-#define CLEANUP_FCLOSE __attribute__((cleanup(guestfs___cleanup_fclose)))
-#define CLEANUP_PCLOSE __attribute__((cleanup(guestfs___cleanup_pclose)))
+  __attribute__((cleanup(guestfs_int_cleanup_xmlXPathFreeObject)))
+#define CLEANUP_FCLOSE __attribute__((cleanup(guestfs_int_cleanup_fclose)))
+#define CLEANUP_PCLOSE __attribute__((cleanup(guestfs_int_cleanup_pclose)))
 #else
 #define CLEANUP_FREE
 #define CLEANUP_FREE_STRING_LIST
@@ -76,52 +76,52 @@
  * functions outside the library, so don't use them in new tools or
  * bindings code.
  */
-extern GUESTFS_DLL_PUBLIC void *guestfs___safe_malloc (guestfs_h *g, size_t nbytes);
-extern GUESTFS_DLL_PUBLIC void *guestfs___safe_calloc (guestfs_h *g, size_t n, size_t s);
-extern GUESTFS_DLL_PUBLIC char *guestfs___safe_strdup (guestfs_h *g, const char *str);
-extern GUESTFS_DLL_PUBLIC void *guestfs___safe_memdup (guestfs_h *g, const void *ptr, size_t size);
-extern void *guestfs___safe_realloc (guestfs_h *g, void *ptr, size_t nbytes);
-extern char *guestfs___safe_strdup (guestfs_h *g, const char *str);
-extern char *guestfs___safe_strndup (guestfs_h *g, const char *str, size_t n);
-extern void *guestfs___safe_memdup (guestfs_h *g, const void *ptr, size_t size);
-extern char *guestfs___safe_asprintf (guestfs_h *g, const char *fs, ...)
+extern GUESTFS_DLL_PUBLIC void *guestfs_int_safe_malloc (guestfs_h *g, size_t nbytes);
+extern GUESTFS_DLL_PUBLIC void *guestfs_int_safe_calloc (guestfs_h *g, size_t n, size_t s);
+extern GUESTFS_DLL_PUBLIC char *guestfs_int_safe_strdup (guestfs_h *g, const char *str);
+extern GUESTFS_DLL_PUBLIC void *guestfs_int_safe_memdup (guestfs_h *g, const void *ptr, size_t size);
+extern void *guestfs_int_safe_realloc (guestfs_h *g, void *ptr, size_t nbytes);
+extern char *guestfs_int_safe_strdup (guestfs_h *g, const char *str);
+extern char *guestfs_int_safe_strndup (guestfs_h *g, const char *str, size_t n);
+extern void *guestfs_int_safe_memdup (guestfs_h *g, const void *ptr, size_t size);
+extern char *guestfs_int_safe_asprintf (guestfs_h *g, const char *fs, ...)
   __attribute__((format (printf,2,3)));
 
-#define safe_calloc guestfs___safe_calloc
-#define safe_malloc guestfs___safe_malloc
-#define safe_realloc guestfs___safe_realloc
-#define safe_strdup guestfs___safe_strdup
-#define safe_strndup guestfs___safe_strndup
-#define safe_memdup guestfs___safe_memdup
-#define safe_asprintf guestfs___safe_asprintf
+#define safe_calloc guestfs_int_safe_calloc
+#define safe_malloc guestfs_int_safe_malloc
+#define safe_realloc guestfs_int_safe_realloc
+#define safe_strdup guestfs_int_safe_strdup
+#define safe_strndup guestfs_int_safe_strndup
+#define safe_memdup guestfs_int_safe_memdup
+#define safe_asprintf guestfs_int_safe_asprintf
 
 /* utils.c */
-extern void guestfs___free_string_list (char **);
-extern size_t guestfs___count_strings (char *const *);
-extern char *guestfs___concat_strings (char *const *);
-extern char **guestfs___copy_string_list (char *const *);
-extern char *guestfs___join_strings (const char *sep, char *const *);
-extern char **guestfs___split_string (char sep, const char *);
-extern char *guestfs___exit_status_to_string (int status, const char *cmd_name, char *buffer, size_t buflen);
-extern int guestfs___random_string (char *ret, size_t len);
-extern char *guestfs___drive_name (size_t index, char *ret);
-extern int guestfs___is_true (const char *str);
+extern void guestfs_int_free_string_list (char **);
+extern size_t guestfs_int_count_strings (char *const *);
+extern char *guestfs_int_concat_strings (char *const *);
+extern char **guestfs_int_copy_string_list (char *const *);
+extern char *guestfs_int_join_strings (const char *sep, char *const *);
+extern char **guestfs_int_split_string (char sep, const char *);
+extern char *guestfs_int_exit_status_to_string (int status, const char *cmd_name, char *buffer, size_t buflen);
+extern int guestfs_int_random_string (char *ret, size_t len);
+extern char *guestfs_int_drive_name (size_t index, char *ret);
+extern int guestfs_int_is_true (const char *str);
 
 /* These functions are used internally by the CLEANUP_* macros.
  * Don't call them directly.
  */
-extern void guestfs___cleanup_free (void *ptr);
-extern void guestfs___cleanup_free_string_list (char ***ptr);
-extern void guestfs___cleanup_hash_free (void *ptr);
-extern void guestfs___cleanup_unlink_free (char **ptr);
-extern void guestfs___cleanup_xmlBufferFree (void *ptr);
-extern void guestfs___cleanup_xmlFreeDoc (void *ptr);
-extern void guestfs___cleanup_xmlFreeURI (void *ptr);
-extern void guestfs___cleanup_xmlFreeTextWriter (void *ptr);
-extern void guestfs___cleanup_xmlXPathFreeContext (void *ptr);
-extern void guestfs___cleanup_xmlXPathFreeObject (void *ptr);
-extern void guestfs___cleanup_fclose (void *ptr);
-extern void guestfs___cleanup_pclose (void *ptr);
+extern void guestfs_int_cleanup_free (void *ptr);
+extern void guestfs_int_cleanup_free_string_list (char ***ptr);
+extern void guestfs_int_cleanup_hash_free (void *ptr);
+extern void guestfs_int_cleanup_unlink_free (char **ptr);
+extern void guestfs_int_cleanup_xmlBufferFree (void *ptr);
+extern void guestfs_int_cleanup_xmlFreeDoc (void *ptr);
+extern void guestfs_int_cleanup_xmlFreeURI (void *ptr);
+extern void guestfs_int_cleanup_xmlFreeTextWriter (void *ptr);
+extern void guestfs_int_cleanup_xmlXPathFreeContext (void *ptr);
+extern void guestfs_int_cleanup_xmlXPathFreeObject (void *ptr);
+extern void guestfs_int_cleanup_fclose (void *ptr);
+extern void guestfs_int_cleanup_pclose (void *ptr);
 
 /* These are in a separate header so the header can be generated.
  * Don't include the following file directly:
@@ -139,7 +139,7 @@ extern void guestfs___cleanup_pclose (void *ptr);
  * internally within the libguestfs code, not to external users.
  */
 
-struct guestfs___add_libvirt_dom_argv {
+struct guestfs_int_add_libvirt_dom_argv {
   uint64_t bitmask;
 #define GUESTFS___ADD_LIBVIRT_DOM_READONLY_BITMASK (UINT64_C(1)<<0)
   int readonly;
@@ -157,17 +157,17 @@ struct guestfs___add_libvirt_dom_argv {
   int copyonread;
 };
 
-extern GUESTFS_DLL_PUBLIC int guestfs___add_libvirt_dom (guestfs_h *g, virDomainPtr dom, const struct guestfs___add_libvirt_dom_argv *optargs);
+extern GUESTFS_DLL_PUBLIC int guestfs_int_add_libvirt_dom (guestfs_h *g, virDomainPtr dom, const struct guestfs_int_add_libvirt_dom_argv *optargs);
 
 #endif /* HAVE_LIBVIRT */
 
 /* Current program name.  Note <errno.h> must be included in all files
- * that want to use 'guestfs___program_name'.
+ * that want to use 'guestfs_int_program_name'.
  */
 #if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME == 1
-#  define guestfs___program_name program_invocation_short_name
+#  define guestfs_int_program_name program_invocation_short_name
 #else
-#  define guestfs___program_name "libguestfs"
+#  define guestfs_int_program_name "libguestfs"
 #endif
 
 /* Close all file descriptors matching the condition. */
diff --git a/src/guestfs-internal.h b/src/guestfs-internal.h
index 65f3388..6c16622 100644
--- a/src/guestfs-internal.h
+++ b/src/guestfs-internal.h
@@ -415,7 +415,7 @@ struct guestfs_h
   for (i = 0; i < (g)->nr_drives; ++i)    \
     if (((drv) = (g)->drives[i]) != NULL)
 
-  /* Backend.  NB: Use guestfs___set_backend to change the backend. */
+  /* Backend.  NB: Use guestfs_int_set_backend to change the backend. */
   char *backend;                /* The full string, always non-NULL. */
   char *backend_arg;            /* Pointer to the argument part. */
   const struct backend_ops *backend_ops;
@@ -428,7 +428,7 @@ struct guestfs_h
 
   /* Temporary and cache directories. */
   /* The actual temporary directory - this is not created with the
-   * handle, you have to call guestfs___lazy_make_tmpdir.
+   * handle, you have to call guestfs_int_lazy_make_tmpdir.
    */
   char *tmpdir;
   /* Environment variables that affect tmpdir/cachedir locations. */
@@ -449,7 +449,7 @@ struct guestfs_h
   size_t nr_events;
 
   /* Information gathered by inspect_os.  Must be freed by calling
-   * guestfs___free_inspect_info.
+   * guestfs_int_free_inspect_info.
    */
   struct inspect_fs *fses;
   size_t nr_fses;
@@ -611,43 +611,43 @@ struct guestfs_message_error;
 struct guestfs_progress;
 
 /* handle.c */
-extern int guestfs___get_backend_setting_bool (guestfs_h *g, const char *name);
+extern int guestfs_int_get_backend_setting_bool (guestfs_h *g, const char *name);
 
 /* errors.c */
-extern void guestfs___init_error_handler (guestfs_h *g);
+extern void guestfs_int_init_error_handler (guestfs_h *g);
 
-extern void guestfs___error_errno (guestfs_h *g, int errnum, const char *fs, ...)
+extern void guestfs_int_error_errno (guestfs_h *g, int errnum, const char *fs, ...)
   __attribute__((format (printf,3,4)));
-extern void guestfs___perrorf (guestfs_h *g, const char *fs, ...)
+extern void guestfs_int_perrorf (guestfs_h *g, const char *fs, ...)
   __attribute__((format (printf,2,3)));
 
-extern void guestfs___warning (guestfs_h *g, const char *fs, ...)
+extern void guestfs_int_warning (guestfs_h *g, const char *fs, ...)
   __attribute__((format (printf,2,3)));
-extern void guestfs___debug (guestfs_h *g, const char *fs, ...)
+extern void guestfs_int_debug (guestfs_h *g, const char *fs, ...)
   __attribute__((format (printf,2,3)));
-extern void guestfs___trace (guestfs_h *g, const char *fs, ...)
+extern void guestfs_int_trace (guestfs_h *g, const char *fs, ...)
   __attribute__((format (printf,2,3)));
 
-extern void guestfs___print_BufferIn (FILE *out, const char *buf, size_t buf_size);
-extern void guestfs___print_BufferOut (FILE *out, const char *buf, size_t buf_size);
+extern void guestfs_int_print_BufferIn (FILE *out, const char *buf, size_t buf_size);
+extern void guestfs_int_print_BufferOut (FILE *out, const char *buf, size_t buf_size);
 
-#define error(g,...) guestfs___error_errno((g),0,__VA_ARGS__)
-#define perrorf guestfs___perrorf
-#define warning(g,...) guestfs___warning((g),__VA_ARGS__)
+#define error(g,...) guestfs_int_error_errno((g),0,__VA_ARGS__)
+#define perrorf guestfs_int_perrorf
+#define warning(g,...) guestfs_int_warning((g),__VA_ARGS__)
 #define debug(g,...) \
-  do { if ((g)->verbose) guestfs___debug ((g),__VA_ARGS__); } while (0)
+  do { if ((g)->verbose) guestfs_int_debug ((g),__VA_ARGS__); } while (0)
 
 #define NOT_SUPPORTED(g,errcode,...)                     \
   do {                                                   \
-    guestfs___error_errno ((g), ENOTSUP, __VA_ARGS__);   \
+    guestfs_int_error_errno ((g), ENOTSUP, __VA_ARGS__);   \
     return (errcode);                                    \
   }                                                      \
   while (0)
 
-extern void guestfs___launch_failed_error (guestfs_h *g);
-extern void guestfs___unexpected_close_error (guestfs_h *g);
-extern void guestfs___launch_timeout (guestfs_h *g);
-extern void guestfs___external_command_failed (guestfs_h *g, int status, const char *cmd_name, const char *extra);
+extern void guestfs_int_launch_failed_error (guestfs_h *g);
+extern void guestfs_int_unexpected_close_error (guestfs_h *g);
+extern void guestfs_int_launch_timeout (guestfs_h *g);
+extern void guestfs_int_external_command_failed (guestfs_h *g, int status, const char *cmd_name, const char *extra);
 
 /* actions-support.c */
 struct trace_buffer {
@@ -657,25 +657,25 @@ struct trace_buffer {
   bool opened;
 };
 
-extern int guestfs___check_reply_header (guestfs_h *g, const struct guestfs_message_header *hdr, unsigned int proc_nr, unsigned int serial);
-extern int guestfs___check_appliance_up (guestfs_h *g, const char *caller);
-extern void guestfs___trace_open (struct trace_buffer *tb);
-extern void guestfs___trace_send_line (guestfs_h *g, struct trace_buffer *tb);
+extern int guestfs_int_check_reply_header (guestfs_h *g, const struct guestfs_message_header *hdr, unsigned int proc_nr, unsigned int serial);
+extern int guestfs_int_check_appliance_up (guestfs_h *g, const char *caller);
+extern void guestfs_int_trace_open (struct trace_buffer *tb);
+extern void guestfs_int_trace_send_line (guestfs_h *g, struct trace_buffer *tb);
 
 /* match.c */
-extern int guestfs___match (guestfs_h *g, const char *str, const pcre *re);
-extern char *guestfs___match1 (guestfs_h *g, const char *str, const pcre *re);
-extern int guestfs___match2 (guestfs_h *g, const char *str, const pcre *re, char **ret1, char **ret2);
-extern int guestfs___match3 (guestfs_h *g, const char *str, const pcre *re, char **ret1, char **ret2, char **ret3);
-extern int guestfs___match4 (guestfs_h *g, const char *str, const pcre *re, char **ret1, char **ret2, char **ret3, char **ret4);
-extern int guestfs___match6 (guestfs_h *g, const char *str, const pcre *re, char **ret1, char **ret2, char **ret3, char **ret4, char **ret5, char **ret6);
+extern int guestfs_int_match (guestfs_h *g, const char *str, const pcre *re);
+extern char *guestfs_int_match1 (guestfs_h *g, const char *str, const pcre *re);
+extern int guestfs_int_match2 (guestfs_h *g, const char *str, const pcre *re, char **ret1, char **ret2);
+extern int guestfs_int_match3 (guestfs_h *g, const char *str, const pcre *re, char **ret1, char **ret2, char **ret3);
+extern int guestfs_int_match4 (guestfs_h *g, const char *str, const pcre *re, char **ret1, char **ret2, char **ret3, char **ret4);
+extern int guestfs_int_match6 (guestfs_h *g, const char *str, const pcre *re, char **ret1, char **ret2, char **ret3, char **ret4, char **ret5, char **ret6);
 
-#define match guestfs___match
-#define match1 guestfs___match1
-#define match2 guestfs___match2
-#define match3 guestfs___match3
-#define match4 guestfs___match4
-#define match6 guestfs___match6
+#define match guestfs_int_match
+#define match1 guestfs_int_match1
+#define match2 guestfs_int_match2
+#define match3 guestfs_int_match3
+#define match4 guestfs_int_match4
+#define match6 guestfs_int_match6
 
 /* stringsbuf.c */
 struct stringsbuf {
@@ -686,117 +686,117 @@ struct stringsbuf {
 #define DECLARE_STRINGSBUF(v) \
   struct stringsbuf (v) = { .argv = NULL, .size = 0, .alloc = 0 }
 
-extern void guestfs___add_string_nodup (guestfs_h *g, struct stringsbuf *sb, char *str);
-extern void guestfs___add_string (guestfs_h *g, struct stringsbuf *sb, const char *str);
-extern void guestfs___add_sprintf (guestfs_h *g, struct stringsbuf *sb, const char *fs, ...)
+extern void guestfs_int_add_string_nodup (guestfs_h *g, struct stringsbuf *sb, char *str);
+extern void guestfs_int_add_string (guestfs_h *g, struct stringsbuf *sb, const char *str);
+extern void guestfs_int_add_sprintf (guestfs_h *g, struct stringsbuf *sb, const char *fs, ...)
   __attribute__((format (printf,3,4)));
-extern void guestfs___end_stringsbuf (guestfs_h *g, struct stringsbuf *sb);
+extern void guestfs_int_end_stringsbuf (guestfs_h *g, struct stringsbuf *sb);
 
-extern void guestfs___free_stringsbuf (struct stringsbuf *sb);
+extern void guestfs_int_free_stringsbuf (struct stringsbuf *sb);
 
 #ifdef HAVE_ATTRIBUTE_CLEANUP
-#define CLEANUP_FREE_STRINGSBUF __attribute__((cleanup(guestfs___cleanup_free_stringsbuf)))
+#define CLEANUP_FREE_STRINGSBUF __attribute__((cleanup(guestfs_int_cleanup_free_stringsbuf)))
 #else
 #define CLEANUP_FREE_STRINGSBUF
 #endif
-extern void guestfs___cleanup_free_stringsbuf (struct stringsbuf *sb);
+extern void guestfs_int_cleanup_free_stringsbuf (struct stringsbuf *sb);
 
 /* proto.c */
-extern int guestfs___send (guestfs_h *g, int proc_nr, uint64_t progress_hint, uint64_t optargs_bitmask, xdrproc_t xdrp, char *args);
-extern int guestfs___recv (guestfs_h *g, const char *fn, struct guestfs_message_header *hdr, struct guestfs_message_error *err, xdrproc_t xdrp, char *ret);
-extern int guestfs___recv_discard (guestfs_h *g, const char *fn);
-extern int guestfs___send_file (guestfs_h *g, const char *filename);
-extern int guestfs___recv_file (guestfs_h *g, const char *filename);
-extern int guestfs___recv_from_daemon (guestfs_h *g, uint32_t *size_rtn, void **buf_rtn);
-extern void guestfs___progress_message_callback (guestfs_h *g, const struct guestfs_progress *message);
-extern void guestfs___log_message_callback (guestfs_h *g, const char *buf, size_t len);
+extern int guestfs_int_send (guestfs_h *g, int proc_nr, uint64_t progress_hint, uint64_t optargs_bitmask, xdrproc_t xdrp, char *args);
+extern int guestfs_int_recv (guestfs_h *g, const char *fn, struct guestfs_message_header *hdr, struct guestfs_message_error *err, xdrproc_t xdrp, char *ret);
+extern int guestfs_int_recv_discard (guestfs_h *g, const char *fn);
+extern int guestfs_int_send_file (guestfs_h *g, const char *filename);
+extern int guestfs_int_recv_file (guestfs_h *g, const char *filename);
+extern int guestfs_int_recv_from_daemon (guestfs_h *g, uint32_t *size_rtn, void **buf_rtn);
+extern void guestfs_int_progress_message_callback (guestfs_h *g, const struct guestfs_progress *message);
+extern void guestfs_int_log_message_callback (guestfs_h *g, const char *buf, size_t len);
 
 /* conn-socket.c */
-extern struct connection *guestfs___new_conn_socket_listening (guestfs_h *g, int daemon_accept_sock, int console_sock);
-extern struct connection *guestfs___new_conn_socket_connected (guestfs_h *g, int daemon_sock, int console_sock);
+extern struct connection *guestfs_int_new_conn_socket_listening (guestfs_h *g, int daemon_accept_sock, int console_sock);
+extern struct connection *guestfs_int_new_conn_socket_connected (guestfs_h *g, int daemon_sock, int console_sock);
 
 /* events.c */
-extern void guestfs___call_callbacks_void (guestfs_h *g, uint64_t event);
-extern void guestfs___call_callbacks_message (guestfs_h *g, uint64_t event, const char *buf, size_t buf_len);
-extern void guestfs___call_callbacks_array (guestfs_h *g, uint64_t event, const uint64_t *array, size_t array_len);
+extern void guestfs_int_call_callbacks_void (guestfs_h *g, uint64_t event);
+extern void guestfs_int_call_callbacks_message (guestfs_h *g, uint64_t event, const char *buf, size_t buf_len);
+extern void guestfs_int_call_callbacks_array (guestfs_h *g, uint64_t event, const uint64_t *array, size_t array_len);
 
 /* tmpdirs.c */
-extern int guestfs___set_env_tmpdir (guestfs_h *g, const char *tmpdir);
-extern int guestfs___lazy_make_tmpdir (guestfs_h *g);
-extern void guestfs___remove_tmpdir (guestfs_h *g);
-extern void guestfs___recursive_remove_dir (guestfs_h *g, const char *dir);
+extern int guestfs_int_set_env_tmpdir (guestfs_h *g, const char *tmpdir);
+extern int guestfs_int_lazy_make_tmpdir (guestfs_h *g);
+extern void guestfs_int_remove_tmpdir (guestfs_h *g);
+extern void guestfs_int_recursive_remove_dir (guestfs_h *g, const char *dir);
 
 /* drives.c */
-extern size_t guestfs___checkpoint_drives (guestfs_h *g);
-extern void guestfs___rollback_drives (guestfs_h *g, size_t);
-extern void guestfs___add_dummy_appliance_drive (guestfs_h *g);
-extern void guestfs___free_drives (guestfs_h *g);
-extern const char *guestfs___drive_protocol_to_string (enum drive_protocol protocol);
+extern size_t guestfs_int_checkpoint_drives (guestfs_h *g);
+extern void guestfs_int_rollback_drives (guestfs_h *g, size_t);
+extern void guestfs_int_add_dummy_appliance_drive (guestfs_h *g);
+extern void guestfs_int_free_drives (guestfs_h *g);
+extern const char *guestfs_int_drive_protocol_to_string (enum drive_protocol protocol);
 
 /* appliance.c */
-extern int guestfs___build_appliance (guestfs_h *g, char **kernel, char **dtb, char **initrd, char **appliance);
-extern int guestfs___get_uefi (guestfs_h *g, char **code, char **vars);
+extern int guestfs_int_build_appliance (guestfs_h *g, char **kernel, char **dtb, char **initrd, char **appliance);
+extern int guestfs_int_get_uefi (guestfs_h *g, char **code, char **vars);
 
 /* launch.c */
-extern int64_t guestfs___timeval_diff (const struct timeval *x, const struct timeval *y);
-extern void guestfs___print_timestamped_message (guestfs_h *g, const char *fs, ...) __attribute__((format (printf,2,3)));
-extern void guestfs___launch_send_progress (guestfs_h *g, int perdozen);
-extern char *guestfs___appliance_command_line (guestfs_h *g, const char *appliance_dev, int flags);
+extern int64_t guestfs_int_timeval_diff (const struct timeval *x, const struct timeval *y);
+extern void guestfs_int_print_timestamped_message (guestfs_h *g, const char *fs, ...) __attribute__((format (printf,2,3)));
+extern void guestfs_int_launch_send_progress (guestfs_h *g, int perdozen);
+extern char *guestfs_int_appliance_command_line (guestfs_h *g, const char *appliance_dev, int flags);
 #define APPLIANCE_COMMAND_LINE_IS_TCG 1
-const char *guestfs___get_cpu_model (int kvm);
-extern void guestfs___register_backend (const char *name, const struct backend_ops *);
-extern int guestfs___set_backend (guestfs_h *g, const char *method);
+const char *guestfs_int_get_cpu_model (int kvm);
+extern void guestfs_int_register_backend (const char *name, const struct backend_ops *);
+extern int guestfs_int_set_backend (guestfs_h *g, const char *method);
 
 /* inspect.c */
-extern void guestfs___free_inspect_info (guestfs_h *g);
-extern char *guestfs___download_to_tmp (guestfs_h *g, struct inspect_fs *fs, const char *filename, const char *basename, uint64_t max_size);
-extern struct inspect_fs *guestfs___search_for_root (guestfs_h *g, const char *root);
-extern int guestfs___is_partition (guestfs_h *g, const char *partition);
+extern void guestfs_int_free_inspect_info (guestfs_h *g);
+extern char *guestfs_int_download_to_tmp (guestfs_h *g, struct inspect_fs *fs, const char *filename, const char *basename, uint64_t max_size);
+extern struct inspect_fs *guestfs_int_search_for_root (guestfs_h *g, const char *root);
+extern int guestfs_int_is_partition (guestfs_h *g, const char *partition);
 
 /* inspect-fs.c */
-extern int guestfs___is_file_nocase (guestfs_h *g, const char *);
-extern int guestfs___is_dir_nocase (guestfs_h *g, const char *);
-extern int guestfs___check_for_filesystem_on (guestfs_h *g,
+extern int guestfs_int_is_file_nocase (guestfs_h *g, const char *);
+extern int guestfs_int_is_dir_nocase (guestfs_h *g, const char *);
+extern int guestfs_int_check_for_filesystem_on (guestfs_h *g,
                                               const char *mountable);
-extern int guestfs___parse_unsigned_int (guestfs_h *g, const char *str);
-extern int guestfs___parse_unsigned_int_ignore_trailing (guestfs_h *g, const char *str);
-extern int guestfs___parse_major_minor (guestfs_h *g, struct inspect_fs *fs);
-extern char *guestfs___first_line_of_file (guestfs_h *g, const char *filename);
-extern int guestfs___first_egrep_of_file (guestfs_h *g, const char *filename, const char *eregex, int iflag, char **ret);
-extern void guestfs___check_package_format (guestfs_h *g, struct inspect_fs *fs);
-extern void guestfs___check_package_management (guestfs_h *g, struct inspect_fs *fs);
+extern int guestfs_int_parse_unsigned_int (guestfs_h *g, const char *str);
+extern int guestfs_int_parse_unsigned_int_ignore_trailing (guestfs_h *g, const char *str);
+extern int guestfs_int_parse_major_minor (guestfs_h *g, struct inspect_fs *fs);
+extern char *guestfs_int_first_line_of_file (guestfs_h *g, const char *filename);
+extern int guestfs_int_first_egrep_of_file (guestfs_h *g, const char *filename, const char *eregex, int iflag, char **ret);
+extern void guestfs_int_check_package_format (guestfs_h *g, struct inspect_fs *fs);
+extern void guestfs_int_check_package_management (guestfs_h *g, struct inspect_fs *fs);
 
 /* inspect-fs-unix.c */
-extern int guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs);
-extern int guestfs___check_freebsd_root (guestfs_h *g, struct inspect_fs *fs);
-extern int guestfs___check_netbsd_root (guestfs_h *g, struct inspect_fs *fs);
-extern int guestfs___check_hurd_root (guestfs_h *g, struct inspect_fs *fs);
-extern int guestfs___check_minix_root (guestfs_h *g, struct inspect_fs *fs);
+extern int guestfs_int_check_linux_root (guestfs_h *g, struct inspect_fs *fs);
+extern int guestfs_int_check_freebsd_root (guestfs_h *g, struct inspect_fs *fs);
+extern int guestfs_int_check_netbsd_root (guestfs_h *g, struct inspect_fs *fs);
+extern int guestfs_int_check_hurd_root (guestfs_h *g, struct inspect_fs *fs);
+extern int guestfs_int_check_minix_root (guestfs_h *g, struct inspect_fs *fs);
 
 /* inspect-fs-windows.c */
-extern char *guestfs___case_sensitive_path_silently (guestfs_h *g, const char *);
-extern char * guestfs___get_windows_systemroot (guestfs_h *g);
-extern int guestfs___check_windows_root (guestfs_h *g, struct inspect_fs *fs, char *windows_systemroot);
+extern char *guestfs_int_case_sensitive_path_silently (guestfs_h *g, const char *);
+extern char * guestfs_int_get_windows_systemroot (guestfs_h *g);
+extern int guestfs_int_check_windows_root (guestfs_h *g, struct inspect_fs *fs, char *windows_systemroot);
 
 /* inspect-fs-cd.c */
-extern int guestfs___check_installer_root (guestfs_h *g, struct inspect_fs *fs);
-extern int guestfs___check_installer_iso (guestfs_h *g, struct inspect_fs *fs, const char *device);
+extern int guestfs_int_check_installer_root (guestfs_h *g, struct inspect_fs *fs);
+extern int guestfs_int_check_installer_iso (guestfs_h *g, struct inspect_fs *fs, const char *device);
 
 /* dbdump.c */
-typedef int (*guestfs___db_dump_callback) (guestfs_h *g, const unsigned char *key, size_t keylen, const unsigned char *value, size_t valuelen, void *opaque);
-extern int guestfs___read_db_dump (guestfs_h *g, const char *dumpfile, void *opaque, guestfs___db_dump_callback callback);
+typedef int (*guestfs_int_db_dump_callback) (guestfs_h *g, const unsigned char *key, size_t keylen, const unsigned char *value, size_t valuelen, void *opaque);
+extern int guestfs_int_read_db_dump (guestfs_h *g, const char *dumpfile, void *opaque, guestfs_int_db_dump_callback callback);
 
 /* lpj.c */
-extern int guestfs___get_lpj (guestfs_h *g);
+extern int guestfs_int_get_lpj (guestfs_h *g);
 
 /* fuse.c */
 #if HAVE_FUSE
-extern void guestfs___free_fuse (guestfs_h *g);
+extern void guestfs_int_free_fuse (guestfs_h *g);
 #endif
 
 /* libvirt-auth.c */
 #ifdef HAVE_LIBVIRT
-extern virConnectPtr guestfs___open_libvirt_connection (guestfs_h *g, const char *uri, unsigned int flags);
+extern virConnectPtr guestfs_int_open_libvirt_connection (guestfs_h *g, const char *uri, unsigned int flags);
 #endif
 
 /* osinfo.c */
@@ -823,39 +823,39 @@ struct osinfo {
   pcre *re_publisher_id;
   pcre *re_application_id;
 };
-extern int guestfs___osinfo_map (guestfs_h *g, const struct guestfs_isoinfo *isoinfo, const struct osinfo **osinfo_ret);
+extern int guestfs_int_osinfo_map (guestfs_h *g, const struct guestfs_isoinfo *isoinfo, const struct osinfo **osinfo_ret);
 
 /* command.c */
 struct command;
 typedef void (*cmd_stdout_callback) (guestfs_h *g, void *data, const char *line, size_t len);
-extern struct command *guestfs___new_command (guestfs_h *g);
-extern void guestfs___cmd_add_arg (struct command *, const char *arg);
-extern void guestfs___cmd_add_arg_format (struct command *, const char *fs, ...)
+extern struct command *guestfs_int_new_command (guestfs_h *g);
+extern void guestfs_int_cmd_add_arg (struct command *, const char *arg);
+extern void guestfs_int_cmd_add_arg_format (struct command *, const char *fs, ...)
   __attribute__((format (printf,2,3)));
-extern void guestfs___cmd_add_string_unquoted (struct command *, const char *str);
-extern void guestfs___cmd_add_string_quoted (struct command *, const char *str);
-extern void guestfs___cmd_set_stdout_callback (struct command *, cmd_stdout_callback stdout_callback, void *data, unsigned flags);
+extern void guestfs_int_cmd_add_string_unquoted (struct command *, const char *str);
+extern void guestfs_int_cmd_add_string_quoted (struct command *, const char *str);
+extern void guestfs_int_cmd_set_stdout_callback (struct command *, cmd_stdout_callback stdout_callback, void *data, unsigned flags);
 #define CMD_STDOUT_FLAG_LINE_BUFFER    0
 #define CMD_STDOUT_FLAG_UNBUFFERED      1
 #define CMD_STDOUT_FLAG_WHOLE_BUFFER    2
-extern void guestfs___cmd_set_stderr_to_stdout (struct command *);
-extern void guestfs___cmd_clear_capture_errors (struct command *);
-extern void guestfs___cmd_clear_close_files (struct command *);
-extern int guestfs___cmd_run (struct command *);
-extern void guestfs___cmd_close (struct command *);
+extern void guestfs_int_cmd_set_stderr_to_stdout (struct command *);
+extern void guestfs_int_cmd_clear_capture_errors (struct command *);
+extern void guestfs_int_cmd_clear_close_files (struct command *);
+extern int guestfs_int_cmd_run (struct command *);
+extern void guestfs_int_cmd_close (struct command *);
 
 #ifdef HAVE_ATTRIBUTE_CLEANUP
-#define CLEANUP_CMD_CLOSE __attribute__((cleanup(guestfs___cleanup_cmd_close)))
+#define CLEANUP_CMD_CLOSE __attribute__((cleanup(guestfs_int_cleanup_cmd_close)))
 #else
 #define CLEANUP_CMD_CLOSE
 #endif
-extern void guestfs___cleanup_cmd_close (struct command **);
+extern void guestfs_int_cleanup_cmd_close (struct command **);
 
 /* launch-direct.c */
-extern char *guestfs___drive_source_qemu_param (guestfs_h *g, const struct drive_source *src);
-extern bool guestfs___discard_possible (guestfs_h *g, struct drive *drv, unsigned long qemu_version);
+extern char *guestfs_int_drive_source_qemu_param (guestfs_h *g, const struct drive_source *src);
+extern bool guestfs_int_discard_possible (guestfs_h *g, struct drive *drv, unsigned long qemu_version);
 
 /* guid.c */
-extern int guestfs___validate_guid (const char *);
+extern int guestfs_int_validate_guid (const char *);
 
 #endif /* GUESTFS_INTERNAL_H_ */
diff --git a/src/guid.c b/src/guid.c
index 8f6da4f..a69f5ec 100644
--- a/src/guid.c
+++ b/src/guid.c
@@ -32,7 +32,7 @@
  * or '21EC2020-3AEA-1069-A2DD-08002B30309D'.
  */
 int
-guestfs___validate_guid (const char *str)
+guestfs_int_validate_guid (const char *str)
 {
   size_t i, len = strlen (str);
 
diff --git a/src/handle.c b/src/handle.c
index 0990082..b712e21 100644
--- a/src/handle.c
+++ b/src/handle.c
@@ -88,7 +88,7 @@ guestfs_create_flags (unsigned flags, ...)
 
   g->conn = NULL;
 
-  guestfs___init_error_handler (g);
+  guestfs_int_init_error_handler (g);
   g->abort_cb = abort;
 
   g->recovery_proc = 1;
@@ -130,9 +130,9 @@ guestfs_create_flags (unsigned flags, ...)
 #endif
   if (!g->program) goto error;
 
-  if (guestfs___set_backend (g, DEFAULT_BACKEND) == -1) {
+  if (guestfs_int_set_backend (g, DEFAULT_BACKEND) == -1) {
     warning (g, _("libguestfs was built with an invalid default backend, using 'direct' instead"));
-    if (guestfs___set_backend (g, "direct") == -1) {
+    if (guestfs_int_set_backend (g, "direct") == -1) {
       warning (g, _("'direct' backend does not work"));
       goto error;
     }
@@ -161,7 +161,7 @@ guestfs_create_flags (unsigned flags, ...)
   return g;
 
  error:
-  guestfs___free_string_list (g->backend_settings);
+  guestfs_int_free_string_list (g->backend_settings);
   free (g->backend);
   free (g->program);
   free (g->path);
@@ -185,7 +185,7 @@ parse_environment (guestfs_h *g,
 
   str = do_getenv (data, "LIBGUESTFS_TRACE");
   if (str) {
-    b = guestfs___is_true (str);
+    b = guestfs_int_is_true (str);
     if (b == -1) {
       error (g, _("%s=%s: non-boolean value"), "LIBGUESTFS_TRACE", str);
       return -1;
@@ -195,7 +195,7 @@ parse_environment (guestfs_h *g,
 
   str = do_getenv (data, "LIBGUESTFS_DEBUG");
   if (str) {
-    b = guestfs___is_true (str);
+    b = guestfs_int_is_true (str);
     if (b == -1) {
       error (g, _("%s=%s: non-boolean value"), "LIBGUESTFS_TRACE", str);
       return -1;
@@ -216,7 +216,7 @@ parse_environment (guestfs_h *g,
   }
 
   str = do_getenv (data, "TMPDIR");
-  if (guestfs___set_env_tmpdir (g, str) == -1)
+  if (guestfs_int_set_env_tmpdir (g, str) == -1)
     return -1;
 
   str = do_getenv (data, "LIBGUESTFS_PATH");
@@ -263,7 +263,7 @@ parse_environment (guestfs_h *g,
 
   str = do_getenv (data, "LIBGUESTFS_BACKEND_SETTINGS");
   if (str) {
-    CLEANUP_FREE_STRING_LIST char **settings = guestfs___split_string (':', str);
+    CLEANUP_FREE_STRING_LIST char **settings = guestfs_int_split_string (':', str);
 
     if (settings == NULL) {
       perrorf (g, "split_string: malloc");
@@ -332,7 +332,7 @@ guestfs_close (guestfs_h *g)
   if (g->trace) {
     const char trace_msg[] = "close";
 
-    guestfs___call_callbacks_message (g, GUESTFS_EVENT_TRACE,
+    guestfs_int_call_callbacks_message (g, GUESTFS_EVENT_TRACE,
                                       trace_msg, strlen (trace_msg));
   }
 
@@ -342,14 +342,14 @@ guestfs_close (guestfs_h *g)
     shutdown_backend (g, 0);
 
   /* Run user close callbacks. */
-  guestfs___call_callbacks_void (g, GUESTFS_EVENT_CLOSE);
+  guestfs_int_call_callbacks_void (g, GUESTFS_EVENT_CLOSE);
 
   /* Test output file used by bindtests. */
   if (g->test_fp != NULL)
     fclose (g->test_fp);
 
   /* Remove temporary directory. */
-  guestfs___remove_tmpdir (g);
+  guestfs_int_remove_tmpdir (g);
 
   /* Mark the handle as dead and then free up all memory. */
   g->state = NO_HANDLE;
@@ -359,11 +359,11 @@ guestfs_close (guestfs_h *g)
   g->events = NULL;
 
 #if HAVE_FUSE
-  guestfs___free_fuse (g);
+  guestfs_int_free_fuse (g);
 #endif
 
-  guestfs___free_inspect_info (g);
-  guestfs___free_drives (g);
+  guestfs_int_free_inspect_info (g);
+  guestfs_int_free_drives (g);
 
   for (hp = g->hv_params; hp; hp = hp_next) {
     free (hp->hv_param);
@@ -387,7 +387,7 @@ guestfs_close (guestfs_h *g)
   free (g->hv);
   free (g->backend);
   free (g->backend_data);
-  guestfs___free_string_list (g->backend_settings);
+  guestfs_int_free_string_list (g->backend_settings);
   free (g->append);
   free (g);
 }
@@ -444,7 +444,7 @@ shutdown_backend (guestfs_h *g, int check_for_errors)
     g->conn = NULL;
   }
 
-  guestfs___free_drives (g);
+  guestfs_int_free_drives (g);
 
   g->state = CONFIG;
 
@@ -677,7 +677,7 @@ guestfs__get_program (guestfs_h *g)
 int
 guestfs__set_backend (guestfs_h *g, const char *method)
 {
-  if (guestfs___set_backend (g, method) == -1) {
+  if (guestfs_int_set_backend (g, method) == -1) {
     error (g, "invalid backend: %s", method);
     return -1;
   }
@@ -712,13 +712,13 @@ guestfs__set_backend_settings (guestfs_h *g, char *const *settings)
 {
   char **copy;
 
-  copy = guestfs___copy_string_list (settings);
+  copy = guestfs_int_copy_string_list (settings);
   if (copy == NULL) {
     perrorf (g, "copy: malloc");
     return -1;
   }
 
-  guestfs___free_string_list (g->backend_settings);
+  guestfs_int_free_string_list (g->backend_settings);
   g->backend_settings = copy;
 
   return 0;
@@ -731,9 +731,9 @@ guestfs__get_backend_settings (guestfs_h *g)
   char **ret;
 
   if (g->backend_settings == NULL)
-    ret = guestfs___copy_string_list (empty_list);
+    ret = guestfs_int_copy_string_list (empty_list);
   else
-    ret = guestfs___copy_string_list (g->backend_settings);
+    ret = guestfs_int_copy_string_list (g->backend_settings);
 
   if (ret == NULL) {
     perrorf (g, "copy: malloc");
@@ -763,7 +763,7 @@ guestfs__get_backend_setting (guestfs_h *g, const char *name)
   }
 
  not_found:
-  guestfs___error_errno (g, ESRCH, _("setting not found"));
+  guestfs_int_error_errno (g, ESRCH, _("setting not found"));
   return NULL;
 }
 
@@ -810,7 +810,7 @@ guestfs__set_backend_setting (guestfs_h *g, const char *name, const char *value)
   }
   else {
     ignore_value (guestfs_clear_backend_setting (g, name));
-    len = guestfs___count_strings (g->backend_settings);
+    len = guestfs_int_count_strings (g->backend_settings);
   }
 
   g->backend_settings =
@@ -825,7 +825,7 @@ guestfs__set_backend_setting (guestfs_h *g, const char *name, const char *value)
  * it as an API in future.
  */
 int
-guestfs___get_backend_setting_bool (guestfs_h *g, const char *name)
+guestfs_int_get_backend_setting_bool (guestfs_h *g, const char *name)
 {
   CLEANUP_FREE char *value = NULL;
   int b;
@@ -840,7 +840,7 @@ guestfs___get_backend_setting_bool (guestfs_h *g, const char *name)
   if (value == NULL)
     return -1;
 
-  b = guestfs___is_true (value);
+  b = guestfs_int_is_true (value);
   if (b == -1)
     return -1;
 
diff --git a/src/info.c b/src/info.c
index 175c503..cec042b 100644
--- a/src/info.c
+++ b/src/info.c
@@ -236,7 +236,7 @@ static void parse_json (guestfs_h *g, void *treevp, const char *input, size_t le
 static yajl_val
 get_json_output (guestfs_h *g, const char *filename)
 {
-  CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
   int fd, r;
   char fdpath[64];
   yajl_val tree = NULL;
@@ -260,21 +260,21 @@ get_json_output (guestfs_h *g, const char *filename)
   }
 
   snprintf (fdpath, sizeof fdpath, "/dev/fd/%d", fd);
-  guestfs___cmd_clear_close_files (cmd);
+  guestfs_int_cmd_clear_close_files (cmd);
 
-  guestfs___cmd_add_arg (cmd, "qemu-img");
-  guestfs___cmd_add_arg (cmd, "info");
-  guestfs___cmd_add_arg (cmd, "--output");
-  guestfs___cmd_add_arg (cmd, "json");
-  guestfs___cmd_add_arg (cmd, fdpath);
-  guestfs___cmd_set_stdout_callback (cmd, parse_json, &tree,
+  guestfs_int_cmd_add_arg (cmd, "qemu-img");
+  guestfs_int_cmd_add_arg (cmd, "info");
+  guestfs_int_cmd_add_arg (cmd, "--output");
+  guestfs_int_cmd_add_arg (cmd, "json");
+  guestfs_int_cmd_add_arg (cmd, fdpath);
+  guestfs_int_cmd_set_stdout_callback (cmd, parse_json, &tree,
                                      CMD_STDOUT_FLAG_WHOLE_BUFFER);
-  r = guestfs___cmd_run (cmd);
+  r = guestfs_int_cmd_run (cmd);
   close (fd);
   if (r == -1)
     return NULL;
   if (!WIFEXITED (r) || WEXITSTATUS (r) != 0) {
-    guestfs___external_command_failed (g, r, "qemu-img info", filename);
+    guestfs_int_external_command_failed (g, r, "qemu-img info", filename);
     return NULL;
   }
 
@@ -331,14 +331,14 @@ which_parser (guestfs_h *g)
 {
   if (g->qemu_img_info_parser == QEMU_IMG_INFO_UNKNOWN_PARSER) {
     int qemu_img_supports_json = 0;
-    CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+    CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
 
-    guestfs___cmd_add_arg (cmd, "qemu-img");
-    guestfs___cmd_add_arg (cmd, "--help");
-    guestfs___cmd_set_stdout_callback (cmd,
+    guestfs_int_cmd_add_arg (cmd, "qemu-img");
+    guestfs_int_cmd_add_arg (cmd, "--help");
+    guestfs_int_cmd_set_stdout_callback (cmd,
                                        help_contains_output_json,
                                        &qemu_img_supports_json, 0);
-    guestfs___cmd_run (cmd);
+    guestfs_int_cmd_run (cmd);
     /* ignore return code, which would usually be 1 */
 
     if (qemu_img_supports_json)
@@ -523,10 +523,10 @@ old_parser_run_qemu_img_info (guestfs_h *g, const char *filename,
 {
   CLEANUP_FREE char *abs_filename = NULL;
   CLEANUP_FREE char *safe_filename = NULL;
-  CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
   int r;
 
-  if (guestfs___lazy_make_tmpdir (g) == -1)
+  if (guestfs_int_lazy_make_tmpdir (g) == -1)
     return -1;
 
   safe_filename = safe_asprintf (g, "%s/format.%d", g->tmpdir, ++g->unique);
@@ -543,15 +543,15 @@ old_parser_run_qemu_img_info (guestfs_h *g, const char *filename,
     return -1;
   }
 
-  guestfs___cmd_add_arg (cmd, "qemu-img");
-  guestfs___cmd_add_arg (cmd, "info");
-  guestfs___cmd_add_arg (cmd, safe_filename);
-  guestfs___cmd_set_stdout_callback (cmd, fn, data, 0);
-  r = guestfs___cmd_run (cmd);
+  guestfs_int_cmd_add_arg (cmd, "qemu-img");
+  guestfs_int_cmd_add_arg (cmd, "info");
+  guestfs_int_cmd_add_arg (cmd, safe_filename);
+  guestfs_int_cmd_set_stdout_callback (cmd, fn, data, 0);
+  r = guestfs_int_cmd_run (cmd);
   if (r == -1)
     return -1;
   if (!WIFEXITED (r) || WEXITSTATUS (r) != 0) {
-    guestfs___external_command_failed (g, r, "qemu-img info", filename);
+    guestfs_int_external_command_failed (g, r, "qemu-img info", filename);
     return -1;
   }
 
diff --git a/src/inspect-apps.c b/src/inspect-apps.c
index a77e9ce..64b0602 100644
--- a/src/inspect-apps.c
+++ b/src/inspect-apps.c
@@ -115,7 +115,7 @@ struct guestfs_application2_list *
 guestfs__inspect_list_applications2 (guestfs_h *g, const char *root)
 {
   struct guestfs_application2_list *ret = NULL;
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return NULL;
 
@@ -353,20 +353,20 @@ list_applications_rpm (guestfs_h *g, struct inspect_fs *fs)
   struct guestfs_application2_list *apps = NULL;
   struct read_package_data data;
 
-  Name = guestfs___download_to_tmp (g, fs,
+  Name = guestfs_int_download_to_tmp (g, fs,
                                     "/var/lib/rpm/Name", "rpm_Name",
                                     MAX_PKG_DB_SIZE);
   if (Name == NULL)
     goto error;
 
-  Packages = guestfs___download_to_tmp (g, fs,
+  Packages = guestfs_int_download_to_tmp (g, fs,
                                         "/var/lib/rpm/Packages", "rpm_Packages",
                                         MAX_PKG_DB_SIZE);
   if (Packages == NULL)
     goto error;
 
   /* Read Name database. */
-  if (guestfs___read_db_dump (g, Name, &list, read_rpm_name) == -1)
+  if (guestfs_int_read_db_dump (g, Name, &list, read_rpm_name) == -1)
     goto error;
 
   /* Sort the names by link field for fast searching. */
@@ -380,7 +380,7 @@ list_applications_rpm (guestfs_h *g, struct inspect_fs *fs)
   /* Read Packages database. */
   data.list = &list;
   data.apps = apps;
-  if (guestfs___read_db_dump (g, Packages, &data, read_package) == -1)
+  if (guestfs_int_read_db_dump (g, Packages, &data, read_package) == -1)
     goto error;
 
   free_rpm_names_list (&list);
@@ -407,7 +407,7 @@ list_applications_deb (guestfs_h *g, struct inspect_fs *fs)
   CLEANUP_FREE char *name = NULL, *version = NULL, *release = NULL, *arch = NULL;
   int installed_flag = 0;
 
-  status = guestfs___download_to_tmp (g, fs, "/var/lib/dpkg/status", "status",
+  status = guestfs_int_download_to_tmp (g, fs, "/var/lib/dpkg/status", "status",
                                       MAX_PKG_DB_SIZE);
   if (status == NULL)
     return NULL;
diff --git a/src/inspect-fs-cd.c b/src/inspect-fs-cd.c
index 8e1e8d0..22d0921 100644
--- a/src/inspect-fs-cd.c
+++ b/src/inspect-fs-cd.c
@@ -56,7 +56,7 @@
 static int
 check_debian_installer_root (guestfs_h *g, struct inspect_fs *fs)
 {
-  fs->product_name = guestfs___first_line_of_file (g, "/.disk/info");
+  fs->product_name = guestfs_int_first_line_of_file (g, "/.disk/info");
   if (!fs->product_name)
     return -1;
 
@@ -66,11 +66,11 @@ check_debian_installer_root (guestfs_h *g, struct inspect_fs *fs)
   else if (STRPREFIX (fs->product_name, "Debian"))
     fs->distro = OS_DISTRO_DEBIAN;
 
-  (void) guestfs___parse_major_minor (g, fs);
+  (void) guestfs_int_parse_major_minor (g, fs);
 
   if (guestfs_is_file (g, "/.disk/cd_type") > 0) {
     CLEANUP_FREE char *cd_type =
-      guestfs___first_line_of_file (g, "/.disk/cd_type");
+      guestfs_int_first_line_of_file (g, "/.disk/cd_type");
     if (!cd_type)
       return -1;
 
@@ -192,7 +192,7 @@ check_fedora_installer_root (guestfs_h *g, struct inspect_fs *fs)
 
   fs->type = OS_TYPE_LINUX;
 
-  r = guestfs___first_egrep_of_file (g, "/.treeinfo",
+  r = guestfs_int_first_egrep_of_file (g, "/.treeinfo",
                                      "^family = Fedora$", 0, &str);
   if (r == -1)
     return -1;
@@ -201,7 +201,7 @@ check_fedora_installer_root (guestfs_h *g, struct inspect_fs *fs)
     free (str);
   }
 
-  r = guestfs___first_egrep_of_file (g, "/.treeinfo",
+  r = guestfs_int_first_egrep_of_file (g, "/.treeinfo",
                                      "^family = Red Hat Enterprise Linux$",
                                      0, &str);
   if (r == -1)
@@ -211,7 +211,7 @@ check_fedora_installer_root (guestfs_h *g, struct inspect_fs *fs)
     free (str);
   }
 
-  r = guestfs___first_egrep_of_file (g, "/.treeinfo",
+  r = guestfs_int_first_egrep_of_file (g, "/.treeinfo",
                                      "^family = Oracle Linux Server$",
                                      0, &str);
   if (r == -1)
@@ -222,19 +222,19 @@ check_fedora_installer_root (guestfs_h *g, struct inspect_fs *fs)
   }
 
   /* XXX should do major.minor before this */
-  r = guestfs___first_egrep_of_file (g, "/.treeinfo",
+  r = guestfs_int_first_egrep_of_file (g, "/.treeinfo",
                                      "^version = [[:digit:]]+", 0, &str);
   if (r == -1)
     return -1;
   if (r > 0) {
     v = find_value (str);
-    fs->major_version = guestfs___parse_unsigned_int_ignore_trailing (g, v);
+    fs->major_version = guestfs_int_parse_unsigned_int_ignore_trailing (g, v);
     free (str);
     if (fs->major_version == -1)
       return -1;
   }
 
-  r = guestfs___first_egrep_of_file (g, "/.treeinfo",
+  r = guestfs_int_first_egrep_of_file (g, "/.treeinfo",
                                      "^arch = [-_[:alnum:]]+$", 0, &str);
   if (r == -1)
     return -1;
@@ -244,25 +244,25 @@ check_fedora_installer_root (guestfs_h *g, struct inspect_fs *fs)
     free (str);
   }
 
-  r = guestfs___first_egrep_of_file (g, "/.treeinfo",
+  r = guestfs_int_first_egrep_of_file (g, "/.treeinfo",
                                      "^discnum = [[:digit:]]+$", 0, &str);
   if (r == -1)
     return -1;
   if (r > 0) {
     v = find_value (str);
-    discnum = guestfs___parse_unsigned_int (g, v);
+    discnum = guestfs_int_parse_unsigned_int (g, v);
     free (str);
     if (discnum == -1)
       return -1;
   }
 
-  r = guestfs___first_egrep_of_file (g, "/.treeinfo",
+  r = guestfs_int_first_egrep_of_file (g, "/.treeinfo",
                                      "^totaldiscs = [[:digit:]]+$", 0, &str);
   if (r == -1)
     return -1;
   if (r > 0) {
     v = find_value (str);
-    totaldiscs = guestfs___parse_unsigned_int (g, v);
+    totaldiscs = guestfs_int_parse_unsigned_int (g, v);
     free (str);
     if (totaldiscs == -1)
       return -1;
@@ -290,7 +290,7 @@ check_isolinux_installer_root (guestfs_h *g, struct inspect_fs *fs)
 
   fs->type = OS_TYPE_LINUX;
 
-  r = guestfs___first_egrep_of_file (g, "/isolinux/isolinux.cfg",
+  r = guestfs_int_first_egrep_of_file (g, "/isolinux/isolinux.cfg",
                                      "^menu title Welcome to Fedora [[:digit:]]+",
                                      0, &str);
   if (r == -1)
@@ -298,14 +298,14 @@ check_isolinux_installer_root (guestfs_h *g, struct inspect_fs *fs)
   if (r > 0) {
     fs->distro = OS_DISTRO_FEDORA;
     fs->major_version =
-      guestfs___parse_unsigned_int_ignore_trailing (g, &str[29]);
+      guestfs_int_parse_unsigned_int_ignore_trailing (g, &str[29]);
     free (str);
     if (fs->major_version == -1)
       return -1;
   }
 
   /* XXX parse major.minor */
-  r = guestfs___first_egrep_of_file (g, "/isolinux/isolinux.cfg",
+  r = guestfs_int_first_egrep_of_file (g, "/isolinux/isolinux.cfg",
                                      "^menu title Welcome to Red Hat Enterprise Linux [[:digit:]]+",
                            0, &str);
   if (r == -1)
@@ -313,14 +313,14 @@ check_isolinux_installer_root (guestfs_h *g, struct inspect_fs *fs)
   if (r > 0) {
     fs->distro = OS_DISTRO_RHEL;
     fs->major_version =
-      guestfs___parse_unsigned_int_ignore_trailing (g, &str[47]);
+      guestfs_int_parse_unsigned_int_ignore_trailing (g, &str[47]);
     free (str);
     if (fs->major_version == -1)
       return -1;
   }
 
   /* XXX parse major.minor */
-  r = guestfs___first_egrep_of_file (g, "/isolinux/isolinux.cfg",
+  r = guestfs_int_first_egrep_of_file (g, "/isolinux/isolinux.cfg",
                                      "^menu title Welcome to RHEL[[:digit:]]+",
                            0, &str);
   if (r == -1)
@@ -328,14 +328,14 @@ check_isolinux_installer_root (guestfs_h *g, struct inspect_fs *fs)
   if (r > 0) {
     fs->distro = OS_DISTRO_RHEL;
     fs->major_version =
-      guestfs___parse_unsigned_int_ignore_trailing (g, &str[26]);
+      guestfs_int_parse_unsigned_int_ignore_trailing (g, &str[26]);
     free (str);
     if (fs->major_version == -1)
       return -1;
   }
 
   /* XXX parse major.minor */
-  r = guestfs___first_egrep_of_file (g, "/isolinux/isolinux.cfg",
+  r = guestfs_int_first_egrep_of_file (g, "/isolinux/isolinux.cfg",
                                      "^menu title Welcome to Oracle Linux Server [[:digit:]]+",
                            0, &str);
   if (r == -1)
@@ -343,7 +343,7 @@ check_isolinux_installer_root (guestfs_h *g, struct inspect_fs *fs)
   if (r > 0) {
     fs->distro = OS_DISTRO_ORACLE_LINUX;
     fs->major_version =
-      guestfs___parse_unsigned_int_ignore_trailing (g, &str[42]);
+      guestfs_int_parse_unsigned_int_ignore_trailing (g, &str[42]);
     free (str);
     if (fs->major_version == -1)
       return -1;
@@ -384,7 +384,7 @@ check_w2k3_installer_root (guestfs_h *g, struct inspect_fs *fs,
   fs->type = OS_TYPE_WINDOWS;
   fs->distro = OS_DISTRO_WINDOWS;
 
-  r = guestfs___first_egrep_of_file (g, txtsetup,
+  r = guestfs_int_first_egrep_of_file (g, txtsetup,
                                      "^productname[[:space:]]*=[[:space:]]*\"", 1, &str);
   if (r == -1)
     return -1;
@@ -396,7 +396,7 @@ check_w2k3_installer_root (guestfs_h *g, struct inspect_fs *fs,
     free (str);
   }
 
-  r = guestfs___first_egrep_of_file (g, txtsetup,
+  r = guestfs_int_first_egrep_of_file (g, txtsetup,
                                      "^majorversion[[:space:]]*=[[:space:]]*[[:digit:]]+",
                                      1, &str);
   if (r == -1)
@@ -404,13 +404,13 @@ check_w2k3_installer_root (guestfs_h *g, struct inspect_fs *fs,
   if (r > 0) {
     trim_cr (str);
     v = find_value (str);
-    fs->major_version = guestfs___parse_unsigned_int_ignore_trailing (g, v);
+    fs->major_version = guestfs_int_parse_unsigned_int_ignore_trailing (g, v);
     free (str);
     if (fs->major_version == -1)
       return -1;
   }
 
-  r = guestfs___first_egrep_of_file (g, txtsetup,
+  r = guestfs_int_first_egrep_of_file (g, txtsetup,
                                      "^minorversion[[:space:]]*=[[:space:]]*[[:digit:]]+",
                                      1, &str);
   if (r == -1)
@@ -418,7 +418,7 @@ check_w2k3_installer_root (guestfs_h *g, struct inspect_fs *fs,
   if (r > 0) {
     trim_cr (str);
     v = find_value (str);
-    fs->minor_version = guestfs___parse_unsigned_int_ignore_trailing (g, v);
+    fs->minor_version = guestfs_int_parse_unsigned_int_ignore_trailing (g, v);
     free (str);
     if (fs->minor_version == -1)
       return -1;
@@ -428,7 +428,7 @@ check_w2k3_installer_root (guestfs_h *g, struct inspect_fs *fs,
    * installation by default, although not necessarily the one that
    * the user will finally choose.
    */
-  r = guestfs___first_egrep_of_file (g, txtsetup,
+  r = guestfs_int_first_egrep_of_file (g, txtsetup,
                                      "^defaultpath[[:space:]]*=[[:space:]]*",
                                      1, &str);
   if (r == -1)
@@ -445,7 +445,7 @@ check_w2k3_installer_root (guestfs_h *g, struct inspect_fs *fs,
 
 /* The currently mounted device is very likely to be an installer. */
 int
-guestfs___check_installer_root (guestfs_h *g, struct inspect_fs *fs)
+guestfs_int_check_installer_root (guestfs_h *g, struct inspect_fs *fs)
 {
   /* The presence of certain files indicates a live CD.
    *
@@ -515,7 +515,7 @@ guestfs___check_installer_root (guestfs_h *g, struct inspect_fs *fs)
  * directly to the operating system type.
  */
 int
-guestfs___check_installer_iso (guestfs_h *g, struct inspect_fs *fs,
+guestfs_int_check_installer_iso (guestfs_h *g, struct inspect_fs *fs,
                                const char *device)
 {
   CLEANUP_FREE_ISOINFO struct guestfs_isoinfo *isoinfo = NULL;
@@ -528,7 +528,7 @@ guestfs___check_installer_iso (guestfs_h *g, struct inspect_fs *fs,
   if (!isoinfo)
     return 0;
 
-  r = guestfs___osinfo_map (g, isoinfo, &osinfo);
+  r = guestfs_int_osinfo_map (g, isoinfo, &osinfo);
   if (r == -1)                  /* Fatal error. */
     return -1;
   if (r == 0)                   /* Could not locate any matching ISO. */
@@ -547,8 +547,8 @@ guestfs___check_installer_iso (guestfs_h *g, struct inspect_fs *fs,
   fs->arch = osinfo->arch ? safe_strdup (g, osinfo->arch) : NULL;
   fs->is_live_disk = osinfo->is_live_disk;
 
-  guestfs___check_package_format (g, fs);
-  guestfs___check_package_management (g, fs);
+  guestfs_int_check_package_format (g, fs);
+  guestfs_int_check_package_management (g, fs);
 
   return 1;
 }
diff --git a/src/inspect-fs-unix.c b/src/inspect-fs-unix.c
index 8778e92..8c032e9 100644
--- a/src/inspect-fs-unix.c
+++ b/src/inspect-fs-unix.c
@@ -216,7 +216,7 @@ static int
 parse_release_file (guestfs_h *g, struct inspect_fs *fs,
                     const char *release_filename)
 {
-  fs->product_name = guestfs___first_line_of_file (g, release_filename);
+  fs->product_name = guestfs_int_first_line_of_file (g, release_filename);
   if (fs->product_name == NULL)
     return -1;
   if (STREQ (fs->product_name, "")) {
@@ -300,13 +300,13 @@ parse_lsb_release (guestfs_h *g, struct inspect_fs *fs)
     else if (STRPREFIX (lines[i], "DISTRIB_RELEASE=")) {
       char *major, *minor;
       if (match2 (g, &lines[i][16], re_major_minor, &major, &minor)) {
-        fs->major_version = guestfs___parse_unsigned_int (g, major);
+        fs->major_version = guestfs_int_parse_unsigned_int (g, major);
         free (major);
         if (fs->major_version == -1) {
           free (minor);
           return -1;
         }
-        fs->minor_version = guestfs___parse_unsigned_int (g, minor);
+        fs->minor_version = guestfs_int_parse_unsigned_int (g, minor);
         free (minor);
         if (fs->minor_version == -1)
           return -1;
@@ -374,7 +374,7 @@ parse_suse_release (guestfs_h *g, struct inspect_fs *fs, const char *filename)
     major = match1 (g, lines[1], re_sles_version);
     if (major == NULL)
       goto out;
-    fs->major_version = guestfs___parse_unsigned_int (g, major);
+    fs->major_version = guestfs_int_parse_unsigned_int (g, major);
     free (major);
     if (fs->major_version == -1)
       goto out;
@@ -385,7 +385,7 @@ parse_suse_release (guestfs_h *g, struct inspect_fs *fs, const char *filename)
     minor = match1 (g, lines[2], re_sles_patchlevel);
     if (minor == NULL)
       goto out;
-    fs->minor_version = guestfs___parse_unsigned_int (g, minor);
+    fs->minor_version = guestfs_int_parse_unsigned_int (g, minor);
     free (minor);
     if (fs->minor_version == -1)
       goto out;
@@ -397,8 +397,8 @@ parse_suse_release (guestfs_h *g, struct inspect_fs *fs, const char *filename)
     if (lines[1] == NULL)
       goto out;
     if (match2 (g, lines[1], re_opensuse_version, &major, &minor)) {
-      fs->major_version = guestfs___parse_unsigned_int (g, major);
-      fs->minor_version = guestfs___parse_unsigned_int (g, minor);
+      fs->major_version = guestfs_int_parse_unsigned_int (g, major);
+      fs->minor_version = guestfs_int_parse_unsigned_int (g, minor);
       free (major);
       free (minor);
       if (fs->major_version == -1 || fs->minor_version == -1)
@@ -418,7 +418,7 @@ out:
  * associated devices.
  */
 int
-guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs)
+guestfs_int_check_linux_root (guestfs_h *g, struct inspect_fs *fs)
 {
   int r;
   char *major, *minor;
@@ -447,18 +447,18 @@ guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs)
 
     if (match2 (g, fs->product_name, re_oracle_linux_old, &major, &minor) ||
         match2 (g, fs->product_name, re_oracle_linux, &major, &minor)) {
-      fs->major_version = guestfs___parse_unsigned_int (g, major);
+      fs->major_version = guestfs_int_parse_unsigned_int (g, major);
       free (major);
       if (fs->major_version == -1) {
         free (minor);
         return -1;
       }
-      fs->minor_version = guestfs___parse_unsigned_int (g, minor);
+      fs->minor_version = guestfs_int_parse_unsigned_int (g, minor);
       free (minor);
       if (fs->minor_version == -1)
         return -1;
     } else if ((major = match1 (g, fs->product_name, re_oracle_linux_no_minor)) != NULL) {
-      fs->major_version = guestfs___parse_unsigned_int (g, major);
+      fs->major_version = guestfs_int_parse_unsigned_int (g, major);
       free (major);
       if (fs->major_version == -1)
         return -1;
@@ -474,7 +474,7 @@ guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs)
 
     if ((major = match1 (g, fs->product_name, re_fedora)) != NULL) {
       fs->distro = OS_DISTRO_FEDORA;
-      fs->major_version = guestfs___parse_unsigned_int (g, major);
+      fs->major_version = guestfs_int_parse_unsigned_int (g, major);
       free (major);
       if (fs->major_version == -1)
         return -1;
@@ -482,20 +482,20 @@ guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs)
     else if (match2 (g, fs->product_name, re_rhel_old, &major, &minor) ||
              match2 (g, fs->product_name, re_rhel, &major, &minor)) {
       fs->distro = OS_DISTRO_RHEL;
-      fs->major_version = guestfs___parse_unsigned_int (g, major);
+      fs->major_version = guestfs_int_parse_unsigned_int (g, major);
       free (major);
       if (fs->major_version == -1) {
         free (minor);
         return -1;
       }
-      fs->minor_version = guestfs___parse_unsigned_int (g, minor);
+      fs->minor_version = guestfs_int_parse_unsigned_int (g, minor);
       free (minor);
       if (fs->minor_version == -1)
         return -1;
     }
     else if ((major = match1 (g, fs->product_name, re_rhel_no_minor)) != NULL) {
       fs->distro = OS_DISTRO_RHEL;
-      fs->major_version = guestfs___parse_unsigned_int (g, major);
+      fs->major_version = guestfs_int_parse_unsigned_int (g, major);
       free (major);
       if (fs->major_version == -1)
         return -1;
@@ -504,20 +504,20 @@ guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs)
     else if (match2 (g, fs->product_name, re_centos_old, &major, &minor) ||
              match2 (g, fs->product_name, re_centos, &major, &minor)) {
       fs->distro = OS_DISTRO_CENTOS;
-      fs->major_version = guestfs___parse_unsigned_int (g, major);
+      fs->major_version = guestfs_int_parse_unsigned_int (g, major);
       free (major);
       if (fs->major_version == -1) {
         free (minor);
         return -1;
       }
-      fs->minor_version = guestfs___parse_unsigned_int (g, minor);
+      fs->minor_version = guestfs_int_parse_unsigned_int (g, minor);
       free (minor);
       if (fs->minor_version == -1)
         return -1;
     }
     else if ((major = match1 (g, fs->product_name, re_centos_no_minor)) != NULL) {
       fs->distro = OS_DISTRO_CENTOS;
-      fs->major_version = guestfs___parse_unsigned_int (g, major);
+      fs->major_version = guestfs_int_parse_unsigned_int (g, major);
       free (major);
       if (fs->major_version == -1)
         return -1;
@@ -526,20 +526,20 @@ guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs)
     else if (match2 (g, fs->product_name, re_scientific_linux_old, &major, &minor) ||
              match2 (g, fs->product_name, re_scientific_linux, &major, &minor)) {
       fs->distro = OS_DISTRO_SCIENTIFIC_LINUX;
-      fs->major_version = guestfs___parse_unsigned_int (g, major);
+      fs->major_version = guestfs_int_parse_unsigned_int (g, major);
       free (major);
       if (fs->major_version == -1) {
         free (minor);
         return -1;
       }
-      fs->minor_version = guestfs___parse_unsigned_int (g, minor);
+      fs->minor_version = guestfs_int_parse_unsigned_int (g, minor);
       free (minor);
       if (fs->minor_version == -1)
         return -1;
     }
     else if ((major = match1 (g, fs->product_name, re_scientific_linux_no_minor)) != NULL) {
       fs->distro = OS_DISTRO_SCIENTIFIC_LINUX;
-      fs->major_version = guestfs___parse_unsigned_int (g, major);
+      fs->major_version = guestfs_int_parse_unsigned_int (g, major);
       free (major);
       if (fs->major_version == -1)
         return -1;
@@ -553,7 +553,7 @@ guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs)
     if (parse_release_file (g, fs, "/etc/debian_version") == -1)
       return -1;
 
-    if (guestfs___parse_major_minor (g, fs) == -1)
+    if (guestfs_int_parse_major_minor (g, fs) == -1)
       return -1;
   }
   else if (guestfs_is_file_opts (g, "/etc/pardus-release",
@@ -563,7 +563,7 @@ guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs)
     if (parse_release_file (g, fs, "/etc/pardus-release") == -1)
       return -1;
 
-    if (guestfs___parse_major_minor (g, fs) == -1)
+    if (guestfs_int_parse_major_minor (g, fs) == -1)
       return -1;
   }
   else if (guestfs_is_file_opts (g, "/etc/arch-release",
@@ -581,7 +581,7 @@ guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs)
     if (parse_release_file (g, fs, "/etc/gentoo-release") == -1)
       return -1;
 
-    if (guestfs___parse_major_minor (g, fs) == -1)
+    if (guestfs_int_parse_major_minor (g, fs) == -1)
       return -1;
   }
   else if (guestfs_is_file_opts (g, "/etc/meego-release",
@@ -591,7 +591,7 @@ guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs)
     if (parse_release_file (g, fs, "/etc/meego-release") == -1)
       return -1;
 
-    if (guestfs___parse_major_minor (g, fs) == -1)
+    if (guestfs_int_parse_major_minor (g, fs) == -1)
       return -1;
   }
   else if (guestfs_is_file_opts (g, "/etc/slackware-version",
@@ -601,7 +601,7 @@ guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs)
     if (parse_release_file (g, fs, "/etc/slackware-version") == -1)
       return -1;
 
-    if (guestfs___parse_major_minor (g, fs) == -1)
+    if (guestfs_int_parse_major_minor (g, fs) == -1)
       return -1;
   }
   else if (guestfs_is_file_opts (g, "/etc/ttylinux-target",
@@ -611,7 +611,7 @@ guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs)
     if (parse_release_file (g, fs, "/etc/ttylinux-target") == -1)
       return -1;
 
-    if (guestfs___parse_major_minor (g, fs) == -1)
+    if (guestfs_int_parse_major_minor (g, fs) == -1)
       return -1;
   }
   else if (guestfs_is_file_opts (g, "/etc/SuSE-release",
@@ -631,7 +631,7 @@ guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs)
     if (parse_release_file (g, fs, "/etc/cirros/version") == -1)
       return -1;
 
-    if (guestfs___parse_major_minor (g, fs) == -1)
+    if (guestfs_int_parse_major_minor (g, fs) == -1)
       return -1;
   }
   /* Buildroot (http://buildroot.net) is an embedded Linux distro
@@ -649,7 +649,7 @@ guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs)
     if (parse_release_file (g, fs, "/etc/br-version") == -1)
       return -1;
 
-    if (guestfs___parse_major_minor (g, fs) == -1)
+    if (guestfs_int_parse_major_minor (g, fs) == -1)
       return -1;
   }
 
@@ -676,7 +676,7 @@ guestfs___check_linux_root (guestfs_h *g, struct inspect_fs *fs)
 
 /* The currently mounted device is known to be a FreeBSD root. */
 int
-guestfs___check_freebsd_root (guestfs_h *g, struct inspect_fs *fs)
+guestfs_int_check_freebsd_root (guestfs_h *g, struct inspect_fs *fs)
 {
   fs->type = OS_TYPE_FREEBSD;
 
@@ -690,7 +690,7 @@ guestfs___check_freebsd_root (guestfs_h *g, struct inspect_fs *fs)
     if (parse_release_file (g, fs, "/etc/motd") == -1)
       return -1;
 
-    if (guestfs___parse_major_minor (g, fs) == -1)
+    if (guestfs_int_parse_major_minor (g, fs) == -1)
       return -1;
   }
 
@@ -711,7 +711,7 @@ guestfs___check_freebsd_root (guestfs_h *g, struct inspect_fs *fs)
 
 /* The currently mounted device is maybe to be a *BSD root. */
 int
-guestfs___check_netbsd_root (guestfs_h *g, struct inspect_fs *fs)
+guestfs_int_check_netbsd_root (guestfs_h *g, struct inspect_fs *fs)
 {
 
   if (guestfs_is_file_opts (g, "/etc/release",
@@ -722,13 +722,13 @@ guestfs___check_netbsd_root (guestfs_h *g, struct inspect_fs *fs)
 
     if (match2 (g, fs->product_name, re_netbsd, &major, &minor)) {
       fs->type = OS_TYPE_NETBSD;
-      fs->major_version = guestfs___parse_unsigned_int (g, major);
+      fs->major_version = guestfs_int_parse_unsigned_int (g, major);
       free (major);
       if (fs->major_version == -1) {
         free (minor);
         return -1;
       }
-      fs->minor_version = guestfs___parse_unsigned_int (g, minor);
+      fs->minor_version = guestfs_int_parse_unsigned_int (g, minor);
       free (minor);
       if (fs->minor_version == -1)
         return -1;
@@ -756,7 +756,7 @@ guestfs___check_netbsd_root (guestfs_h *g, struct inspect_fs *fs)
  * just like Linux.
  */
 int
-guestfs___check_hurd_root (guestfs_h *g, struct inspect_fs *fs)
+guestfs_int_check_hurd_root (guestfs_h *g, struct inspect_fs *fs)
 {
   fs->type = OS_TYPE_HURD;
 
@@ -767,7 +767,7 @@ guestfs___check_hurd_root (guestfs_h *g, struct inspect_fs *fs)
     if (parse_release_file (g, fs, "/etc/debian_version") == -1)
       return -1;
 
-    if (guestfs___parse_major_minor (g, fs) == -1)
+    if (guestfs_int_parse_major_minor (g, fs) == -1)
       return -1;
   }
 
@@ -793,7 +793,7 @@ guestfs___check_hurd_root (guestfs_h *g, struct inspect_fs *fs)
 
 /* The currently mounted device is maybe to be a Minix root. */
 int
-guestfs___check_minix_root (guestfs_h *g, struct inspect_fs *fs)
+guestfs_int_check_minix_root (guestfs_h *g, struct inspect_fs *fs)
 {
   fs->type = OS_TYPE_MINIX;
 
@@ -804,13 +804,13 @@ guestfs___check_minix_root (guestfs_h *g, struct inspect_fs *fs)
       return -1;
 
     if (match2 (g, fs->product_name, re_minix, &major, &minor)) {
-      fs->major_version = guestfs___parse_unsigned_int (g, major);
+      fs->major_version = guestfs_int_parse_unsigned_int (g, major);
       free (major);
       if (fs->major_version == -1) {
         free (minor);
         return -1;
       }
-      fs->minor_version = guestfs___parse_unsigned_int (g, minor);
+      fs->minor_version = guestfs_int_parse_unsigned_int (g, minor);
       free (minor);
       if (fs->minor_version == -1)
         return -1;
@@ -850,7 +850,7 @@ check_architecture (guestfs_h *g, struct inspect_fs *fs)
 
       if (arch) {
         /* String will be owned by handle, freed by
-         * guestfs___free_inspect_info.
+         * guestfs_int_free_inspect_info.
          */
         fs->arch = arch;
         break;
@@ -876,7 +876,7 @@ check_hostname_unix (guestfs_h *g, struct inspect_fs *fs)
      * than try anything clever based on distro.
      */
     if (guestfs_is_file (g, "/etc/HOSTNAME")) {
-      fs->hostname = guestfs___first_line_of_file (g, "/etc/HOSTNAME");
+      fs->hostname = guestfs_int_first_line_of_file (g, "/etc/HOSTNAME");
       if (fs->hostname == NULL)
         return -1;
       if (STREQ (fs->hostname, "")) {
@@ -886,7 +886,7 @@ check_hostname_unix (guestfs_h *g, struct inspect_fs *fs)
     }
 
     if (!fs->hostname && guestfs_is_file (g, "/etc/hostname")) {
-      fs->hostname = guestfs___first_line_of_file (g, "/etc/hostname");
+      fs->hostname = guestfs_int_first_line_of_file (g, "/etc/hostname");
       if (fs->hostname == NULL)
         return -1;
       if (STREQ (fs->hostname, "")) {
@@ -916,7 +916,7 @@ check_hostname_unix (guestfs_h *g, struct inspect_fs *fs)
 
   case OS_TYPE_MINIX:
     if (guestfs_is_file (g, "/etc/hostname.file")) {
-      fs->hostname = guestfs___first_line_of_file (g, "/etc/hostname.file");
+      fs->hostname = guestfs_int_first_line_of_file (g, "/etc/hostname.file");
       if (fs->hostname == NULL)
         return -1;
       if (STREQ (fs->hostname, "")) {
@@ -952,7 +952,7 @@ check_hostname_redhat (guestfs_h *g, struct inspect_fs *fs)
   hostname = guestfs_aug_get (g, "/files/etc/sysconfig/network/HOSTNAME");
   guestfs_pop_error_handler (g);
 
-  /* This is freed by guestfs___free_inspect_info.  Note that hostname
+  /* This is freed by guestfs_int_free_inspect_info.  Note that hostname
    * could be NULL because we ignored errors above.
    */
   fs->hostname = hostname;
@@ -1145,7 +1145,7 @@ add_fstab_entry (guestfs_h *g, struct inspect_fs *fs,
   fs->fstab = p;
   fs->nr_fstab = n;
 
-  /* These are owned by the handle and freed by guestfs___free_inspect_info. */
+  /* These are owned by the handle and freed by guestfs_int_free_inspect_info. */
   fs->fstab[n-1].mountable = safe_strdup (g, mountable);
   fs->fstab[n-1].mountpoint = safe_strdup (g, mountpoint);
 
@@ -1435,7 +1435,7 @@ resolve_fstab_device_xdev (guestfs_h *g, const char *type, const char *disk,
   ITER_DRIVES (g, i, drv) {
     if (drv->name && STREQ (drv->name, name)) {
       device = safe_asprintf (g, "%s%s", devices[i], part);
-      if (!guestfs___is_partition (g, device)) {
+      if (!guestfs_int_is_partition (g, device)) {
         free (device);
         return 0;
       }
@@ -1462,7 +1462,7 @@ resolve_fstab_device_xdev (guestfs_h *g, const char *type, const char *disk,
      */
     if (i < count) {
       device = safe_asprintf (g, "%s%s", devices[i], part);
-      if (!guestfs___is_partition (g, device)) {
+      if (!guestfs_int_is_partition (g, device)) {
         free (device);
         return 0;
       }
@@ -1495,7 +1495,7 @@ resolve_fstab_device_cciss (guestfs_h *g, const char *disk, const char *part,
     if (drv->name && STREQ (drv->name, disk)) {
       if (part) {
         device = safe_asprintf (g, "%s%s", devices[i], part);
-        if (!guestfs___is_partition (g, device)) {
+        if (!guestfs_int_is_partition (g, device)) {
           free (device);
           return 0;
         }
@@ -1540,7 +1540,7 @@ resolve_fstab_device_diskbyid (guestfs_h *g, const char *part,
 
   /* Make the partition name and check it exists. */
   device = safe_asprintf (g, "/dev/sda%s", part);
-  if (!guestfs___is_partition (g, device)) {
+  if (!guestfs_int_is_partition (g, device)) {
     free (device);
     return 0;
   }
@@ -1605,8 +1605,8 @@ resolve_fstab_device (guestfs_h *g, const char *spec, Hash_table *md_map)
      * prefixed with vtbd. IDE hard drives used to be prefixed with ad and now
      * are with ada.
      */
-    int disk_i = guestfs___parse_unsigned_int (g, disk);
-    int part_i = guestfs___parse_unsigned_int (g, part);
+    int disk_i = guestfs_int_parse_unsigned_int (g, disk);
+    int part_i = guestfs_int_parse_unsigned_int (g, part);
     free (type);
     free (disk);
     free (part);
@@ -1621,8 +1621,8 @@ resolve_fstab_device (guestfs_h *g, const char *spec, Hash_table *md_map)
      * numbered from 5 in Linux.  I have no idea what happens when you
      * have multiple "slices" (the FreeBSD term for MBR partitions).
      */
-    int disk_i = guestfs___parse_unsigned_int (g, disk);
-    int slice_i = guestfs___parse_unsigned_int (g, slice);
+    int disk_i = guestfs_int_parse_unsigned_int (g, disk);
+    int slice_i = guestfs_int_parse_unsigned_int (g, slice);
     int part_i = part[0] - 'a' /* counting from 0 */;
     free (type);
     free (disk);
@@ -1647,7 +1647,7 @@ resolve_fstab_device (guestfs_h *g, const char *spec, Hash_table *md_map)
      * Turn the disk number into a letter-based identifier, so
      * we can resolve it easily.
      */
-    int disk_i = guestfs___parse_unsigned_int (g, disk);
+    int disk_i = guestfs_int_parse_unsigned_int (g, disk);
     const char disk_as_letter[2] = { disk_i + 'a', 0 };
     r = resolve_fstab_device_xdev (g, type, disk_as_letter, part, &device);
     free (type);
@@ -1734,7 +1734,7 @@ make_augeas_path_expression (guestfs_h *g, const char **configfiles)
   CLEANUP_FREE char *subexpr = NULL;
   char *ret;
 
-  nr_files = guestfs___count_strings ((char **) configfiles);
+  nr_files = guestfs_int_count_strings ((char **) configfiles);
   subexprs = safe_malloc (g, sizeof (char *) * (nr_files + 1));
 
   for (i = 0; i < nr_files; ++i) {
@@ -1744,7 +1744,7 @@ make_augeas_path_expression (guestfs_h *g, const char **configfiles)
   }
   subexprs[nr_files] = NULL;
 
-  subexpr = guestfs___join_strings (" and ", subexprs);
+  subexpr = guestfs_int_join_strings (" and ", subexprs);
   if (subexpr == NULL)
     g->abort_cb ();
 
diff --git a/src/inspect-fs-windows.c b/src/inspect-fs-windows.c
index 20e4d7f..80e60b4 100644
--- a/src/inspect-fs-windows.c
+++ b/src/inspect-fs-windows.c
@@ -114,22 +114,22 @@ is_systemroot (guestfs_h *const g, const char *systemroot)
   char path[256];
 
   snprintf (path, sizeof path, "%s/system32", systemroot);
-  if (!guestfs___is_dir_nocase (g, path))
+  if (!guestfs_int_is_dir_nocase (g, path))
     return 0;
 
   snprintf (path, sizeof path, "%s/system32/config", systemroot);
-  if (!guestfs___is_dir_nocase (g, path))
+  if (!guestfs_int_is_dir_nocase (g, path))
     return 0;
 
   snprintf (path, sizeof path, "%s/system32/cmd.exe", systemroot);
-  if (!guestfs___is_file_nocase (g, path))
+  if (!guestfs_int_is_file_nocase (g, path))
     return 0;
 
   return 1;
 }
 
 char *
-guestfs___get_windows_systemroot (guestfs_h *g)
+guestfs_int_get_windows_systemroot (guestfs_h *g)
 {
   /* Check a predefined list of common windows system root locations */
   static const char *systemroots[] =
@@ -137,7 +137,7 @@ guestfs___get_windows_systemroot (guestfs_h *g)
 
   for (size_t i = 0; i < sizeof systemroots / sizeof systemroots[0]; ++i) {
     char *systemroot =
-      guestfs___case_sensitive_path_silently (g, systemroots[i]);
+      guestfs_int_case_sensitive_path_silently (g, systemroots[i]);
     if (!systemroot)
       continue;
 
@@ -153,7 +153,7 @@ guestfs___get_windows_systemroot (guestfs_h *g)
   /* If the fs contains boot.ini, check it for non-standard
    * systemroot locations */
   CLEANUP_FREE char *boot_ini_path =
-    guestfs___case_sensitive_path_silently (g, "/boot.ini");
+    guestfs_int_case_sensitive_path_silently (g, "/boot.ini");
   if (boot_ini_path && guestfs_is_file (g, boot_ini_path) > 0) {
     CLEANUP_FREE_STRING_LIST char **boot_ini =
       guestfs_read_lines (g, boot_ini_path);
@@ -218,7 +218,7 @@ guestfs___get_windows_systemroot (guestfs_h *g)
           if (*j == '\\') *j = '/';
         }
 
-        char *systemroot = guestfs___case_sensitive_path_silently (g, path);
+        char *systemroot = guestfs_int_case_sensitive_path_silently (g, path);
         if (systemroot && is_systemroot (g, systemroot)) {
           debug (g, "windows %%SYSTEMROOT%% = %s", systemroot);
 
@@ -234,13 +234,13 @@ guestfs___get_windows_systemroot (guestfs_h *g)
 }
 
 int
-guestfs___check_windows_root (guestfs_h *g, struct inspect_fs *fs,
+guestfs_int_check_windows_root (guestfs_h *g, struct inspect_fs *fs,
                               char *const systemroot)
 {
   fs->type = OS_TYPE_WINDOWS;
   fs->distro = OS_DISTRO_WINDOWS;
 
-  /* Freed by guestfs___free_inspect_info. */
+  /* Freed by guestfs_int_free_inspect_info. */
   fs->windows_systemroot = systemroot;
 
   if (check_windows_arch (g, fs) == -1)
@@ -272,7 +272,7 @@ check_windows_arch (guestfs_h *g, struct inspect_fs *fs)
   char *arch = guestfs_file_architecture (g, cmd_exe_path);
 
   if (arch)
-    fs->arch = arch;        /* freed by guestfs___free_inspect_info */
+    fs->arch = arch;        /* freed by guestfs_int_free_inspect_info */
 
   return 0;
 }
@@ -346,13 +346,13 @@ check_windows_software_registry (guestfs_h *g, struct inspect_fs *fs)
         goto out;
       char *major, *minor;
       if (match2 (g, version, re_windows_version, &major, &minor)) {
-        fs->major_version = guestfs___parse_unsigned_int (g, major);
+        fs->major_version = guestfs_int_parse_unsigned_int (g, major);
         free (major);
         if (fs->major_version == -1) {
           free (minor);
           goto out;
         }
-        fs->minor_version = guestfs___parse_unsigned_int (g, minor);
+        fs->minor_version = guestfs_int_parse_unsigned_int (g, minor);
         free (minor);
         if (fs->minor_version == -1)
           goto out;
@@ -604,7 +604,7 @@ map_registry_disk_blob (guestfs_h *g, const void *blob)
  * You have to call guestfs_is_file{,_opts} etc.
  */
 char *
-guestfs___case_sensitive_path_silently (guestfs_h *g, const char *path)
+guestfs_int_case_sensitive_path_silently (guestfs_h *g, const char *path)
 {
   char *ret;
 
diff --git a/src/inspect-fs.c b/src/inspect-fs.c
index 686d1ae..799a321 100644
--- a/src/inspect-fs.c
+++ b/src/inspect-fs.c
@@ -89,7 +89,7 @@ static int get_partition_context (guestfs_h *g, const char *partition, int *part
  * another entry in g->fses.
  */
 int
-guestfs___check_for_filesystem_on (guestfs_h *g, const char *mountable)
+guestfs_int_check_for_filesystem_on (guestfs_h *g, const char *mountable)
 {
   CLEANUP_FREE char *vfs_type = NULL;
   int is_swap, r;
@@ -134,7 +134,7 @@ guestfs___check_for_filesystem_on (guestfs_h *g, const char *mountable)
       return -1;
     fs = &g->fses[g->nr_fses-1];
 
-    r = guestfs___check_installer_iso (g, fs, m->im_device);
+    r = guestfs_int_check_installer_iso (g, fs, m->im_device);
     if (r == -1) {              /* Fatal error. */
       g->nr_fses--;
       return -1;
@@ -184,7 +184,7 @@ check_filesystem (guestfs_h *g, const char *mountable,
     return -1;
 
   if (!whole_device && m->im_type == MOUNTABLE_DEVICE &&
-      guestfs___is_partition (g, m->im_device)) {
+      guestfs_int_is_partition (g, m->im_device)) {
     if (get_partition_context (g, m->im_device,
                                &partnum, &nr_partitions) == -1)
       return -1;
@@ -219,7 +219,7 @@ check_filesystem (guestfs_h *g, const char *mountable,
 
     fs->is_root = 1;
     fs->format = OS_FORMAT_INSTALLED;
-    if (guestfs___check_freebsd_root (g, fs) == -1)
+    if (guestfs_int_check_freebsd_root (g, fs) == -1)
       return -1;
   }
   else if (is_dir_etc &&
@@ -237,7 +237,7 @@ check_filesystem (guestfs_h *g, const char *mountable,
 
     fs->is_root = 1;
     fs->format = OS_FORMAT_INSTALLED;
-    if (guestfs___check_netbsd_root (g, fs) == -1)
+    if (guestfs_int_check_netbsd_root (g, fs) == -1)
       return -1;
   }
   /* Hurd root? */
@@ -246,7 +246,7 @@ check_filesystem (guestfs_h *g, const char *mountable,
            guestfs_is_file (g, "/hurd/null") > 0) {
     fs->is_root = 1;
     fs->format = OS_FORMAT_INSTALLED; /* XXX could be more specific */
-    if (guestfs___check_hurd_root (g, fs) == -1)
+    if (guestfs_int_check_hurd_root (g, fs) == -1)
       return -1;
   }
   /* Minix root? */
@@ -257,7 +257,7 @@ check_filesystem (guestfs_h *g, const char *mountable,
            guestfs_is_file (g, "/etc/version") > 0) {
     fs->is_root = 1;
     fs->format = OS_FORMAT_INSTALLED;
-    if (guestfs___check_minix_root (g, fs) == -1)
+    if (guestfs_int_check_minix_root (g, fs) == -1)
       return -1;
   }
   /* Linux root? */
@@ -268,7 +268,7 @@ check_filesystem (guestfs_h *g, const char *mountable,
            guestfs_is_file (g, "/etc/fstab") > 0) {
     fs->is_root = 1;
     fs->format = OS_FORMAT_INSTALLED;
-    if (guestfs___check_linux_root (g, fs) == -1)
+    if (guestfs_int_check_linux_root (g, fs) == -1)
       return -1;
   }
   /* Linux /usr/local? */
@@ -291,23 +291,23 @@ check_filesystem (guestfs_h *g, const char *mountable,
            guestfs_is_dir (g, "/spool") > 0)
     ;
   /* Windows root? */
-  else if ((windows_systemroot = guestfs___get_windows_systemroot (g)) != NULL)
+  else if ((windows_systemroot = guestfs_int_get_windows_systemroot (g)) != NULL)
   {
     fs->is_root = 1;
     fs->format = OS_FORMAT_INSTALLED;
-    if (guestfs___check_windows_root (g, fs, windows_systemroot) == -1)
+    if (guestfs_int_check_windows_root (g, fs, windows_systemroot) == -1)
       return -1;
   }
   /* Windows volume with installed applications (but not root)? */
-  else if (guestfs___is_dir_nocase (g, "/System Volume Information") > 0 &&
-           guestfs___is_dir_nocase (g, "/Program Files") > 0)
+  else if (guestfs_int_is_dir_nocase (g, "/System Volume Information") > 0 &&
+           guestfs_int_is_dir_nocase (g, "/Program Files") > 0)
     ;
   /* Windows volume (but not root)? */
-  else if (guestfs___is_dir_nocase (g, "/System Volume Information") > 0)
+  else if (guestfs_int_is_dir_nocase (g, "/System Volume Information") > 0)
     ;
   /* FreeDOS? */
-  else if (guestfs___is_dir_nocase (g, "/FDOS") > 0 &&
-           guestfs___is_file_nocase (g, "/FDOS/FREEDOS.BSS") > 0) {
+  else if (guestfs_int_is_dir_nocase (g, "/FDOS") > 0 &&
+           guestfs_int_is_file_nocase (g, "/FDOS/FREEDOS.BSS") > 0) {
     fs->is_root = 1;
     fs->format = OS_FORMAT_INSTALLED;
     fs->type = OS_TYPE_DOS;
@@ -338,15 +338,15 @@ check_filesystem (guestfs_h *g, const char *mountable,
             guestfs_is_file (g, "/boot/loader.rc") > 0)) {
     fs->is_root = 1;
     fs->format = OS_FORMAT_INSTALLER;
-    if (guestfs___check_installer_root (g, fs) == -1)
+    if (guestfs_int_check_installer_root (g, fs) == -1)
       return -1;
   }
 
   /* The above code should have set fs->type and fs->distro fields, so
    * we can now guess the package management system.
    */
-  guestfs___check_package_format (g, fs);
-  guestfs___check_package_management (g, fs);
+  guestfs_int_check_package_format (g, fs);
+  guestfs_int_check_package_management (g, fs);
 
   return 0;
 }
@@ -402,12 +402,12 @@ get_partition_context (guestfs_h *g, const char *partition,
 }
 
 int
-guestfs___is_file_nocase (guestfs_h *g, const char *path)
+guestfs_int_is_file_nocase (guestfs_h *g, const char *path)
 {
   CLEANUP_FREE char *p = NULL;
   int r;
 
-  p = guestfs___case_sensitive_path_silently (g, path);
+  p = guestfs_int_case_sensitive_path_silently (g, path);
   if (!p)
     return 0;
   r = guestfs_is_file (g, p);
@@ -415,12 +415,12 @@ guestfs___is_file_nocase (guestfs_h *g, const char *path)
 }
 
 int
-guestfs___is_dir_nocase (guestfs_h *g, const char *path)
+guestfs_int_is_dir_nocase (guestfs_h *g, const char *path)
 {
   CLEANUP_FREE char *p = NULL;
   int r;
 
-  p = guestfs___case_sensitive_path_silently (g, path);
+  p = guestfs_int_case_sensitive_path_silently (g, path);
   if (!p)
     return 0;
   r = guestfs_is_dir (g, p);
@@ -429,7 +429,7 @@ guestfs___is_dir_nocase (guestfs_h *g, const char *path)
 
 /* Parse small, unsigned ints, as used in version numbers. */
 int
-guestfs___parse_unsigned_int (guestfs_h *g, const char *str)
+guestfs_int_parse_unsigned_int (guestfs_h *g, const char *str)
 {
   long ret;
   int r = xstrtol (str, NULL, 10, &ret, "");
@@ -442,7 +442,7 @@ guestfs___parse_unsigned_int (guestfs_h *g, const char *str)
 
 /* Like parse_unsigned_int, but ignore trailing stuff. */
 int
-guestfs___parse_unsigned_int_ignore_trailing (guestfs_h *g, const char *str)
+guestfs_int_parse_unsigned_int_ignore_trailing (guestfs_h *g, const char *str)
 {
   long ret;
   int r = xstrtol (str, NULL, 10, &ret, NULL);
@@ -455,18 +455,18 @@ guestfs___parse_unsigned_int_ignore_trailing (guestfs_h *g, const char *str)
 
 /* Parse generic MAJOR.MINOR from the fs->product_name string. */
 int
-guestfs___parse_major_minor (guestfs_h *g, struct inspect_fs *fs)
+guestfs_int_parse_major_minor (guestfs_h *g, struct inspect_fs *fs)
 {
   char *major, *minor;
 
   if (match2 (g, fs->product_name, re_major_minor, &major, &minor)) {
-    fs->major_version = guestfs___parse_unsigned_int (g, major);
+    fs->major_version = guestfs_int_parse_unsigned_int (g, major);
     free (major);
     if (fs->major_version == -1) {
       free (minor);
       return -1;
     }
-    fs->minor_version = guestfs___parse_unsigned_int (g, minor);
+    fs->minor_version = guestfs_int_parse_unsigned_int (g, minor);
     free (minor);
     if (fs->minor_version == -1)
       return -1;
@@ -479,7 +479,7 @@ guestfs___parse_major_minor (guestfs_h *g, struct inspect_fs *fs)
  * can never return an error.  We might be cleverer in future.
  */
 void
-guestfs___check_package_format (guestfs_h *g, struct inspect_fs *fs)
+guestfs_int_check_package_format (guestfs_h *g, struct inspect_fs *fs)
 {
   switch (fs->distro) {
   case OS_DISTRO_FEDORA:
@@ -527,7 +527,7 @@ guestfs___check_package_format (guestfs_h *g, struct inspect_fs *fs)
 }
 
 void
-guestfs___check_package_management (guestfs_h *g, struct inspect_fs *fs)
+guestfs_int_check_package_management (guestfs_h *g, struct inspect_fs *fs)
 {
   switch (fs->distro) {
   case OS_DISTRO_FEDORA:
@@ -593,7 +593,7 @@ guestfs___check_package_management (guestfs_h *g, struct inspect_fs *fs)
  * will usually need to check for this case.
  */
 char *
-guestfs___first_line_of_file (guestfs_h *g, const char *filename)
+guestfs_int_first_line_of_file (guestfs_h *g, const char *filename)
 {
   char **lines = NULL; /* sic: not CLEANUP_FREE_STRING_LIST */
   int64_t size;
@@ -616,7 +616,7 @@ guestfs___first_line_of_file (guestfs_h *g, const char *filename)
   if (lines == NULL)
     return NULL;
   if (lines[0] == NULL) {
-    guestfs___free_string_list (lines);
+    guestfs_int_free_string_list (lines);
     /* Empty file: Return an empty string as explained above. */
     return safe_strdup (g, "");
   }
@@ -637,7 +637,7 @@ guestfs___first_line_of_file (guestfs_h *g, const char *filename)
  *          -1 = error
  */
 int
-guestfs___first_egrep_of_file (guestfs_h *g, const char *filename,
+guestfs_int_first_egrep_of_file (guestfs_h *g, const char *filename,
                                const char *eregex, int iflag, char **ret)
 {
   char **lines;
@@ -668,7 +668,7 @@ guestfs___first_egrep_of_file (guestfs_h *g, const char *filename,
   if (lines == NULL)
     return -1;
   if (lines[0] == NULL) {
-    guestfs___free_string_list (lines);
+    guestfs_int_free_string_list (lines);
     return 0;
   }
 
diff --git a/src/inspect-icon.c b/src/inspect-icon.c
index 72d4bba..866c80e 100644
--- a/src/inspect-icon.c
+++ b/src/inspect-icon.c
@@ -92,7 +92,7 @@ guestfs__inspect_get_icon (guestfs_h *g, const char *root, size_t *size_r,
   int favicon, highquality;
   size_t size;
 
-  fs = guestfs___search_for_root (g, root);
+  fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return NULL;
 
@@ -260,7 +260,7 @@ get_png (guestfs_h *g, struct inspect_fs *fs, const char *filename,
   if (max_size == 0)
     max_size = 4 * w * h;
 
-  local = guestfs___download_to_tmp (g, fs, real, "icon", max_size);
+  local = guestfs_int_download_to_tmp (g, fs, real, "icon", max_size);
   if (!local)
     return NOT_FOUND;
 
@@ -281,7 +281,7 @@ icon_favicon (guestfs_h *g, struct inspect_fs *fs, size_t *size_r)
   char *filename = safe_strdup (g, "/etc/favicon.png");
 
   if (fs->type == OS_TYPE_WINDOWS) {
-    char *f = guestfs___case_sensitive_path_silently (g, filename);
+    char *f = guestfs_int_case_sensitive_path_silently (g, filename);
     if (f) {
       free (filename);
       filename = f;
@@ -379,7 +379,7 @@ icon_cirros (guestfs_h *g, struct inspect_fs *fs, size_t *size_r)
   CLEANUP_FREE char *type = NULL;
   CLEANUP_FREE char *local = NULL;
   CLEANUP_FREE char *pngfile = NULL;
-  CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
   int r;
 
   r = guestfs_is_file_opts (g, CIRROS_LOGO,
@@ -397,18 +397,18 @@ icon_cirros (guestfs_h *g, struct inspect_fs *fs, size_t *size_r)
   if (!STRPREFIX (type, "ASCII text"))
     return NOT_FOUND;
 
-  local = guestfs___download_to_tmp (g, fs, CIRROS_LOGO, "icon", 1024);
+  local = guestfs_int_download_to_tmp (g, fs, CIRROS_LOGO, "icon", 1024);
   if (!local)
     return NOT_FOUND;
 
   /* Use pbmtext to render it. */
   pngfile = safe_asprintf (g, "%s/cirros.png", g->tmpdir);
 
-  guestfs___cmd_add_string_unquoted (cmd, PBMTEXT " < ");
-  guestfs___cmd_add_string_quoted   (cmd, local);
-  guestfs___cmd_add_string_unquoted (cmd, " | " PNMTOPNG " > ");
-  guestfs___cmd_add_string_quoted   (cmd, pngfile);
-  r = guestfs___cmd_run (cmd);
+  guestfs_int_cmd_add_string_unquoted (cmd, PBMTEXT " < ");
+  guestfs_int_cmd_add_string_quoted   (cmd, local);
+  guestfs_int_cmd_add_string_unquoted (cmd, " | " PNMTOPNG " > ");
+  guestfs_int_cmd_add_string_quoted   (cmd, pngfile);
+  r = guestfs_int_cmd_run (cmd);
   if (r == -1)
     return NOT_FOUND;
   if (!WIFEXITED (r) || WEXITSTATUS (r) != 0)
@@ -447,7 +447,7 @@ icon_windows_xp (guestfs_h *g, struct inspect_fs *fs, size_t *size_r)
   CLEANUP_FREE char *filename_case = NULL;
   CLEANUP_FREE char *filename_downloaded = NULL;
   CLEANUP_FREE char *pngfile = NULL;
-  CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
   int r;
   char *ret;
 
@@ -465,7 +465,7 @@ icon_windows_xp (guestfs_h *g, struct inspect_fs *fs, size_t *size_r)
   if (r == 0)
     return NOT_FOUND;
 
-  filename_downloaded = guestfs___download_to_tmp (g, fs, filename_case,
+  filename_downloaded = guestfs_int_download_to_tmp (g, fs, filename_case,
                                                    "explorer.exe",
                                                    MAX_WINDOWS_EXPLORER_SIZE);
   if (filename_downloaded == NULL)
@@ -473,12 +473,12 @@ icon_windows_xp (guestfs_h *g, struct inspect_fs *fs, size_t *size_r)
 
   pngfile = safe_asprintf (g, "%s/windows-xp-icon.png", g->tmpdir);
 
-  guestfs___cmd_add_string_unquoted (cmd, WRESTOOL " -x --type=2 --name=143 ");
-  guestfs___cmd_add_string_quoted   (cmd, filename_downloaded);
-  guestfs___cmd_add_string_unquoted (cmd,
+  guestfs_int_cmd_add_string_unquoted (cmd, WRESTOOL " -x --type=2 --name=143 ");
+  guestfs_int_cmd_add_string_quoted   (cmd, filename_downloaded);
+  guestfs_int_cmd_add_string_unquoted (cmd,
                                      " | " BMPTOPNM " | " PNMTOPNG " > ");
-  guestfs___cmd_add_string_quoted   (cmd, pngfile);
-  r = guestfs___cmd_run (cmd);
+  guestfs_int_cmd_add_string_quoted   (cmd, pngfile);
+  r = guestfs_int_cmd_run (cmd);
   if (r == -1)
     return NULL;
   if (!WIFEXITED (r) || WEXITSTATUS (r) != 0)
@@ -497,7 +497,7 @@ icon_windows_7 (guestfs_h *g, struct inspect_fs *fs, size_t *size_r)
   CLEANUP_FREE char *filename_case = NULL;
   CLEANUP_FREE char *filename_downloaded = NULL;
   CLEANUP_FREE char *pngfile = NULL;
-  CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
   int r;
   char *ret;
 
@@ -515,7 +515,7 @@ icon_windows_7 (guestfs_h *g, struct inspect_fs *fs, size_t *size_r)
   if (r == 0)
     return NOT_FOUND;
 
-  filename_downloaded = guestfs___download_to_tmp (g, fs, filename_case,
+  filename_downloaded = guestfs_int_download_to_tmp (g, fs, filename_case,
                                                    "explorer.exe",
                                                    MAX_WINDOWS_EXPLORER_SIZE);
   if (filename_downloaded == NULL)
@@ -523,14 +523,14 @@ icon_windows_7 (guestfs_h *g, struct inspect_fs *fs, size_t *size_r)
 
   pngfile = safe_asprintf (g, "%s/windows-7-icon.png", g->tmpdir);
 
-  guestfs___cmd_add_string_unquoted (cmd, WRESTOOL " -x --type=2 --name=6801 ");
-  guestfs___cmd_add_string_quoted   (cmd, filename_downloaded);
-  guestfs___cmd_add_string_unquoted (cmd,
+  guestfs_int_cmd_add_string_unquoted (cmd, WRESTOOL " -x --type=2 --name=6801 ");
+  guestfs_int_cmd_add_string_quoted   (cmd, filename_downloaded);
+  guestfs_int_cmd_add_string_unquoted (cmd,
                                      " | " BMPTOPNM " | "
                                      PAMCUT " -bottom 54 | "
                                      PNMTOPNG " > ");
-  guestfs___cmd_add_string_quoted   (cmd, pngfile);
-  r = guestfs___cmd_run (cmd);
+  guestfs_int_cmd_add_string_quoted   (cmd, pngfile);
+  r = guestfs_int_cmd_run (cmd);
   if (r == -1)
     return NULL;
   if (!WIFEXITED (r) || WEXITSTATUS (r) != 0)
@@ -555,7 +555,7 @@ icon_windows_8 (guestfs_h *g, struct inspect_fs *fs, size_t *size_r)
   int r;
   char *ret;
 
-  filename_case = guestfs___case_sensitive_path_silently
+  filename_case = guestfs_int_case_sensitive_path_silently
     (g, "/ProgramData/Microsoft/Windows Live/WLive48x48.png");
   if (filename_case == NULL)
     return NOT_FOUND; /* Not an error since a parent dir might not exist. */
@@ -568,7 +568,7 @@ icon_windows_8 (guestfs_h *g, struct inspect_fs *fs, size_t *size_r)
   if (r == 0)
     return NOT_FOUND;
 
-  filename_downloaded = guestfs___download_to_tmp (g, fs, filename_case,
+  filename_downloaded = guestfs_int_download_to_tmp (g, fs, filename_case,
                                                    "wlive48x48.png", 8192);
   if (filename_downloaded == NULL)
     return NOT_FOUND;
diff --git a/src/inspect.c b/src/inspect.c
index 03d870f..311175d 100644
--- a/src/inspect.c
+++ b/src/inspect.c
@@ -45,7 +45,7 @@ guestfs__inspect_os (guestfs_h *g)
   char **fs, **ret;
 
   /* Remove any information previously stored in the handle. */
-  guestfs___free_inspect_info (g);
+  guestfs_int_free_inspect_info (g);
 
   if (guestfs_umount_all (g) == -1)
     return NULL;
@@ -58,8 +58,8 @@ guestfs__inspect_os (guestfs_h *g)
   if (fses == NULL) return NULL;
 
   for (fs = fses; *fs; fs += 2) {
-    if (guestfs___check_for_filesystem_on (g, *fs)) {
-      guestfs___free_inspect_info (g);
+    if (guestfs_int_check_for_filesystem_on (g, *fs)) {
+      guestfs_int_free_inspect_info (g);
       return NULL;
     }
   }
@@ -71,7 +71,7 @@ guestfs__inspect_os (guestfs_h *g)
    */
   ret = guestfs_inspect_get_roots (g);
   if (ret == NULL)
-    guestfs___free_inspect_info (g);
+    guestfs_int_free_inspect_info (g);
   return ret;
 }
 
@@ -95,9 +95,9 @@ guestfs__inspect_get_roots (guestfs_h *g)
    */
   for (i = 0; i < g->nr_fses; ++i) {
     if (g->fses[i].is_root)
-      guestfs___add_string (g, &ret, g->fses[i].mountable);
+      guestfs_int_add_string (g, &ret, g->fses[i].mountable);
   }
-  guestfs___end_stringsbuf (g, &ret);
+  guestfs_int_end_stringsbuf (g, &ret);
 
   qsort (ret.argv, ret.size-1, sizeof (char *), compare_strings);
 
@@ -107,7 +107,7 @@ guestfs__inspect_get_roots (guestfs_h *g)
 char *
 guestfs__inspect_get_type (guestfs_h *g, const char *root)
 {
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   char *ret = NULL;
 
   if (!fs)
@@ -134,7 +134,7 @@ guestfs__inspect_get_type (guestfs_h *g, const char *root)
 char *
 guestfs__inspect_get_arch (guestfs_h *g, const char *root)
 {
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return NULL;
 
@@ -144,7 +144,7 @@ guestfs__inspect_get_arch (guestfs_h *g, const char *root)
 char *
 guestfs__inspect_get_distro (guestfs_h *g, const char *root)
 {
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   char *ret = NULL;
 
   if (!fs)
@@ -188,7 +188,7 @@ guestfs__inspect_get_distro (guestfs_h *g, const char *root)
 int
 guestfs__inspect_get_major_version (guestfs_h *g, const char *root)
 {
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return -1;
 
@@ -198,7 +198,7 @@ guestfs__inspect_get_major_version (guestfs_h *g, const char *root)
 int
 guestfs__inspect_get_minor_version (guestfs_h *g, const char *root)
 {
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return -1;
 
@@ -208,7 +208,7 @@ guestfs__inspect_get_minor_version (guestfs_h *g, const char *root)
 char *
 guestfs__inspect_get_product_name (guestfs_h *g, const char *root)
 {
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return NULL;
 
@@ -218,7 +218,7 @@ guestfs__inspect_get_product_name (guestfs_h *g, const char *root)
 char *
 guestfs__inspect_get_product_variant (guestfs_h *g, const char *root)
 {
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return NULL;
 
@@ -228,7 +228,7 @@ guestfs__inspect_get_product_variant (guestfs_h *g, const char *root)
 char *
 guestfs__inspect_get_windows_systemroot (guestfs_h *g, const char *root)
 {
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return NULL;
 
@@ -244,7 +244,7 @@ char *
 guestfs__inspect_get_windows_current_control_set (guestfs_h *g,
                                                   const char *root)
 {
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return NULL;
 
@@ -260,7 +260,7 @@ char *
 guestfs__inspect_get_format (guestfs_h *g, const char *root)
 {
   char *ret = NULL;
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return NULL;
 
@@ -279,7 +279,7 @@ guestfs__inspect_get_format (guestfs_h *g, const char *root)
 int
 guestfs__inspect_is_live (guestfs_h *g, const char *root)
 {
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return -1;
 
@@ -289,7 +289,7 @@ guestfs__inspect_is_live (guestfs_h *g, const char *root)
 int
 guestfs__inspect_is_netinst (guestfs_h *g, const char *root)
 {
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return -1;
 
@@ -299,7 +299,7 @@ guestfs__inspect_is_netinst (guestfs_h *g, const char *root)
 int
 guestfs__inspect_is_multipart (guestfs_h *g, const char *root)
 {
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return -1;
 
@@ -313,7 +313,7 @@ guestfs__inspect_get_mountpoints (guestfs_h *g, const char *root)
   size_t i, count, nr;
   struct inspect_fs *fs;
 
-  fs = guestfs___search_for_root (g, root);
+  fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return NULL;
 
@@ -362,7 +362,7 @@ guestfs__inspect_get_filesystems (guestfs_h *g, const char *root)
 {
   char **ret;
   size_t i, nr;
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
 
   if (!fs)
     return NULL;
@@ -394,16 +394,16 @@ guestfs__inspect_get_drive_mappings (guestfs_h *g, const char *root)
   size_t i;
   struct inspect_fs *fs;
 
-  fs = guestfs___search_for_root (g, root);
+  fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return NULL;
 
   if (fs->drive_mappings) {
     for (i = 0; fs->drive_mappings[i] != NULL; ++i)
-      guestfs___add_string (g, &ret, fs->drive_mappings[i]);
+      guestfs_int_add_string (g, &ret, fs->drive_mappings[i]);
   }
 
-  guestfs___end_stringsbuf (g, &ret);
+  guestfs_int_end_stringsbuf (g, &ret);
   return ret.argv;
 }
 
@@ -411,7 +411,7 @@ char *
 guestfs__inspect_get_package_format (guestfs_h *g, const char *root)
 {
   char *ret = NULL;
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return NULL;
 
@@ -437,7 +437,7 @@ char *
 guestfs__inspect_get_package_management (guestfs_h *g, const char *root)
 {
   char *ret = NULL;
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return NULL;
 
@@ -464,7 +464,7 @@ guestfs__inspect_get_package_management (guestfs_h *g, const char *root)
 char *
 guestfs__inspect_get_hostname (guestfs_h *g, const char *root)
 {
-  struct inspect_fs *fs = guestfs___search_for_root (g, root);
+  struct inspect_fs *fs = guestfs_int_search_for_root (g, root);
   if (!fs)
     return NULL;
 
@@ -472,7 +472,7 @@ guestfs__inspect_get_hostname (guestfs_h *g, const char *root)
 }
 
 void
-guestfs___free_inspect_info (guestfs_h *g)
+guestfs_int_free_inspect_info (guestfs_h *g)
 {
   size_t i, j;
 
@@ -490,7 +490,7 @@ guestfs___free_inspect_info (guestfs_h *g)
     }
     free (g->fses[i].fstab);
     if (g->fses[i].drive_mappings)
-      guestfs___free_string_list (g->fses[i].drive_mappings);
+      guestfs_int_free_string_list (g->fses[i].drive_mappings);
   }
   free (g->fses);
   g->nr_fses = 0;
@@ -511,7 +511,7 @@ guestfs___free_inspect_info (guestfs_h *g)
  * to handle the case of multiple roots.
  */
 char *
-guestfs___download_to_tmp (guestfs_h *g, struct inspect_fs *fs,
+guestfs_int_download_to_tmp (guestfs_h *g, struct inspect_fs *fs,
                            const char *filename,
                            const char *basename, uint64_t max_size)
 {
@@ -571,7 +571,7 @@ guestfs___download_to_tmp (guestfs_h *g, struct inspect_fs *fs,
 }
 
 struct inspect_fs *
-guestfs___search_for_root (guestfs_h *g, const char *root)
+guestfs_int_search_for_root (guestfs_h *g, const char *root)
 {
   size_t i;
 
@@ -592,7 +592,7 @@ guestfs___search_for_root (guestfs_h *g, const char *root)
 }
 
 int
-guestfs___is_partition (guestfs_h *g, const char *partition)
+guestfs_int_is_partition (guestfs_h *g, const char *partition)
 {
   CLEANUP_FREE char *device = NULL;
 
diff --git a/src/journal.c b/src/journal.c
index 61ab352..d2e7269 100644
--- a/src/journal.c
+++ b/src/journal.c
@@ -60,7 +60,7 @@ guestfs__journal_get (guestfs_h *g)
   size_t i, j, size;
   uint64_t len;
 
-  if (guestfs___lazy_make_tmpdir (g) == -1)
+  if (guestfs_int_lazy_make_tmpdir (g) == -1)
     goto err;
 
   tmpfile = safe_asprintf (g, "%s/journal%d", g->tmpdir, ++g->unique);
diff --git a/src/launch-direct.c b/src/launch-direct.c
index 2834967..fa3bb7a 100644
--- a/src/launch-direct.c
+++ b/src/launch-direct.c
@@ -111,11 +111,11 @@ create_cow_overlay_direct (guestfs_h *g, void *datav, struct drive *drv)
   CLEANUP_FREE char *backing_drive = NULL;
   struct guestfs_disk_create_argv optargs;
 
-  backing_drive = guestfs___drive_source_qemu_param (g, &drv->src);
+  backing_drive = guestfs_int_drive_source_qemu_param (g, &drv->src);
   if (!backing_drive)
     return NULL;
 
-  if (guestfs___lazy_make_tmpdir (g) == -1)
+  if (guestfs_int_lazy_make_tmpdir (g) == -1)
     return NULL;
 
   overlay = safe_asprintf (g, "%s/overlay%d", g->tmpdir, ++g->unique);
@@ -188,7 +188,7 @@ add_cmdline_shell_unquoted (guestfs_h *g, struct stringsbuf *sb,
     while (*nextp && *nextp == ' ')
       nextp++;
 
-    guestfs___add_string_nodup (g, sb,
+    guestfs_int_add_string_nodup (g, sb,
                                 safe_strndup (g, startp, endp-startp));
 
     options = nextp;
@@ -298,28 +298,28 @@ launch_direct (guestfs_h *g, void *datav, const char *arg)
    */
   has_kvm = is_openable (g, "/dev/kvm", O_RDWR|O_CLOEXEC);
 
-  force_tcg = guestfs___get_backend_setting_bool (g, "force_tcg");
+  force_tcg = guestfs_int_get_backend_setting_bool (g, "force_tcg");
   if (force_tcg == -1)
     return -1;
 
   if (!has_kvm && !force_tcg)
     debian_kvm_warning (g);
 
-  guestfs___launch_send_progress (g, 0);
+  guestfs_int_launch_send_progress (g, 0);
 
   TRACE0 (launch_build_appliance_start);
 
   /* Locate and/or build the appliance. */
-  if (guestfs___build_appliance (g, &kernel, &dtb, &initrd, &appliance) == -1)
+  if (guestfs_int_build_appliance (g, &kernel, &dtb, &initrd, &appliance) == -1)
     return -1;
   has_appliance_drive = appliance != NULL;
 
   TRACE0 (launch_build_appliance_end);
 
-  guestfs___launch_send_progress (g, 3);
+  guestfs_int_launch_send_progress (g, 3);
 
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "begin testing qemu features");
+    guestfs_int_print_timestamped_message (g, "begin testing qemu features");
 
   /* Get qemu help text and version. */
   if (qemu_supports (g, data, NULL) == -1)
@@ -359,18 +359,18 @@ launch_direct (guestfs_h *g, void *datav, const char *arg)
   }
 
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "finished testing qemu features");
+    guestfs_int_print_timestamped_message (g, "finished testing qemu features");
 
   /* Construct the qemu command line.  We have to do this before
    * forking, because after fork we are not allowed to use
    * non-signal-safe functions such as malloc.
    */
 #define ADD_CMDLINE(str) \
-  guestfs___add_string (g, &cmdline, (str))
+  guestfs_int_add_string (g, &cmdline, (str))
 #define ADD_CMDLINE_STRING_NODUP(str) \
-  guestfs___add_string_nodup (g, &cmdline, (str))
+  guestfs_int_add_string_nodup (g, &cmdline, (str))
 #define ADD_CMDLINE_PRINTF(fs,...) \
-  guestfs___add_sprintf (g, &cmdline, (fs), ##__VA_ARGS__)
+  guestfs_int_add_sprintf (g, &cmdline, (fs), ##__VA_ARGS__)
 
   ADD_CMDLINE (g->hv);
 
@@ -414,13 +414,13 @@ launch_direct (guestfs_h *g, void *datav, const char *arg)
 #endif
 
   /* See guestfs.pod / gdb */
-  if (guestfs___get_backend_setting_bool (g, "gdb") > 0) {
+  if (guestfs_int_get_backend_setting_bool (g, "gdb") > 0) {
     ADD_CMDLINE ("-S");
     ADD_CMDLINE ("-s");
     warning (g, "qemu debugging is enabled, connect gdb to tcp::1234 to begin");
   }
 
-  cpu_model = guestfs___get_cpu_model (has_kvm && !force_tcg);
+  cpu_model = guestfs_int_get_cpu_model (has_kvm && !force_tcg);
   if (cpu_model) {
     ADD_CMDLINE ("-cpu");
     ADD_CMDLINE (cpu_model);
@@ -476,7 +476,7 @@ launch_direct (guestfs_h *g, void *datav, const char *arg)
   }
 
   /* UEFI (firmware) if required. */
-  if (guestfs___get_uefi (g, &uefi_code, &uefi_vars) == -1)
+  if (guestfs_int_get_uefi (g, &uefi_code, &uefi_vars) == -1)
     goto cleanup0;
   if (uefi_code) {
     ADD_CMDLINE ("-drive");
@@ -522,7 +522,7 @@ launch_direct (guestfs_h *g, void *datav, const char *arg)
          */
         break;
       case discard_enable:
-        if (!guestfs___discard_possible (g, drv, qemu_version))
+        if (!guestfs_int_discard_possible (g, drv, qemu_version))
           goto cleanup0;
         /*FALLTHROUGH*/
       case discard_besteffort:
@@ -535,7 +535,7 @@ launch_direct (guestfs_h *g, void *datav, const char *arg)
       }
 
       /* Make the file= parameter. */
-      file = guestfs___drive_source_qemu_param (g, &drv->src);
+      file = guestfs_int_drive_source_qemu_param (g, &drv->src);
       escaped_file = qemu_escape_param (g, file);
 
       /* Make the first part of the -drive parameter, everything up to
@@ -660,7 +660,7 @@ launch_direct (guestfs_h *g, void *datav, const char *arg)
   flags = 0;
   if (!has_kvm || force_tcg)
     flags |= APPLIANCE_COMMAND_LINE_IS_TCG;
-  ADD_CMDLINE_STRING_NODUP (guestfs___appliance_command_line (g, appliance_dev,
+  ADD_CMDLINE_STRING_NODUP (guestfs_int_appliance_command_line (g, appliance_dev,
                                                               flags));
 
   /* Note: custom command line parameters must come last so that
@@ -683,7 +683,7 @@ launch_direct (guestfs_h *g, void *datav, const char *arg)
   }
 
   /* Finish off the command line. */
-  guestfs___end_stringsbuf (g, &cmdline);
+  guestfs_int_end_stringsbuf (g, &cmdline);
 
   r = fork ();
   if (r == -1) {
@@ -835,7 +835,7 @@ launch_direct (guestfs_h *g, void *datav, const char *arg)
    * virtio-serial and send the GUESTFS_LAUNCH_FLAG message.
    */
   g->conn =
-    guestfs___new_conn_socket_listening (g, daemon_accept_sock, console_sock);
+    guestfs_int_new_conn_socket_listening (g, daemon_accept_sock, console_sock);
   if (!g->conn)
     goto cleanup1;
 
@@ -846,7 +846,7 @@ launch_direct (guestfs_h *g, void *datav, const char *arg)
   if (r == -1)
     goto cleanup1;
   if (r == 0) {
-    guestfs___launch_failed_error (g);
+    guestfs_int_launch_failed_error (g);
     goto cleanup1;
   }
 
@@ -857,20 +857,20 @@ launch_direct (guestfs_h *g, void *datav, const char *arg)
    * able to open a drive.
    */
 
-  r = guestfs___recv_from_daemon (g, &size, &buf);
+  r = guestfs_int_recv_from_daemon (g, &size, &buf);
 
   if (r == -1) {
-    guestfs___launch_failed_error (g);
+    guestfs_int_launch_failed_error (g);
     goto cleanup1;
   }
 
   if (size != GUESTFS_LAUNCH_FLAG) {
-    guestfs___launch_failed_error (g);
+    guestfs_int_launch_failed_error (g);
     goto cleanup1;
   }
 
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "appliance is up");
+    guestfs_int_print_timestamped_message (g, "appliance is up");
 
   /* This is possible in some really strange situations, such as
    * guestfsd starts up OK but then qemu immediately exits.  Check for
@@ -884,10 +884,10 @@ launch_direct (guestfs_h *g, void *datav, const char *arg)
 
   TRACE0 (launch_end);
 
-  guestfs___launch_send_progress (g, 12);
+  guestfs_int_launch_send_progress (g, 12);
 
   if (has_appliance_drive)
-    guestfs___add_dummy_appliance_drive (g);
+    guestfs_int_add_dummy_appliance_drive (g);
 
   return 0;
 
@@ -944,7 +944,7 @@ make_appliance_dev (guestfs_h *g, int virtio_scsi)
   }
 
   dev[5] = virtio_scsi ? 's' : 'v';
-  guestfs___drive_name (index, &dev[7]);
+  guestfs_int_drive_name (index, &dev[7]);
 
   return safe_strdup (g, dev);  /* Caller frees. */
 }
@@ -962,7 +962,7 @@ print_qemu_command_line (guestfs_h *g, char **argv)
   struct timeval tv;
   gettimeofday (&tv, NULL);
   fprintf (stderr, "[%05" PRIi64 "ms] ",
-           guestfs___timeval_diff (&g->launch_t, &tv));
+           guestfs_int_timeval_diff (&g->launch_t, &tv));
 
   while (argv[i]) {
     if (argv[i][0] == '-') /* -option starts a new line */
@@ -992,9 +992,9 @@ static void read_all (guestfs_h *g, void *retv, const char *buf, size_t len);
 static int
 test_qemu (guestfs_h *g, struct backend_direct_data *data)
 {
-  CLEANUP_CMD_CLOSE struct command *cmd1 = guestfs___new_command (g);
-  CLEANUP_CMD_CLOSE struct command *cmd2 = guestfs___new_command (g);
-  CLEANUP_CMD_CLOSE struct command *cmd3 = guestfs___new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd1 = guestfs_int_new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd2 = guestfs_int_new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd3 = guestfs_int_new_command (g);
   int r;
 
   free (data->qemu_help);
@@ -1004,44 +1004,44 @@ test_qemu (guestfs_h *g, struct backend_direct_data *data)
   free (data->qemu_devices);
   data->qemu_devices = NULL;
 
-  guestfs___cmd_add_arg (cmd1, g->hv);
-  guestfs___cmd_add_arg (cmd1, "-display");
-  guestfs___cmd_add_arg (cmd1, "none");
-  guestfs___cmd_add_arg (cmd1, "-help");
-  guestfs___cmd_set_stdout_callback (cmd1, read_all, &data->qemu_help,
+  guestfs_int_cmd_add_arg (cmd1, g->hv);
+  guestfs_int_cmd_add_arg (cmd1, "-display");
+  guestfs_int_cmd_add_arg (cmd1, "none");
+  guestfs_int_cmd_add_arg (cmd1, "-help");
+  guestfs_int_cmd_set_stdout_callback (cmd1, read_all, &data->qemu_help,
                                      CMD_STDOUT_FLAG_WHOLE_BUFFER);
-  r = guestfs___cmd_run (cmd1);
+  r = guestfs_int_cmd_run (cmd1);
   if (r == -1 || !WIFEXITED (r) || WEXITSTATUS (r) != 0)
     goto error;
 
-  guestfs___cmd_add_arg (cmd2, g->hv);
-  guestfs___cmd_add_arg (cmd2, "-display");
-  guestfs___cmd_add_arg (cmd2, "none");
-  guestfs___cmd_add_arg (cmd2, "-version");
-  guestfs___cmd_set_stdout_callback (cmd2, read_all, &data->qemu_version,
+  guestfs_int_cmd_add_arg (cmd2, g->hv);
+  guestfs_int_cmd_add_arg (cmd2, "-display");
+  guestfs_int_cmd_add_arg (cmd2, "none");
+  guestfs_int_cmd_add_arg (cmd2, "-version");
+  guestfs_int_cmd_set_stdout_callback (cmd2, read_all, &data->qemu_version,
                                      CMD_STDOUT_FLAG_WHOLE_BUFFER);
-  r = guestfs___cmd_run (cmd2);
+  r = guestfs_int_cmd_run (cmd2);
   if (r == -1 || !WIFEXITED (r) || WEXITSTATUS (r) != 0)
     goto error;
 
   parse_qemu_version (g, data);
 
-  guestfs___cmd_add_arg (cmd3, g->hv);
-  guestfs___cmd_add_arg (cmd3, "-display");
-  guestfs___cmd_add_arg (cmd3, "none");
+  guestfs_int_cmd_add_arg (cmd3, g->hv);
+  guestfs_int_cmd_add_arg (cmd3, "-display");
+  guestfs_int_cmd_add_arg (cmd3, "none");
 #ifdef MACHINE_TYPE
-  guestfs___cmd_add_arg (cmd3, "-M");
-  guestfs___cmd_add_arg (cmd3, MACHINE_TYPE);
+  guestfs_int_cmd_add_arg (cmd3, "-M");
+  guestfs_int_cmd_add_arg (cmd3, MACHINE_TYPE);
 #endif
-  guestfs___cmd_add_arg (cmd3, "-machine");
-  guestfs___cmd_add_arg (cmd3, "accel=kvm:tcg");
-  guestfs___cmd_add_arg (cmd3, "-device");
-  guestfs___cmd_add_arg (cmd3, "?");
-  guestfs___cmd_clear_capture_errors (cmd3);
-  guestfs___cmd_set_stderr_to_stdout (cmd3);
-  guestfs___cmd_set_stdout_callback (cmd3, read_all, &data->qemu_devices,
+  guestfs_int_cmd_add_arg (cmd3, "-machine");
+  guestfs_int_cmd_add_arg (cmd3, "accel=kvm:tcg");
+  guestfs_int_cmd_add_arg (cmd3, "-device");
+  guestfs_int_cmd_add_arg (cmd3, "?");
+  guestfs_int_cmd_clear_capture_errors (cmd3);
+  guestfs_int_cmd_set_stderr_to_stdout (cmd3);
+  guestfs_int_cmd_set_stdout_callback (cmd3, read_all, &data->qemu_devices,
                                      CMD_STDOUT_FLAG_WHOLE_BUFFER);
-  r = guestfs___cmd_run (cmd3);
+  r = guestfs_int_cmd_run (cmd3);
   if (r == -1 || !WIFEXITED (r) || WEXITSTATUS (r) != 0)
     goto error;
 
@@ -1051,7 +1051,7 @@ test_qemu (guestfs_h *g, struct backend_direct_data *data)
   if (r == -1)
     return -1;
 
-  guestfs___external_command_failed (g, r, g->hv, NULL);
+  guestfs_int_external_command_failed (g, r, g->hv, NULL);
   return -1;
 }
 
@@ -1077,11 +1077,11 @@ parse_qemu_version (guestfs_h *g, struct backend_direct_data *data)
     return;
   }
 
-  major_i = guestfs___parse_unsigned_int (g, major_s);
+  major_i = guestfs_int_parse_unsigned_int (g, major_s);
   if (major_i == -1)
     goto parse_failed;
 
-  minor_i = guestfs___parse_unsigned_int (g, minor_s);
+  minor_i = guestfs_int_parse_unsigned_int (g, minor_s);
   if (minor_i == -1)
     goto parse_failed;
 
@@ -1265,7 +1265,7 @@ make_uri (guestfs_h *g, const char *scheme, const char *user,
  * part of a full -drive parameter (but not for qemu-img).
  */
 char *
-guestfs___drive_source_qemu_param (guestfs_h *g, const struct drive_source *src)
+guestfs_int_drive_source_qemu_param (guestfs_h *g, const struct drive_source *src)
 {
   char *path;
 
@@ -1424,7 +1424,7 @@ guestfs___drive_source_qemu_param (guestfs_h *g, const struct drive_source *src)
  * major * 1,000,000 + minor * 1,000 + release
  */
 bool
-guestfs___discard_possible (guestfs_h *g, struct drive *drv,
+guestfs_int_discard_possible (guestfs_h *g, struct drive *drv,
                             unsigned long qemu_version)
 {
   /* qemu >= 1.5.  This was the first version that supported the
@@ -1495,7 +1495,7 @@ guestfs___discard_possible (guestfs_h *g, struct drive *drv,
     NOT_SUPPORTED (g, -1,
                    _("discard cannot be enabled on this drive: "
                      "protocol '%s' does not support discard"),
-                   guestfs___drive_protocol_to_string (drv->src.protocol));
+                   guestfs_int_drive_protocol_to_string (drv->src.protocol));
   }
 
   return true;
@@ -1522,7 +1522,7 @@ shutdown_direct (guestfs_h *g, void *datav, int check_for_errors)
       ret = -1;
     }
     else if (!WIFEXITED (status) || WEXITSTATUS (status) != 0) {
-      guestfs___external_command_failed (g, status, g->hv, NULL);
+      guestfs_int_external_command_failed (g, status, g->hv, NULL);
       ret = -1;
     }
   }
@@ -1578,5 +1578,5 @@ static void init_backend (void) __attribute__((constructor));
 static void
 init_backend (void)
 {
-  guestfs___register_backend ("direct", &backend_direct_ops);
+  guestfs_int_register_backend ("direct", &backend_direct_ops);
 }
diff --git a/src/launch-libvirt.c b/src/launch-libvirt.c
index 5daa396..c2ae144 100644
--- a/src/launch-libvirt.c
+++ b/src/launch-libvirt.c
@@ -179,7 +179,7 @@ make_qcow2_overlay (guestfs_h *g, const char *backing_drive,
   char *overlay;
   struct guestfs_disk_create_argv optargs;
 
-  if (guestfs___lazy_make_tmpdir (g) == -1)
+  if (guestfs_int_lazy_make_tmpdir (g) == -1)
     return NULL;
 
   overlay = safe_asprintf (g, "%s/overlay%d", g->tmpdir, ++g->unique);
@@ -208,7 +208,7 @@ create_cow_overlay_libvirt (guestfs_h *g, void *datav, struct drive *drv)
   CLEANUP_FREE char *backing_drive = NULL;
   char *overlay;
 
-  backing_drive = guestfs___drive_source_qemu_param (g, &drv->src);
+  backing_drive = guestfs_int_drive_source_qemu_param (g, &drv->src);
   if (!backing_drive)
     return NULL;
 
@@ -276,21 +276,21 @@ launch_libvirt (guestfs_h *g, void *datav, const char *libvirt_uri)
     return -1;
   }
 
-  guestfs___launch_send_progress (g, 0);
+  guestfs_int_launch_send_progress (g, 0);
   TRACE0 (launch_libvirt_start);
 
   /* Create a random name for the guest. */
   memcpy (data->name, "guestfs-", 8);
   const size_t random_name_len =
     DOMAIN_NAME_LEN - 8 /* "guestfs-" */ - 1 /* \0 */;
-  if (guestfs___random_string (&data->name[8], random_name_len) == -1) {
-    perrorf (g, "guestfs___random_string");
+  if (guestfs_int_random_string (&data->name[8], random_name_len) == -1) {
+    perrorf (g, "guestfs_int_random_string");
     return -1;
   }
   debug (g, "guest random name = %s", data->name);
 
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "connect to libvirt");
+    guestfs_int_print_timestamped_message (g, "connect to libvirt");
 
   /* Decode the URI string. */
   if (!libvirt_uri) {           /* "libvirt" */
@@ -303,7 +303,7 @@ launch_libvirt (guestfs_h *g, void *datav, const char *libvirt_uri)
   } /* else nothing */
 
   /* Connect to libvirt, get capabilities. */
-  conn = guestfs___open_libvirt_connection (g, libvirt_uri, 0);
+  conn = guestfs_int_open_libvirt_connection (g, libvirt_uri, 0);
   if (!conn) {
     libvirt_error (g, _("could not connect to libvirt (URI = %s)"),
            libvirt_uri ? : "NULL");
@@ -330,7 +330,7 @@ launch_libvirt (guestfs_h *g, void *datav, const char *libvirt_uri)
   }
 
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "get libvirt capabilities");
+    guestfs_int_print_timestamped_message (g, "get libvirt capabilities");
 
   capabilities_xml = virConnectGetCapabilities (conn);
   if (!capabilities_xml) {
@@ -343,13 +343,13 @@ launch_libvirt (guestfs_h *g, void *datav, const char *libvirt_uri)
    * run qemu guests (RHBZ#886915).
    */
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "parsing capabilities XML");
+    guestfs_int_print_timestamped_message (g, "parsing capabilities XML");
 
   if (parse_capabilities (g, capabilities_xml, data) == -1)
     goto cleanup;
 
   /* UEFI code and variables, on architectures where that is required. */
-  if (guestfs___get_uefi (g, &data->uefi_code, &data->uefi_vars) == -1)
+  if (guestfs_int_get_uefi (g, &data->uefi_code, &data->uefi_vars) == -1)
     goto cleanup;
 
   /* Misc backend settings. */
@@ -359,20 +359,20 @@ launch_libvirt (guestfs_h *g, void *datav, const char *libvirt_uri)
   data->selinux_imagelabel =
     guestfs_get_backend_setting (g, "internal_libvirt_imagelabel");
   data->selinux_norelabel_disks =
-    guestfs___get_backend_setting_bool (g, "internal_libvirt_norelabel_disks");
+    guestfs_int_get_backend_setting_bool (g, "internal_libvirt_norelabel_disks");
   guestfs_pop_error_handler (g);
 
   /* Locate and/or build the appliance. */
   TRACE0 (launch_build_libvirt_appliance_start);
 
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "build appliance");
+    guestfs_int_print_timestamped_message (g, "build appliance");
 
-  if (guestfs___build_appliance (g, &params.kernel, &params.dtb,
+  if (guestfs_int_build_appliance (g, &params.kernel, &params.dtb,
 				 &params.initrd, &appliance) == -1)
     goto cleanup;
 
-  guestfs___launch_send_progress (g, 3);
+  guestfs_int_launch_send_progress (g, 3);
   TRACE0 (launch_build_libvirt_appliance_end);
 
   /* Note that appliance can be NULL if using the old-style appliance. */
@@ -495,11 +495,11 @@ launch_libvirt (guestfs_h *g, void *datav, const char *libvirt_uri)
 
   /* Construct the libvirt XML. */
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "create libvirt XML");
+    guestfs_int_print_timestamped_message (g, "create libvirt XML");
 
   params.appliance_index = g->nr_drives;
   strcpy (params.appliance_dev, "/dev/sd");
-  guestfs___drive_name (params.appliance_index, &params.appliance_dev[7]);
+  guestfs_int_drive_name (params.appliance_index, &params.appliance_dev[7]);
   params.enable_svirt = ! is_custom_hv (g);
 
   xml = construct_libvirt_xml (g, &params);
@@ -514,7 +514,7 @@ launch_libvirt (guestfs_h *g, void *datav, const char *libvirt_uri)
 
   /* Launch the libvirt guest. */
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "launch libvirt guest");
+    guestfs_int_print_timestamped_message (g, "launch libvirt guest");
 
   dom = virDomainCreateXML (conn, (char *) xml, VIR_DOMAIN_START_AUTODESTROY);
   if (!dom) {
@@ -548,7 +548,7 @@ launch_libvirt (guestfs_h *g, void *datav, const char *libvirt_uri)
    * virtio-serial and send the GUESTFS_LAUNCH_FLAG message.
    */
   g->conn =
-    guestfs___new_conn_socket_listening (g, daemon_accept_sock, console_sock);
+    guestfs_int_new_conn_socket_listening (g, daemon_accept_sock, console_sock);
   if (!g->conn)
     goto cleanup;
 
@@ -559,7 +559,7 @@ launch_libvirt (guestfs_h *g, void *datav, const char *libvirt_uri)
   if (r == -1)
     goto cleanup;
   if (r == 0) {
-    guestfs___launch_failed_error (g);
+    guestfs_int_launch_failed_error (g);
     goto cleanup;
   }
 
@@ -570,20 +570,20 @@ launch_libvirt (guestfs_h *g, void *datav, const char *libvirt_uri)
    * able to open a drive.
    */
 
-  r = guestfs___recv_from_daemon (g, &size, &buf);
+  r = guestfs_int_recv_from_daemon (g, &size, &buf);
 
   if (r == -1) {
-    guestfs___launch_failed_error (g);
+    guestfs_int_launch_failed_error (g);
     goto cleanup;
   }
 
   if (size != GUESTFS_LAUNCH_FLAG) {
-    guestfs___launch_failed_error (g);
+    guestfs_int_launch_failed_error (g);
     goto cleanup;
   }
 
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "appliance is up");
+    guestfs_int_print_timestamped_message (g, "appliance is up");
 
   /* This is possible in some really strange situations, such as
    * guestfsd starts up OK but then qemu immediately exits.  Check for
@@ -596,11 +596,11 @@ launch_libvirt (guestfs_h *g, void *datav, const char *libvirt_uri)
   }
 
   if (appliance)
-    guestfs___add_dummy_appliance_drive (g);
+    guestfs_int_add_dummy_appliance_drive (g);
 
   TRACE0 (launch_libvirt_end);
 
-  guestfs___launch_send_progress (g, 12);
+  guestfs_int_launch_send_progress (g, 12);
 
   data->conn = conn;
   data->dom = dom;
@@ -720,7 +720,7 @@ parse_capabilities (guestfs_h *g, const char *capabilities_xml,
     return -1;
   }
 
-  force_tcg = guestfs___get_backend_setting_bool (g, "force_tcg");
+  force_tcg = guestfs_int_get_backend_setting_bool (g, "force_tcg");
   if (force_tcg == -1)
     return -1;
 
@@ -819,34 +819,34 @@ debug_permissions_cb (guestfs_h *g, void *data, const char *line, size_t len)
 static void
 debug_appliance_permissions (guestfs_h *g)
 {
-  CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
   CLEANUP_FREE char *cachedir = guestfs_get_cachedir (g);
   CLEANUP_FREE char *appliance = NULL;
 
   appliance = safe_asprintf (g, "%s/.guestfs-%d", cachedir, geteuid ());
 
-  guestfs___cmd_add_arg (cmd, "ls");
-  guestfs___cmd_add_arg (cmd, "-a");
-  guestfs___cmd_add_arg (cmd, "-l");
-  guestfs___cmd_add_arg (cmd, "-Z");
-  guestfs___cmd_add_arg (cmd, appliance);
-  guestfs___cmd_set_stdout_callback (cmd, debug_permissions_cb, NULL, 0);
-  guestfs___cmd_run (cmd);
+  guestfs_int_cmd_add_arg (cmd, "ls");
+  guestfs_int_cmd_add_arg (cmd, "-a");
+  guestfs_int_cmd_add_arg (cmd, "-l");
+  guestfs_int_cmd_add_arg (cmd, "-Z");
+  guestfs_int_cmd_add_arg (cmd, appliance);
+  guestfs_int_cmd_set_stdout_callback (cmd, debug_permissions_cb, NULL, 0);
+  guestfs_int_cmd_run (cmd);
 }
 
 static void
 debug_socket_permissions (guestfs_h *g)
 {
   if (g->tmpdir) {
-    CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+    CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
 
-    guestfs___cmd_add_arg (cmd, "ls");
-    guestfs___cmd_add_arg (cmd, "-a");
-    guestfs___cmd_add_arg (cmd, "-l");
-    guestfs___cmd_add_arg (cmd, "-Z");
-    guestfs___cmd_add_arg (cmd, g->tmpdir);
-    guestfs___cmd_set_stdout_callback (cmd, debug_permissions_cb, NULL, 0);
-    guestfs___cmd_run (cmd);
+    guestfs_int_cmd_add_arg (cmd, "ls");
+    guestfs_int_cmd_add_arg (cmd, "-a");
+    guestfs_int_cmd_add_arg (cmd, "-l");
+    guestfs_int_cmd_add_arg (cmd, "-Z");
+    guestfs_int_cmd_add_arg (cmd, g->tmpdir);
+    guestfs_int_cmd_set_stdout_callback (cmd, debug_permissions_cb, NULL, 0);
+    guestfs_int_cmd_run (cmd);
   }
 }
 
@@ -1055,7 +1055,7 @@ construct_libvirt_xml_cpu (guestfs_h *g,
     string_format ("%d", g->memsize);
   } end_element ();
 
-  cpu_model = guestfs___get_cpu_model (params->data->is_kvm);
+  cpu_model = guestfs_int_get_cpu_model (params->data->is_kvm);
   if (cpu_model) {
     start_element ("cpu") {
       if (STREQ (cpu_model, "host")) {
@@ -1125,7 +1125,7 @@ construct_libvirt_xml_boot (guestfs_h *g,
   flags = 0;
   if (!params->data->is_kvm)
     flags |= APPLIANCE_COMMAND_LINE_IS_TCG;
-  cmdline = guestfs___appliance_command_line (g, params->appliance_dev, flags);
+  cmdline = guestfs_int_appliance_command_line (g, params->appliance_dev, flags);
 
   start_element ("os") {
     start_element ("type") {
@@ -1511,7 +1511,7 @@ construct_libvirt_xml_disk_target (guestfs_h *g, xmlTextWriterPtr xo,
 {
   char drive_name[64] = "sd";
 
-  guestfs___drive_name (drv_index, &drive_name[2]);
+  guestfs_int_drive_name (drv_index, &drive_name[2]);
 
   start_element ("target") {
     attribute ("dev", drive_name);
@@ -1545,7 +1545,7 @@ construct_libvirt_xml_disk_driver_qemu (guestfs_h *g,
      */
     break;
   case discard_enable:
-    if (!guestfs___discard_possible (g, drv, data->qemu_version))
+    if (!guestfs_int_discard_possible (g, drv, data->qemu_version))
       return -1;
     /*FALLTHROUGH*/
   case discard_besteffort:
@@ -1724,7 +1724,7 @@ construct_libvirt_xml_qemu_cmdline (guestfs_h *g,
     /* This is a temporary hack until RHBZ#1184411 is resolved.
      * See comments above about cpu model and aarch64.
      */
-    const char *cpu_model = guestfs___get_cpu_model (params->data->is_kvm);
+    const char *cpu_model = guestfs_int_get_cpu_model (params->data->is_kvm);
     if (STRNEQ (cpu_model, "host")) {
       start_element ("qemu:arg") {
         attribute ("value", "-cpu");
@@ -2236,7 +2236,7 @@ static void init_backend (void) __attribute__((constructor));
 static void
 init_backend (void)
 {
-  guestfs___register_backend ("libvirt", &backend_libvirt_ops);
+  guestfs_int_register_backend ("libvirt", &backend_libvirt_ops);
 }
 
 #endif
diff --git a/src/launch-uml.c b/src/launch-uml.c
index 8643ea8..6c13cf4 100644
--- a/src/launch-uml.c
+++ b/src/launch-uml.c
@@ -55,25 +55,25 @@ static void print_vmlinux_command_line (guestfs_h *g, char **argv);
 static char *
 make_cow_overlay (guestfs_h *g, const char *original)
 {
-  CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
   char *overlay;
   int r;
 
-  if (guestfs___lazy_make_tmpdir (g) == -1)
+  if (guestfs_int_lazy_make_tmpdir (g) == -1)
     return NULL;
 
   overlay = safe_asprintf (g, "%s/overlay%d", g->tmpdir, g->unique++);
 
-  guestfs___cmd_add_arg (cmd, "uml_mkcow");
-  guestfs___cmd_add_arg (cmd, overlay);
-  guestfs___cmd_add_arg (cmd, original);
-  r = guestfs___cmd_run (cmd);
+  guestfs_int_cmd_add_arg (cmd, "uml_mkcow");
+  guestfs_int_cmd_add_arg (cmd, overlay);
+  guestfs_int_cmd_add_arg (cmd, original);
+  r = guestfs_int_cmd_run (cmd);
   if (r == -1) {
     free (overlay);
     return NULL;
   }
   if (!WIFEXITED (r) || WEXITSTATUS (r) != 0) {
-    guestfs___external_command_failed (g, r, "uml_mkcow", original);
+    guestfs_int_external_command_failed (g, r, "uml_mkcow", original);
     free (overlay);
     return NULL;
   }
@@ -171,13 +171,13 @@ launch_uml (guestfs_h *g, void *datav, const char *arg)
   }
 
   /* Assign a random unique ID to this run. */
-  if (guestfs___random_string (data->umid, UML_UMID_LEN) == -1) {
-    perrorf (g, "guestfs___random_string");
+  if (guestfs_int_random_string (data->umid, UML_UMID_LEN) == -1) {
+    perrorf (g, "guestfs_int_random_string");
     return -1;
   }
 
   /* Locate and/or build the appliance. */
-  if (guestfs___build_appliance (g, &kernel, &dtb, &initrd, &appliance) == -1)
+  if (guestfs_int_build_appliance (g, &kernel, &dtb, &initrd, &appliance) == -1)
     return -1;
   has_appliance_drive = appliance != NULL;
 
@@ -213,9 +213,9 @@ launch_uml (guestfs_h *g, void *datav, const char *arg)
    * non-signal-safe functions such as malloc.
    */
 #define ADD_CMDLINE(str) \
-  guestfs___add_string (g, &cmdline, (str))
+  guestfs_int_add_string (g, &cmdline, (str))
 #define ADD_CMDLINE_PRINTF(fs,...) \
-  guestfs___add_sprintf (g, &cmdline, (fs), ##__VA_ARGS__)
+  guestfs_int_add_sprintf (g, &cmdline, (fs), ##__VA_ARGS__)
 
   ADD_CMDLINE (g->hv);
 
@@ -239,7 +239,7 @@ launch_uml (guestfs_h *g, void *datav, const char *arg)
    */
   ADD_CMDLINE ("rw");
 
-  /* See also guestfs___appliance_command_line. */
+  /* See also guestfs_int_appliance_command_line. */
   if (g->verbose)
     ADD_CMDLINE ("guestfs_verbose=1");
 
@@ -267,7 +267,7 @@ launch_uml (guestfs_h *g, void *datav, const char *arg)
   /* Add the ext2 appliance drive (after all the drives). */
   if (has_appliance_drive) {
     char drv_name[64] = "ubd";
-    guestfs___drive_name (g->nr_drives, &drv_name[3]);
+    guestfs_int_drive_name (g->nr_drives, &drv_name[3]);
 
     ADD_CMDLINE_PRINTF ("ubd%zu=%s", g->nr_drives, appliance_cow);
     ADD_CMDLINE_PRINTF ("root=/dev/%s", drv_name);
@@ -296,7 +296,7 @@ launch_uml (guestfs_h *g, void *datav, const char *arg)
     }
 
   /* Finish off the command line. */
-  guestfs___end_stringsbuf (g, &cmdline);
+  guestfs_int_end_stringsbuf (g, &cmdline);
 
   r = fork ();
   if (r == -1) {
@@ -449,7 +449,7 @@ launch_uml (guestfs_h *g, void *datav, const char *arg)
    * virtio-serial and send the GUESTFS_LAUNCH_FLAG message.
    */
   g->conn =
-    guestfs___new_conn_socket_connected (g, daemon_sock, console_sock);
+    guestfs_int_new_conn_socket_connected (g, daemon_sock, console_sock);
   if (!g->conn)
     goto cleanup1;
 
@@ -459,20 +459,20 @@ launch_uml (guestfs_h *g, void *datav, const char *arg)
   /* We now have to wait for vmlinux to start up, the daemon to start
    * running, and for it to send the GUESTFS_LAUNCH_FLAG to us.
    */
-  r = guestfs___recv_from_daemon (g, &size, &buf);
+  r = guestfs_int_recv_from_daemon (g, &size, &buf);
 
   if (r == -1) {
-    guestfs___launch_failed_error (g);
+    guestfs_int_launch_failed_error (g);
     goto cleanup1;
   }
 
   if (size != GUESTFS_LAUNCH_FLAG) {
-    guestfs___launch_failed_error (g);
+    guestfs_int_launch_failed_error (g);
     goto cleanup1;
   }
 
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "appliance is up");
+    guestfs_int_print_timestamped_message (g, "appliance is up");
 
   /* This is possible in some really strange situations, such as
    * guestfsd starts up OK but then vmlinux immediately exits.  Check
@@ -485,7 +485,7 @@ launch_uml (guestfs_h *g, void *datav, const char *arg)
   }
 
   if (has_appliance_drive)
-    guestfs___add_dummy_appliance_drive (g);
+    guestfs_int_add_dummy_appliance_drive (g);
 
   return 0;
 
@@ -530,7 +530,7 @@ print_vmlinux_command_line (guestfs_h *g, char **argv)
   struct timeval tv;
   gettimeofday (&tv, NULL);
   fprintf (stderr, "[%05" PRIi64 "ms] ",
-           guestfs___timeval_diff (&g->launch_t, &tv));
+           guestfs_int_timeval_diff (&g->launch_t, &tv));
 
   while (argv[i]) {
     if (i > 0) fputc (' ', stderr);
@@ -577,7 +577,7 @@ shutdown_uml (guestfs_h *g, void *datav, int check_for_errors)
     else if (!(WIFSIGNALED (status) && WTERMSIG (status) == SIGTERM) &&
              !(WIFEXITED (status) && WEXITSTATUS (status) == 0) &&
              !(WIFEXITED (status) && WEXITSTATUS (status) == 1)) {
-      guestfs___external_command_failed (g, status, g->hv, NULL);
+      guestfs_int_external_command_failed (g, status, g->hv, NULL);
       ret = -1;
     }
   }
@@ -626,5 +626,5 @@ static void init_backend (void) __attribute__((constructor));
 static void
 init_backend (void)
 {
-  guestfs___register_backend ("uml", &backend_uml_ops);
+  guestfs_int_register_backend ("uml", &backend_uml_ops);
 }
diff --git a/src/launch-unix.c b/src/launch-unix.c
index 7956bed..c5a4d84 100644
--- a/src/launch-unix.c
+++ b/src/launch-unix.c
@@ -54,7 +54,7 @@ launch_unix (guestfs_h *g, void *datav, const char *sockpath)
   }
 
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "connecting to %s", sockpath);
+    guestfs_int_print_timestamped_message (g, "connecting to %s", sockpath);
 
   daemon_sock = socket (AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0);
   if (daemon_sock == -1) {
@@ -73,14 +73,14 @@ launch_unix (guestfs_h *g, void *datav, const char *sockpath)
     goto cleanup;
   }
 
-  g->conn = guestfs___new_conn_socket_connected (g, daemon_sock, -1);
+  g->conn = guestfs_int_new_conn_socket_connected (g, daemon_sock, -1);
   if (!g->conn)
     goto cleanup;
 
   /* g->conn now owns this socket. */
   daemon_sock = -1;
 
-  r = guestfs___recv_from_daemon (g, &size, &buf);
+  r = guestfs_int_recv_from_daemon (g, &size, &buf);
   free (buf);
 
   if (r == -1) goto cleanup;
@@ -91,7 +91,7 @@ launch_unix (guestfs_h *g, void *datav, const char *sockpath)
   }
 
   if (g->verbose)
-    guestfs___print_timestamped_message (g, "connected");
+    guestfs_int_print_timestamped_message (g, "connected");
 
   if (g->state != READY) {
     error (g, _("contacted guestfsd, but state != READY"));
@@ -130,5 +130,5 @@ static void init_backend (void) __attribute__((constructor));
 static void
 init_backend (void)
 {
-  guestfs___register_backend ("unix", &backend_unix_ops);
+  guestfs_int_register_backend ("unix", &backend_unix_ops);
 }
diff --git a/src/launch.c b/src/launch.c
index 9fadce8..18736e6 100644
--- a/src/launch.c
+++ b/src/launch.c
@@ -59,7 +59,7 @@ guestfs__launch (guestfs_h *g)
   TRACE0 (launch_start);
 
   /* Make the temporary directory. */
-  if (guestfs___lazy_make_tmpdir (g) == -1)
+  if (guestfs_int_lazy_make_tmpdir (g) == -1)
     return -1;
 
   /* Allow anyone to read the temporary directory.  The socket in this
@@ -113,16 +113,16 @@ guestfs__launch (guestfs_h *g)
  * (3) There is a hack in proto.c to make this work.
  */
 void
-guestfs___launch_send_progress (guestfs_h *g, int perdozen)
+guestfs_int_launch_send_progress (guestfs_h *g, int perdozen)
 {
   struct timeval tv;
 
   gettimeofday (&tv, NULL);
-  if (guestfs___timeval_diff (&g->launch_t, &tv) >= 5000) {
+  if (guestfs_int_timeval_diff (&g->launch_t, &tv) >= 5000) {
     guestfs_progress progress_message =
       { .proc = 0, .serial = 0, .position = perdozen, .total = 12 };
 
-    guestfs___progress_message_callback (g, &progress_message);
+    guestfs_int_progress_message_callback (g, &progress_message);
   }
 }
 
@@ -130,7 +130,7 @@ guestfs___launch_send_progress (guestfs_h *g, int perdozen)
  * from the parent process.
  */
 void
-guestfs___print_timestamped_message (guestfs_h *g, const char *fs, ...)
+guestfs_int_print_timestamped_message (guestfs_h *g, const char *fs, ...)
 {
   va_list args;
   char *msg;
@@ -146,7 +146,7 @@ guestfs___print_timestamped_message (guestfs_h *g, const char *fs, ...)
   gettimeofday (&tv, NULL);
 
   debug (g, "[%05" PRIi64 "ms] %s",
-         guestfs___timeval_diff (&g->launch_t, &tv), msg);
+         guestfs_int_timeval_diff (&g->launch_t, &tv), msg);
 
   free (msg);
 }
@@ -156,7 +156,7 @@ guestfs___print_timestamped_message (guestfs_h *g, const char *fs, ...)
  * http://www.mpp.mpg.de/~huber/util/timevaldiff.c
  */
 int64_t
-guestfs___timeval_diff (const struct timeval *x, const struct timeval *y)
+guestfs_int_timeval_diff (const struct timeval *x, const struct timeval *y)
 {
   int64_t msec;
 
@@ -311,7 +311,7 @@ guestfs__config (guestfs_h *g,
 #endif
 
 char *
-guestfs___appliance_command_line (guestfs_h *g, const char *appliance_dev,
+guestfs_int_appliance_command_line (guestfs_h *g, const char *appliance_dev,
                                   int flags)
 {
   char root[64] = "";
@@ -324,7 +324,7 @@ guestfs___appliance_command_line (guestfs_h *g, const char *appliance_dev,
     snprintf (root, sizeof root, " root=%s", appliance_dev);
 
   if (tcg) {
-    int lpj = guestfs___get_lpj (g);
+    int lpj = guestfs_int_get_lpj (g);
     if (lpj > 0)
       snprintf (lpj_s, sizeof lpj_s, " lpj=%d", lpj);
   }
@@ -397,7 +397,7 @@ guestfs___appliance_command_line (guestfs_h *g, const char *appliance_dev,
  * is semi-broken in any way.
  */
 const char *
-guestfs___get_cpu_model (int kvm)
+guestfs_int_get_cpu_model (int kvm)
 {
 #if defined(__arm__)            /* 32 bit ARM. */
   return NULL;
@@ -462,7 +462,7 @@ get_umask (guestfs_h *g)
 
 /* Register backends in a global list when the library is loaded. */
 void
-guestfs___register_backend (const char *name, const struct backend_ops *ops)
+guestfs_int_register_backend (const char *name, const struct backend_ops *ops)
 {
   struct backend *b;
 
@@ -482,7 +482,7 @@ guestfs___register_backend (const char *name, const struct backend_ops *ops)
  * handle initialization.  It can return an error code however.
  */
 int
-guestfs___set_backend (guestfs_h *g, const char *method)
+guestfs_int_set_backend (guestfs_h *g, const char *method)
 {
   struct backend *b;
   size_t len, arg_offs = 0;
diff --git a/src/libvirt-auth.c b/src/libvirt-auth.c
index f8ed1b1..af8b4a4 100644
--- a/src/libvirt-auth.c
+++ b/src/libvirt-auth.c
@@ -137,7 +137,7 @@ libvirt_auth_callback (virConnectCredentialPtr cred,
   g->requested_credentials = cred;
   g->nr_requested_credentials = ncred;
 
-  guestfs___call_callbacks_message (g, GUESTFS_EVENT_LIBVIRT_AUTH,
+  guestfs_int_call_callbacks_message (g, GUESTFS_EVENT_LIBVIRT_AUTH,
                                     g->saved_libvirt_uri,
                                     strlen (g->saved_libvirt_uri));
 
@@ -190,7 +190,7 @@ exists_libvirt_auth_event (guestfs_h *g)
 
 /* Open a libvirt connection (called from other parts of the library). */
 virConnectPtr
-guestfs___open_libvirt_connection (guestfs_h *g, const char *uri,
+guestfs_int_open_libvirt_connection (guestfs_h *g, const char *uri,
                                    unsigned int flags)
 {
   virConnectAuth authdata;
@@ -257,9 +257,9 @@ guestfs__get_libvirt_requested_credentials (guestfs_h *g)
 
   /* Convert the requested_credentials types to a list of strings. */
   for (i = 0; i < g->nr_requested_credentials; ++i)
-    guestfs___add_string (g, &ret,
+    guestfs_int_add_string (g, &ret,
                           get_string_of_credtype (g->requested_credentials[i].type));
-  guestfs___end_stringsbuf (g, &ret);
+  guestfs_int_end_stringsbuf (g, &ret);
 
   return ret.argv;              /* caller frees */
 }
diff --git a/src/libvirt-domain.c b/src/libvirt-domain.c
index 7e0a0d9..7897240 100644
--- a/src/libvirt-domain.c
+++ b/src/libvirt-domain.c
@@ -66,7 +66,7 @@ guestfs__add_domain (guestfs_h *g, const char *domain_name,
   const char *cachemode;
   const char *discard;
   bool copyonread;
-  struct guestfs___add_libvirt_dom_argv optargs2 = { .bitmask = 0 };
+  struct guestfs_int_add_libvirt_dom_argv optargs2 = { .bitmask = 0 };
 
   libvirturi = optargs->bitmask & GUESTFS_ADD_DOMAIN_LIBVIRTURI_BITMASK
                ? optargs->libvirturi : NULL;
@@ -93,7 +93,7 @@ guestfs__add_domain (guestfs_h *g, const char *domain_name,
   }
 
   /* Connect to libvirt, find the domain. */
-  conn = guestfs___open_libvirt_connection (g, libvirturi, VIR_CONNECT_RO);
+  conn = guestfs_int_open_libvirt_connection (g, libvirturi, VIR_CONNECT_RO);
   if (!conn) {
     err = virGetLastError ();
     error (g, _("could not connect to libvirt (code %d, domain %d): %s"),
@@ -151,7 +151,7 @@ guestfs__add_domain (guestfs_h *g, const char *domain_name,
     optargs2.copyonread = copyonread;
   }
 
-  r = guestfs___add_libvirt_dom (g, dom, &optargs2);
+  r = guestfs_int_add_libvirt_dom (g, dom, &optargs2);
 
  cleanup:
   if (dom) virDomainFree (dom);
@@ -178,8 +178,8 @@ struct add_disk_data {
 };
 
 GUESTFS_DLL_PUBLIC int
-guestfs___add_libvirt_dom (guestfs_h *g, virDomainPtr dom,
-                           const struct guestfs___add_libvirt_dom_argv *optargs)
+guestfs_int_add_libvirt_dom (guestfs_h *g, virDomainPtr dom,
+                           const struct guestfs_int_add_libvirt_dom_argv *optargs)
 {
   ssize_t r;
   int readonly;
@@ -309,10 +309,10 @@ guestfs___add_libvirt_dom (guestfs_h *g, virDomainPtr dom,
   /* Checkpoint the command line around the operation so that either
    * all disks are added or none are added.
    */
-  ckp = guestfs___checkpoint_drives (g);
+  ckp = guestfs_int_checkpoint_drives (g);
   r = for_each_disk (g, doc, add_disk, &data);
   if (r == -1)
-    guestfs___rollback_drives (g, ckp);
+    guestfs_int_rollback_drives (g, ckp);
 
   return r;
 }
diff --git a/src/listfs.c b/src/listfs.c
index ffb0adc..836ede2 100644
--- a/src/listfs.c
+++ b/src/listfs.c
@@ -125,11 +125,11 @@ guestfs__list_filesystems (guestfs_h *g)
   }
 
   /* Finish off the list and return it. */
-  guestfs___end_stringsbuf (g, &ret);
+  guestfs_int_end_stringsbuf (g, &ret);
   return ret.argv;
 
  error:
-  guestfs___free_stringsbuf (&ret);
+  guestfs_int_free_stringsbuf (&ret);
   return NULL;
 }
 
@@ -176,10 +176,10 @@ check_with_vfs_type (guestfs_h *g, const char *device, struct stringsbuf *sb)
 
     for (size_t i = 0; i < vols->len; i++) {
       struct guestfs_btrfssubvolume *this = &vols->val[i];
-      guestfs___add_sprintf (g, sb,
+      guestfs_int_add_sprintf (g, sb,
                              "btrfsvol:%s/%s",
                              device, this->btrfssubvolume_path);
-      guestfs___add_string (g, sb, "btrfs");
+      guestfs_int_add_string (g, sb, "btrfs");
     }
 
     v = vfs_type;
@@ -200,8 +200,8 @@ check_with_vfs_type (guestfs_h *g, const char *device, struct stringsbuf *sb)
     v = vfs_type;
   }
 
-  guestfs___add_string (g, sb, device);
-  guestfs___add_string (g, sb, v);
+  guestfs_int_add_string (g, sb, device);
+  guestfs_int_add_string (g, sb, v);
 
   return 0;
 }
diff --git a/src/lpj.c b/src/lpj.c
index 54f4012..88afc18 100644
--- a/src/lpj.c
+++ b/src/lpj.c
@@ -59,7 +59,7 @@ static int read_lpj_from_files (guestfs_h *g);
 static int read_lpj_common (guestfs_h *g, const char *func, struct command *cmd);
 
 int
-guestfs___get_lpj (guestfs_h *g)
+guestfs_int_get_lpj (guestfs_h *g)
 {
   int r;
 
@@ -94,9 +94,9 @@ guestfs___get_lpj (guestfs_h *g)
 static int
 read_lpj_from_dmesg (guestfs_h *g)
 {
-  CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
 
-  guestfs___cmd_add_string_unquoted (cmd, "dmesg | " GREP_CMD);
+  guestfs_int_cmd_add_string_unquoted (cmd, "dmesg | " GREP_CMD);
 
   return read_lpj_common (g, __func__, cmd);
 }
@@ -108,17 +108,17 @@ static int
 read_lpj_from_files (guestfs_h *g)
 {
   size_t files = 0;
-  CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
 
-  guestfs___cmd_add_arg (cmd, "grep");
-  guestfs___cmd_add_arg (cmd, GREP_FLAGS);
-  guestfs___cmd_add_arg (cmd, GREP_REGEX);
+  guestfs_int_cmd_add_arg (cmd, "grep");
+  guestfs_int_cmd_add_arg (cmd, GREP_FLAGS);
+  guestfs_int_cmd_add_arg (cmd, GREP_REGEX);
   if (access (FILE1, R_OK) == 0) {
-    guestfs___cmd_add_arg (cmd, FILE1);
+    guestfs_int_cmd_add_arg (cmd, FILE1);
     files++;
   }
   if (access (FILE2, R_OK) == 0) {
-    guestfs___cmd_add_arg (cmd, FILE2);
+    guestfs_int_cmd_add_arg (cmd, FILE2);
     files++;
   }
 
@@ -144,16 +144,16 @@ read_lpj_common (guestfs_h *g, const char *func, struct command *cmd)
   int r;
   CLEANUP_FREE char *buf = NULL;
 
-  guestfs___cmd_set_stdout_callback (cmd, read_all, &buf,
+  guestfs_int_cmd_set_stdout_callback (cmd, read_all, &buf,
                                      CMD_STDOUT_FLAG_WHOLE_BUFFER);
-  r = guestfs___cmd_run (cmd);
+  r = guestfs_int_cmd_run (cmd);
   if (r == -1)
     return -1;
   if (!WIFEXITED (r) || WEXITSTATUS (r) != 0) {
     char status_string[80];
 
     debug (g, "%s: %s", func,
-           guestfs___exit_status_to_string (r, "external command",
+           guestfs_int_exit_status_to_string (r, "external command",
                                             status_string,
                                             sizeof status_string));
     return -1;
diff --git a/src/match.c b/src/match.c
index 9401744..9c2fae9 100644
--- a/src/match.c
+++ b/src/match.c
@@ -31,7 +31,7 @@
  * true if it matches or false if it doesn't.
  */
 int
-guestfs___match (guestfs_h *g, const char *str, const pcre *re)
+guestfs_int_match (guestfs_h *g, const char *str, const pcre *re)
 {
   size_t len = strlen (str);
   int vec[30], r;
@@ -48,7 +48,7 @@ guestfs___match (guestfs_h *g, const char *str, const pcre *re)
  * caller must free the result.
  */
 char *
-guestfs___match1 (guestfs_h *g, const char *str, const pcre *re)
+guestfs_int_match1 (guestfs_h *g, const char *str, const pcre *re)
 {
   size_t len = strlen (str);
   int vec[30], r;
@@ -62,7 +62,7 @@ guestfs___match1 (guestfs_h *g, const char *str, const pcre *re)
 
 /* Match a regular expression which contains exactly two captures. */
 int
-guestfs___match2 (guestfs_h *g, const char *str, const pcre *re,
+guestfs_int_match2 (guestfs_h *g, const char *str, const pcre *re,
                   char **ret1, char **ret2)
 {
   size_t len = strlen (str);
@@ -83,7 +83,7 @@ guestfs___match2 (guestfs_h *g, const char *str, const pcre *re,
 
 /* Match a regular expression which contains exactly three captures. */
 int
-guestfs___match3 (guestfs_h *g, const char *str, const pcre *re,
+guestfs_int_match3 (guestfs_h *g, const char *str, const pcre *re,
                   char **ret1, char **ret2, char **ret3)
 {
   size_t len = strlen (str);
@@ -106,7 +106,7 @@ guestfs___match3 (guestfs_h *g, const char *str, const pcre *re,
 
 /* Match a regular expression which contains exactly four captures. */
 int
-guestfs___match4 (guestfs_h *g, const char *str, const pcre *re,
+guestfs_int_match4 (guestfs_h *g, const char *str, const pcre *re,
                   char **ret1, char **ret2, char **ret3, char **ret4)
 {
   size_t len = strlen (str);
@@ -131,7 +131,7 @@ guestfs___match4 (guestfs_h *g, const char *str, const pcre *re,
 
 /* Match a regular expression which contains exactly six captures. */
 int
-guestfs___match6 (guestfs_h *g, const char *str, const pcre *re,
+guestfs_int_match6 (guestfs_h *g, const char *str, const pcre *re,
                   char **ret1, char **ret2, char **ret3, char **ret4,
                   char **ret5, char **ret6)
 {
diff --git a/src/osinfo.c b/src/osinfo.c
index dfffaa9..8187962 100644
--- a/src/osinfo.c
+++ b/src/osinfo.c
@@ -111,7 +111,7 @@ static void free_osinfo_db_entry (struct osinfo *);
  *   1  => matching OS found, the osinfo_ret pointer has been filled in
  */
 int
-guestfs___osinfo_map (guestfs_h *g, const struct guestfs_isoinfo *isoinfo,
+guestfs_int_osinfo_map (guestfs_h *g, const struct guestfs_isoinfo *isoinfo,
                       const struct osinfo **osinfo_ret)
 {
   size_t i;
@@ -470,10 +470,10 @@ parse_version (guestfs_h *g, xmlNodePtr node, struct osinfo *osinfo)
   content = (char *) xmlNodeGetContent (node);
   if (content) {
     if (match2 (g, content, re_major_minor, &major, &minor)) {
-      osinfo->major_version = guestfs___parse_unsigned_int (g, major);
+      osinfo->major_version = guestfs_int_parse_unsigned_int (g, major);
       if (osinfo->major_version == -1)
         return -1;
-      osinfo->minor_version = guestfs___parse_unsigned_int (g, minor);
+      osinfo->minor_version = guestfs_int_parse_unsigned_int (g, minor);
       if (osinfo->minor_version == -1)
         return -1;
     }
diff --git a/src/proto.c b/src/proto.c
index 8001c8c..178362a 100644
--- a/src/proto.c
+++ b/src/proto.c
@@ -60,24 +60,24 @@
  * (2) A simple RPC (eg. "mount").  We write the request, then read
  * the reply.  The sequence of calls is:
  *
- *   guestfs___send
- *   guestfs___recv
+ *   guestfs_int_send
+ *   guestfs_int_recv
  *
  * (3) An RPC with FileOut parameters (eg. "upload").  We write the
  * request, then write the file(s), then read the reply.  The sequence
  * of calls is:
  *
- *   guestfs___send
- *   guestfs___send_file  (possibly multiple times)
- *   guestfs___recv
+ *   guestfs_int_send
+ *   guestfs_int_send_file  (possibly multiple times)
+ *   guestfs_int_recv
  *
  * (4) An RPC with FileIn parameters (eg. "download").  We write the
  * request, then read the reply, then read the file(s).  The sequence
  * of calls is:
  *
- *   guestfs___send
- *   guestfs___recv
- *   guestfs___recv_file  (possibly multiple times)
+ *   guestfs_int_send
+ *   guestfs_int_recv
+ *   guestfs_int_recv_file  (possibly multiple times)
  *
  * (5) Both FileOut and FileIn parameters.  There are no calls like
  * this in the current API, but they would be implemented as a
@@ -101,14 +101,14 @@ child_cleanup (guestfs_h *g)
     g->conn = NULL;
   }
   memset (&g->launch_t, 0, sizeof g->launch_t);
-  guestfs___free_drives (g);
+  guestfs_int_free_drives (g);
   g->state = CONFIG;
-  guestfs___call_callbacks_void (g, GUESTFS_EVENT_SUBPROCESS_QUIT);
+  guestfs_int_call_callbacks_void (g, GUESTFS_EVENT_SUBPROCESS_QUIT);
 }
 
 /* Convenient wrapper to generate a progress message callback. */
 void
-guestfs___progress_message_callback (guestfs_h *g,
+guestfs_int_progress_message_callback (guestfs_h *g,
                                      const guestfs_progress *message)
 {
   uint64_t array[4];
@@ -118,19 +118,19 @@ guestfs___progress_message_callback (guestfs_h *g,
   array[2] = message->position;
   array[3] = message->total;
 
-  guestfs___call_callbacks_array (g, GUESTFS_EVENT_PROGRESS,
+  guestfs_int_call_callbacks_array (g, GUESTFS_EVENT_PROGRESS,
                                   array, sizeof array / sizeof array[0]);
 }
 
 /* Connection modules call us back here when they get a log message. */
 void
-guestfs___log_message_callback (guestfs_h *g, const char *buf, size_t len)
+guestfs_int_log_message_callback (guestfs_h *g, const char *buf, size_t len)
 {
   /* Send the log message upwards to anyone who is listening. */
-  guestfs___call_callbacks_message (g, GUESTFS_EVENT_APPLIANCE, buf, len);
+  guestfs_int_call_callbacks_message (g, GUESTFS_EVENT_APPLIANCE, buf, len);
 
   /* This is used to generate launch progress messages.  See comment
-   * above guestfs___launch_send_progress.
+   * above guestfs_int_launch_send_progress.
    */
   if (g->state == LAUNCHING) {
     const char *sentinel;
@@ -139,12 +139,12 @@ guestfs___log_message_callback (guestfs_h *g, const char *buf, size_t len)
     sentinel = "Linux version"; /* kernel up */
     slen = strlen (sentinel);
     if (memmem (buf, len, sentinel, slen) != NULL)
-      guestfs___launch_send_progress (g, 6);
+      guestfs_int_launch_send_progress (g, 6);
 
     sentinel = "Starting /init script"; /* /init running */
     slen = strlen (sentinel);
     if (memmem (buf, len, sentinel, slen) != NULL)
-      guestfs___launch_send_progress (g, 9);
+      guestfs_int_launch_send_progress (g, 9);
   }
 }
 
@@ -192,7 +192,7 @@ check_daemon_socket (guestfs_h *g)
     xdr_guestfs_progress (&xdr, &message);
     xdr_destroy (&xdr);
 
-    guestfs___progress_message_callback (g, &message);
+    guestfs_int_progress_message_callback (g, &message);
 
     goto again;
   }
@@ -207,7 +207,7 @@ check_daemon_socket (guestfs_h *g)
 }
 
 int
-guestfs___send (guestfs_h *g, int proc_nr,
+guestfs_int_send (guestfs_h *g, int proc_nr,
                 uint64_t progress_hint, uint64_t optargs_bitmask,
                 xdrproc_t xdrp, char *args)
 {
@@ -220,7 +220,7 @@ guestfs___send (guestfs_h *g, int proc_nr,
   size_t msg_out_size;
 
   if (!g->conn) {
-    guestfs___unexpected_close_error (g);
+    guestfs_int_unexpected_close_error (g);
     return -1;
   }
 
@@ -278,7 +278,7 @@ guestfs___send (guestfs_h *g, int proc_nr,
   if (r == -1)
     return -1;
   if (r == 0) {
-    guestfs___unexpected_close_error (g);
+    guestfs_int_unexpected_close_error (g);
     child_cleanup (g);
     return -1;
   }
@@ -288,7 +288,7 @@ guestfs___send (guestfs_h *g, int proc_nr,
   if (r == -1)
     return -1;
   if (r == 0) {
-    guestfs___unexpected_close_error (g);
+    guestfs_int_unexpected_close_error (g);
     child_cleanup (g);
     return -1;
   }
@@ -321,7 +321,7 @@ static int send_file_complete (guestfs_h *g);
  *   -2 daemon cancelled (we must read the error message)
  */
 int
-guestfs___send_file (guestfs_h *g, const char *filename)
+guestfs_int_send_file (guestfs_h *g, const char *filename)
 {
   char buf[GUESTFS_MAX_CHUNK_SIZE];
   int fd, r = 0, err;
@@ -455,7 +455,7 @@ send_file_chunk (guestfs_h *g, int cancel, const char *buf, size_t buflen)
   if (r == -1)
     return -1;
   if (r == 0) {
-    guestfs___unexpected_close_error (g);
+    guestfs_int_unexpected_close_error (g);
     child_cleanup (g);
     return -1;
   }
@@ -465,7 +465,7 @@ send_file_chunk (guestfs_h *g, int cancel, const char *buf, size_t buflen)
   if (r == -1)
     return -1;
   if (r == 0) {
-    guestfs___unexpected_close_error (g);
+    guestfs_int_unexpected_close_error (g);
     child_cleanup (g);
     return -1;
   }
@@ -473,7 +473,7 @@ send_file_chunk (guestfs_h *g, int cancel, const char *buf, size_t buflen)
   return 0;
 }
 
-/* guestfs___recv_from_daemon: This reads a single message, file
+/* guestfs_int_recv_from_daemon: This reads a single message, file
  * chunk, launch flag or cancellation flag from the daemon.  If
  * something was read, it returns 0, otherwise -1.
  *
@@ -507,7 +507,7 @@ recv_from_daemon (guestfs_h *g, uint32_t *size_rtn, void **buf_rtn)
    * return an error if this happens.
    */
   if (!g->conn) {
-    guestfs___unexpected_close_error (g);
+    guestfs_int_unexpected_close_error (g);
     return -1;
   }
 
@@ -516,7 +516,7 @@ recv_from_daemon (guestfs_h *g, uint32_t *size_rtn, void **buf_rtn)
   if (n == -1)
     return -1;
   if (n == 0) {
-    guestfs___unexpected_close_error (g);
+    guestfs_int_unexpected_close_error (g);
     child_cleanup (g);
     return -1;
   }
@@ -531,7 +531,7 @@ recv_from_daemon (guestfs_h *g, uint32_t *size_rtn, void **buf_rtn)
              g->state);
     else {
       g->state = READY;
-      guestfs___call_callbacks_void (g, GUESTFS_EVENT_LAUNCH_DONE);
+      guestfs_int_call_callbacks_void (g, GUESTFS_EVENT_LAUNCH_DONE);
     }
     debug (g, "recv_from_daemon: received GUESTFS_LAUNCH_FLAG");
     return 0;
@@ -566,7 +566,7 @@ recv_from_daemon (guestfs_h *g, uint32_t *size_rtn, void **buf_rtn)
     return -1;
   }
   if (n == 0) {
-    guestfs___unexpected_close_error (g);
+    guestfs_int_unexpected_close_error (g);
     child_cleanup (g);
     free (*buf_rtn);
     *buf_rtn = NULL;
@@ -603,7 +603,7 @@ recv_from_daemon (guestfs_h *g, uint32_t *size_rtn, void **buf_rtn)
 }
 
 int
-guestfs___recv_from_daemon (guestfs_h *g, uint32_t *size_rtn, void **buf_rtn)
+guestfs_int_recv_from_daemon (guestfs_h *g, uint32_t *size_rtn, void **buf_rtn)
 {
   int r;
 
@@ -620,7 +620,7 @@ guestfs___recv_from_daemon (guestfs_h *g, uint32_t *size_rtn, void **buf_rtn)
     xdr_guestfs_progress (&xdr, &message);
     xdr_destroy (&xdr);
 
-    guestfs___progress_message_callback (g, &message);
+    guestfs_int_progress_message_callback (g, &message);
 
     free (*buf_rtn);
     *buf_rtn = NULL;
@@ -640,7 +640,7 @@ guestfs___recv_from_daemon (guestfs_h *g, uint32_t *size_rtn, void **buf_rtn)
 
 /* Receive a reply. */
 int
-guestfs___recv (guestfs_h *g, const char *fn,
+guestfs_int_recv (guestfs_h *g, const char *fn,
                 guestfs_message_header *hdr,
                 guestfs_message_error *err,
                 xdrproc_t xdrp, char *ret)
@@ -651,7 +651,7 @@ guestfs___recv (guestfs_h *g, const char *fn,
   int r;
 
  again:
-  r = guestfs___recv_from_daemon (g, &size, &buf);
+  r = guestfs_int_recv_from_daemon (g, &size, &buf);
   if (r == -1)
     return -1;
 
@@ -692,21 +692,21 @@ guestfs___recv (guestfs_h *g, const char *fn,
   return 0;
 }
 
-/* Same as guestfs___recv, but it discards the reply message.
+/* Same as guestfs_int_recv, but it discards the reply message.
  *
  * Notes (XXX):
  * (1) This returns an int, but all current callers ignore it.
  * (2) The error string may end up being set twice on error paths.
  */
 int
-guestfs___recv_discard (guestfs_h *g, const char *fn)
+guestfs_int_recv_discard (guestfs_h *g, const char *fn)
 {
   CLEANUP_FREE void *buf = NULL;
   uint32_t size;
   int r;
 
  again:
-  r = guestfs___recv_from_daemon (g, &size, &buf);
+  r = guestfs_int_recv_from_daemon (g, &size, &buf);
   if (r == -1)
     return -1;
 
@@ -749,7 +749,7 @@ static ssize_t receive_file_data (guestfs_h *g, void **buf);
 
 /* Returns -1 = error, 0 = EOF, > 0 = more data */
 int
-guestfs___recv_file (guestfs_h *g, const char *filename)
+guestfs_int_recv_file (guestfs_h *g, const char *filename)
 {
   void *buf;
   int fd, r;
@@ -829,7 +829,7 @@ receive_file_data (guestfs_h *g, void **buf_r)
   XDR xdr;
   guestfs_chunk chunk;
 
-  r = guestfs___recv_from_daemon (g, &len, &buf);
+  r = guestfs_int_recv_from_daemon (g, &len, &buf);
   if (r == -1)
     return -1;
 
diff --git a/src/stringsbuf.c b/src/stringsbuf.c
index df1dfd6..706ee5c 100644
--- a/src/stringsbuf.c
+++ b/src/stringsbuf.c
@@ -29,7 +29,7 @@
 #include "guestfs-internal.h"
 
 void
-guestfs___add_string_nodup (guestfs_h *g, struct stringsbuf *sb, char *str)
+guestfs_int_add_string_nodup (guestfs_h *g, struct stringsbuf *sb, char *str)
 {
   if (sb->size >= sb->alloc) {
     sb->alloc += 64;
@@ -41,13 +41,13 @@ guestfs___add_string_nodup (guestfs_h *g, struct stringsbuf *sb, char *str)
 }
 
 void
-guestfs___add_string (guestfs_h *g, struct stringsbuf *sb, const char *str)
+guestfs_int_add_string (guestfs_h *g, struct stringsbuf *sb, const char *str)
 {
-  guestfs___add_string_nodup (g, sb, safe_strdup (g, str));
+  guestfs_int_add_string_nodup (g, sb, safe_strdup (g, str));
 }
 
 void
-guestfs___add_sprintf (guestfs_h *g, struct stringsbuf *sb,
+guestfs_int_add_sprintf (guestfs_h *g, struct stringsbuf *sb,
                        const char *fs, ...)
 {
   va_list args;
@@ -60,17 +60,17 @@ guestfs___add_sprintf (guestfs_h *g, struct stringsbuf *sb,
   if (r == -1)
     g->abort_cb ();
 
-  guestfs___add_string_nodup (g, sb, str);
+  guestfs_int_add_string_nodup (g, sb, str);
 }
 
 void
-guestfs___end_stringsbuf (guestfs_h *g, struct stringsbuf *sb)
+guestfs_int_end_stringsbuf (guestfs_h *g, struct stringsbuf *sb)
 {
-  guestfs___add_string_nodup (g, sb, NULL);
+  guestfs_int_add_string_nodup (g, sb, NULL);
 }
 
 void
-guestfs___free_stringsbuf (struct stringsbuf *sb)
+guestfs_int_free_stringsbuf (struct stringsbuf *sb)
 {
   size_t i;
 
@@ -82,7 +82,7 @@ guestfs___free_stringsbuf (struct stringsbuf *sb)
 }
 
 void
-guestfs___cleanup_free_stringsbuf (struct stringsbuf *sb)
+guestfs_int_cleanup_free_stringsbuf (struct stringsbuf *sb)
 {
-  guestfs___free_stringsbuf (sb);
+  guestfs_int_free_stringsbuf (sb);
 }
diff --git a/src/test-utils.c b/src/test-utils.c
index c4a6a62..8e1491f 100644
--- a/src/test-utils.c
+++ b/src/test-utils.c
@@ -31,62 +31,62 @@
 #include "guestfs-internal.h"
 #include "guestfs-internal-frontend.h"
 
-/* Test guestfs___split_string. */
+/* Test guestfs_int_split_string. */
 static void
 test_split (void)
 {
   char **ret;
 
-  ret = guestfs___split_string (':', "");
+  ret = guestfs_int_split_string (':', "");
   assert (ret);
-  assert (guestfs___count_strings (ret) == 0);
-  guestfs___free_string_list (ret);
+  assert (guestfs_int_count_strings (ret) == 0);
+  guestfs_int_free_string_list (ret);
 
-  ret = guestfs___split_string (':', "a");
+  ret = guestfs_int_split_string (':', "a");
   assert (ret);
-  assert (guestfs___count_strings (ret) == 1);
+  assert (guestfs_int_count_strings (ret) == 1);
   assert (STREQ (ret[0], "a"));
-  guestfs___free_string_list (ret);
+  guestfs_int_free_string_list (ret);
 
-  ret = guestfs___split_string (':', ":");
+  ret = guestfs_int_split_string (':', ":");
   assert (ret);
-  assert (guestfs___count_strings (ret) == 2);
+  assert (guestfs_int_count_strings (ret) == 2);
   assert (STREQ (ret[0], ""));
   assert (STREQ (ret[1], ""));
-  guestfs___free_string_list (ret);
+  guestfs_int_free_string_list (ret);
 
-  ret = guestfs___split_string (':', "::");
+  ret = guestfs_int_split_string (':', "::");
   assert (ret);
-  assert (guestfs___count_strings (ret) == 3);
+  assert (guestfs_int_count_strings (ret) == 3);
   assert (STREQ (ret[0], ""));
   assert (STREQ (ret[1], ""));
   assert (STREQ (ret[2], ""));
-  guestfs___free_string_list (ret);
+  guestfs_int_free_string_list (ret);
 
-  ret = guestfs___split_string (':', ":a");
+  ret = guestfs_int_split_string (':', ":a");
   assert (ret);
-  assert (guestfs___count_strings (ret) == 2);
+  assert (guestfs_int_count_strings (ret) == 2);
   assert (STREQ (ret[0], ""));
   assert (STREQ (ret[1], "a"));
-  guestfs___free_string_list (ret);
+  guestfs_int_free_string_list (ret);
 
-  ret = guestfs___split_string (':', "a:");
+  ret = guestfs_int_split_string (':', "a:");
   assert (ret);
-  assert (guestfs___count_strings (ret) == 2);
+  assert (guestfs_int_count_strings (ret) == 2);
   assert (STREQ (ret[0], "a"));
   assert (STREQ (ret[1], ""));
-  guestfs___free_string_list (ret);
+  guestfs_int_free_string_list (ret);
 
-  ret = guestfs___split_string (':', "a:b:c");
+  ret = guestfs_int_split_string (':', "a:b:c");
   assert (ret);
-  assert (guestfs___count_strings (ret) == 3);
+  assert (guestfs_int_count_strings (ret) == 3);
   assert (STREQ (ret[0], "a"));
   assert (STREQ (ret[1], "b"));
   assert (STREQ (ret[2], "c"));
-  guestfs___free_string_list (ret);
+  guestfs_int_free_string_list (ret);
 }
 
-/* Test guestfs___concat_strings. */
+/* Test guestfs_int_concat_strings. */
 static void
 test_concat (void)
 {
@@ -97,28 +97,28 @@ test_concat (void)
   const char *test4[] = { "a", "", NULL };
   const char *test5[] = { "a", "b", NULL };
 
-  ret = guestfs___concat_strings ((char **) test1);
+  ret = guestfs_int_concat_strings ((char **) test1);
   assert (STREQ (ret, ""));
   free (ret);
 
-  ret = guestfs___concat_strings ((char **) test2);
+  ret = guestfs_int_concat_strings ((char **) test2);
   assert (STREQ (ret, ""));
   free (ret);
 
-  ret = guestfs___concat_strings ((char **) test3);
+  ret = guestfs_int_concat_strings ((char **) test3);
   assert (STREQ (ret, "a"));
   free (ret);
 
-  ret = guestfs___concat_strings ((char **) test4);
+  ret = guestfs_int_concat_strings ((char **) test4);
   assert (STREQ (ret, "a"));
   free (ret);
 
-  ret = guestfs___concat_strings ((char **) test5);
+  ret = guestfs_int_concat_strings ((char **) test5);
   assert (STREQ (ret, "ab"));
   free (ret);
 }
 
-/* Test guestfs___join_strings. */
+/* Test guestfs_int_join_strings. */
 static void
 test_join (void)
 {
@@ -129,37 +129,37 @@ test_join (void)
   const char *test4[] = { "a", "", NULL };
   const char *test5[] = { "a", "b", NULL };
 
-  ret = guestfs___join_strings (":!", (char **) test1);
+  ret = guestfs_int_join_strings (":!", (char **) test1);
   assert (STREQ (ret, ""));
   free (ret);
 
-  ret = guestfs___join_strings (":!", (char **) test2);
+  ret = guestfs_int_join_strings (":!", (char **) test2);
   assert (STREQ (ret, ""));
   free (ret);
 
-  ret = guestfs___join_strings (":!", (char **) test3);
+  ret = guestfs_int_join_strings (":!", (char **) test3);
   assert (STREQ (ret, "a"));
   free (ret);
 
-  ret = guestfs___join_strings (":!", (char **) test4);
+  ret = guestfs_int_join_strings (":!", (char **) test4);
   assert (STREQ (ret, "a:!"));
   free (ret);
 
-  ret = guestfs___join_strings (":!", (char **) test5);
+  ret = guestfs_int_join_strings (":!", (char **) test5);
   assert (STREQ (ret, "a:!b"));
   free (ret);
 }
 
-/* Test guestfs___validate_guid. */
+/* Test guestfs_int_validate_guid. */
 static void
 test_validate_guid (void)
 {
-  assert (guestfs___validate_guid ("") == 0);
-  assert (guestfs___validate_guid ("1") == 0);
-  assert (guestfs___validate_guid ("21EC20203AEA1069A2DD08002B30309D") == 0);
+  assert (guestfs_int_validate_guid ("") == 0);
+  assert (guestfs_int_validate_guid ("1") == 0);
+  assert (guestfs_int_validate_guid ("21EC20203AEA1069A2DD08002B30309D") == 0);
 
-  assert (guestfs___validate_guid ("{21EC2020-3AEA-1069-A2DD-08002B30309D}") == 1);
-  assert (guestfs___validate_guid ("21EC2020-3AEA-1069-A2DD-08002B30309D") == 1);
+  assert (guestfs_int_validate_guid ("{21EC2020-3AEA-1069-A2DD-08002B30309D}") == 1);
+  assert (guestfs_int_validate_guid ("21EC2020-3AEA-1069-A2DD-08002B30309D") == 1);
 }
 
 int
diff --git a/src/tmpdirs.c b/src/tmpdirs.c
index 56523aa..1e49ba7 100644
--- a/src/tmpdirs.c
+++ b/src/tmpdirs.c
@@ -72,7 +72,7 @@ set_abs_path (guestfs_h *g, const char *tmpdir, char **tmpdir_ret)
 }
 
 int
-guestfs___set_env_tmpdir (guestfs_h *g, const char *tmpdir)
+guestfs_int_set_env_tmpdir (guestfs_h *g, const char *tmpdir)
 {
   return set_abs_path (g, tmpdir, &g->env_tmpdir);
 }
@@ -126,7 +126,7 @@ guestfs__get_cachedir (guestfs_h *g)
  * first time it is used, or during launch.
  */
 int
-guestfs___lazy_make_tmpdir (guestfs_h *g)
+guestfs_int_lazy_make_tmpdir (guestfs_h *g)
 {
   if (!g->tmpdir) {
     CLEANUP_FREE char *tmpdir = guestfs_get_tmpdir (g);
@@ -147,19 +147,19 @@ guestfs___lazy_make_tmpdir (guestfs_h *g)
  * simpler and safer.
  */
 void
-guestfs___recursive_remove_dir (guestfs_h *g, const char *dir)
+guestfs_int_recursive_remove_dir (guestfs_h *g, const char *dir)
 {
-  CLEANUP_CMD_CLOSE struct command *cmd = guestfs___new_command (g);
+  CLEANUP_CMD_CLOSE struct command *cmd = guestfs_int_new_command (g);
 
-  guestfs___cmd_add_arg (cmd, "rm");
-  guestfs___cmd_add_arg (cmd, "-rf");
-  guestfs___cmd_add_arg (cmd, dir);
-  ignore_value (guestfs___cmd_run (cmd));
+  guestfs_int_cmd_add_arg (cmd, "rm");
+  guestfs_int_cmd_add_arg (cmd, "-rf");
+  guestfs_int_cmd_add_arg (cmd, dir);
+  ignore_value (guestfs_int_cmd_run (cmd));
 }
 
 void
-guestfs___remove_tmpdir (guestfs_h *g)
+guestfs_int_remove_tmpdir (guestfs_h *g)
 {
   if (g->tmpdir)
-    guestfs___recursive_remove_dir (g, g->tmpdir);
+    guestfs_int_recursive_remove_dir (g, g->tmpdir);
 }
diff --git a/src/utils.c b/src/utils.c
index 11c6953..3c7c02e 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -38,7 +38,7 @@
  */
 
 void
-guestfs___free_string_list (char **argv)
+guestfs_int_free_string_list (char **argv)
 {
   size_t i;
 
@@ -51,7 +51,7 @@ guestfs___free_string_list (char **argv)
 }
 
 size_t
-guestfs___count_strings (char *const *argv)
+guestfs_int_count_strings (char *const *argv)
 {
   size_t r;
 
@@ -62,9 +62,9 @@ guestfs___count_strings (char *const *argv)
 }
 
 char **
-guestfs___copy_string_list (char *const *argv)
+guestfs_int_copy_string_list (char *const *argv)
 {
-  size_t n = guestfs___count_strings (argv);
+  size_t n = guestfs_int_count_strings (argv);
   size_t i, j;
   char **ret;
 
@@ -88,13 +88,13 @@ guestfs___copy_string_list (char *const *argv)
 
 /* Note that near-identical functions exist in the daemon. */
 char *
-guestfs___concat_strings (char *const *argv)
+guestfs_int_concat_strings (char *const *argv)
 {
-  return guestfs___join_strings ("", argv);
+  return guestfs_int_join_strings ("", argv);
 }
 
 char *
-guestfs___join_strings (const char *sep, char *const *argv)
+guestfs_int_join_strings (const char *sep, char *const *argv)
 {
   size_t i, len, seplen, rlen;
   char *r;
@@ -138,7 +138,7 @@ guestfs___join_strings (const char *sep, char *const *argv)
  * str == ":"   => returns ["", ""]
  */
 char **
-guestfs___split_string (char sep, const char *str)
+guestfs_int_split_string (char sep, const char *str)
 {
   size_t i, n, c, len = strlen (str);
   char reject[2] = { sep, '\0' };
@@ -188,7 +188,7 @@ guestfs___split_string (char sep, const char *str)
  * string must be freed by the caller.
  */
 char *
-guestfs___exit_status_to_string (int status, const char *cmd_name,
+guestfs_int_exit_status_to_string (int status, const char *cmd_name,
                                  char *buffer, size_t buflen)
 {
   if (WIFEXITED (status)) {
@@ -224,7 +224,7 @@ guestfs___exit_status_to_string (int status, const char *cmd_name,
  * 5*len bits of randomness in the resulting string).
  */
 int
-guestfs___random_string (char *ret, size_t len)
+guestfs_int_random_string (char *ret, size_t len)
 {
   int fd;
   size_t i;
@@ -261,10 +261,10 @@ guestfs___random_string (char *ret, size_t len)
  * https://rwmj.wordpress.com/2011/01/09/how-are-linux-drives-named-beyond-drive-26-devsdz/
  */
 char *
-guestfs___drive_name (size_t index, char *ret)
+guestfs_int_drive_name (size_t index, char *ret)
 {
   if (index >= 26)
-    ret = guestfs___drive_name (index/26 - 1, ret);
+    ret = guestfs_int_drive_name (index/26 - 1, ret);
   index %= 26;
   *ret++ = 'a' + index;
   *ret = '\0';
@@ -273,7 +273,7 @@ guestfs___drive_name (size_t index, char *ret)
 
 /* Similar to Tcl_GetBoolean. */
 int
-guestfs___is_true (const char *str)
+guestfs_int_is_true (const char *str)
 {
   if (STREQ (str, "1") ||
       STRCASEEQ (str, "true") ||
diff --git a/tests/c-api/test-backend-settings.c b/tests/c-api/test-backend-settings.c
index 4b24e21..ce1854f 100644
--- a/tests/c-api/test-backend-settings.c
+++ b/tests/c-api/test-backend-settings.c
@@ -53,7 +53,7 @@ main (int argc, char *argv[])
   strs = guestfs_get_backend_settings (g);
   assert (strs != NULL);
   assert (strs[0] == NULL);
-  guestfs___free_string_list (strs);
+  guestfs_int_free_string_list (strs);
 
   guestfs_push_error_handler (g, NULL, NULL);
   str = guestfs_get_backend_setting (g, "foo");
@@ -97,7 +97,7 @@ main (int argc, char *argv[])
     assert (STREQ (strs[3], "bar"));
     assert (STREQ (strs[4], "baz=value"));
     assert (strs[5] == NULL);
-    guestfs___free_string_list (strs);
+    guestfs_int_free_string_list (strs);
 
     str = guestfs_get_backend_setting (g, "bar");
     assert (str != NULL);
@@ -140,7 +140,7 @@ main (int argc, char *argv[])
     strs = guestfs_get_backend_settings (g);
     assert (strs != NULL);
     assert (strs[0] == NULL);
-    guestfs___free_string_list (strs);
+    guestfs_int_free_string_list (strs);
   }
 
   guestfs_close (g);
diff --git a/tests/charsets/test-charset-fidelity.c b/tests/charsets/test-charset-fidelity.c
index c127314..4f2346e 100644
--- a/tests/charsets/test-charset-fidelity.c
+++ b/tests/charsets/test-charset-fidelity.c
@@ -81,9 +81,9 @@ main (int argc, char *argv[])
 
   /* Allow this test to be skipped. */
   str = getenv (ourenvvar);
-  if (str && guestfs___is_true (str) > 0) {
+  if (str && guestfs_int_is_true (str) > 0) {
     printf ("%s: test skipped because environment variable is set.\n",
-            guestfs___program_name);
+            guestfs_int_program_name);
     exit (77);
   }
 
@@ -126,7 +126,7 @@ test_filesystem (guestfs_h *g, const struct filesystem *fs)
 
   snprintf (envvar, sizeof envvar, "%s_%s", ourenvvar, fs->fs_name);
   str = getenv (envvar);
-  if (str && guestfs___is_true (str) > 0) {
+  if (str && guestfs_int_is_true (str) > 0) {
     printf ("skipped test of %s because environment variable is set\n",
             fs->fs_name);
     return;
@@ -195,7 +195,7 @@ test_ascii (guestfs_h *g, const struct filesystem *fs)
   if (files == NULL)
     exit (EXIT_FAILURE);
   ignore_lost_and_found (files);
-  count = guestfs___count_strings (files);
+  count = guestfs_int_count_strings (files);
 
   if (fs->fs_case_insensitive) { /* case insensitive */
     if (count != 2)
@@ -260,7 +260,7 @@ test_latin1 (guestfs_h *g, const struct filesystem *fs)
   if (files == NULL)
     exit (EXIT_FAILURE);
   ignore_lost_and_found (files);
-  count = guestfs___count_strings (files);
+  count = guestfs_int_count_strings (files);
 
   if (fs->fs_case_insensitive) { /* case insensitive */
     if (count != 1)
@@ -322,7 +322,7 @@ test_latin2 (guestfs_h *g, const struct filesystem *fs)
   if (files == NULL)
     exit (EXIT_FAILURE);
   ignore_lost_and_found (files);
-  count = guestfs___count_strings (files);
+  count = guestfs_int_count_strings (files);
 
   if (fs->fs_case_insensitive) { /* case insensitive */
     if (count != 1)
@@ -387,7 +387,7 @@ test_chinese (guestfs_h *g, const struct filesystem *fs)
   if (files == NULL)
     exit (EXIT_FAILURE);
   ignore_lost_and_found (files);
-  count = guestfs___count_strings (files);
+  count = guestfs_int_count_strings (files);
 
   if (count != nr_filenames)
     error (EXIT_FAILURE, 0,
diff --git a/tests/mount-local/test-parallel-mount-local.c b/tests/mount-local/test-parallel-mount-local.c
index 00c95dc..f4d1a2d 100644
--- a/tests/mount-local/test-parallel-mount-local.c
+++ b/tests/mount-local/test-parallel-mount-local.c
@@ -94,15 +94,15 @@ main (int argc, char *argv[])
 
   /* Allow the test to be skipped by setting an environment variable. */
   skip = getenv ("SKIP_TEST_PARALLEL_MOUNT_LOCAL");
-  if (skip && guestfs___is_true (skip) > 0) {
+  if (skip && guestfs_int_is_true (skip) > 0) {
     fprintf (stderr, "%s: test skipped because environment variable set.\n",
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (77);
   }
 
   if (access ("/dev/fuse", W_OK) == -1) {
     fprintf (stderr, "%s: test skipped because /dev/fuse is not writable.\n",
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (77);
   }
 
@@ -242,7 +242,7 @@ start_thread (void *statevp)
       char status_string[80];
 
       fprintf (stderr, "%s: %s\n", state->mp,
-               guestfs___exit_status_to_string (status, "test",
+               guestfs_int_exit_status_to_string (status, "test",
                                                 status_string,
                                                 sizeof status_string));
         goto error;
diff --git a/tests/parallel/test-parallel.c b/tests/parallel/test-parallel.c
index 0ed3a8e..d018ec7 100644
--- a/tests/parallel/test-parallel.c
+++ b/tests/parallel/test-parallel.c
@@ -76,9 +76,9 @@ main (int argc, char *argv[])
 
   /* Allow the test to be skipped by setting an environment variable. */
   skip = getenv ("SKIP_TEST_PARALLEL");
-  if (skip && guestfs___is_true (skip) > 0) {
+  if (skip && guestfs_int_is_true (skip) > 0) {
     fprintf (stderr, "%s: test skipped because environment variable set.\n",
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (77);
   }
 
diff --git a/tests/qemu/qemu-boot.c b/tests/qemu/qemu-boot.c
index ce52f9a..e9683eb 100644
--- a/tests/qemu/qemu-boot.c
+++ b/tests/qemu/qemu-boot.c
@@ -102,7 +102,7 @@ main (int argc, char *argv[])
     case 0:
       /* Options which are long only. */
       fprintf (stderr, "%s: unknown long option: %s (%d)\n",
-               guestfs___program_name, long_options[option_index].name, option_index);
+               guestfs_int_program_name, long_options[option_index].name, option_index);
       exit (EXIT_FAILURE);
 
     case 'i':
@@ -112,14 +112,14 @@ main (int argc, char *argv[])
     case 'n':
       if (sscanf (optarg, "%zu", &n) != 1 || n == 0) {
         fprintf (stderr, "%s: -n option not numeric and greater than 0\n",
-                 guestfs___program_name);
+                 guestfs_int_program_name);
         exit (EXIT_FAILURE);
       }
       break;
 
     case 'P':
       if (sscanf (optarg, "%zu", &P) != 1) {
-        fprintf (stderr, "%s: -P option not numeric\n", guestfs___program_name);
+        fprintf (stderr, "%s: -P option not numeric\n", guestfs_int_program_name);
         exit (EXIT_FAILURE);
       }
       break;
@@ -143,13 +143,13 @@ main (int argc, char *argv[])
   if (n == 0) {
     fprintf (stderr,
              "%s: must specify number of processes to run (-n option)\n",
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
   if (optind != argc) {
     fprintf (stderr, "%s: extra arguments found on the command line\n",
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
@@ -168,7 +168,7 @@ main (int argc, char *argv[])
     err = pthread_create (&threads[i], NULL, start_thread, &thread_data[i]);
     if (err != 0) {
       fprintf (stderr, "%s: pthread_create[%zu]: %s\n",
-               guestfs___program_name, i, strerror (err));
+               guestfs_int_program_name, i, strerror (err));
       exit (EXIT_FAILURE);
     }
   }
@@ -179,7 +179,7 @@ main (int argc, char *argv[])
     err = pthread_join (threads[i], &status);
     if (err != 0) {
       fprintf (stderr, "%s: pthread_join[%zu]: %s\n",
-               guestfs___program_name, i, strerror (err));
+               guestfs_int_program_name, i, strerror (err));
       errors++;
     }
     if (*(int *)status == -1)
@@ -205,7 +205,7 @@ start_thread (void *thread_data_vp)
     err = pthread_mutex_lock (&mutex);
     if (err != 0) {
       fprintf (stderr, "%s: pthread_mutex_lock: %s",
-               guestfs___program_name, strerror (err));
+               guestfs_int_program_name, strerror (err));
       goto error;
     }
 
@@ -222,7 +222,7 @@ start_thread (void *thread_data_vp)
     err = pthread_mutex_unlock (&mutex);
     if (err != 0) {
       fprintf (stderr, "%s: pthread_mutex_unlock: %s",
-               guestfs___program_name, strerror (err));
+               guestfs_int_program_name, strerror (err));
       goto error;
     }
 
@@ -263,7 +263,7 @@ start_thread (void *thread_data_vp)
 
   if (errors > 0) {
     fprintf (stderr, "%s: thread %d: %u errors were ignored\n",
-             guestfs___program_name, thread_data->thread_num, errors);
+             guestfs_int_program_name, thread_data->thread_num, errors);
     goto error;
   }
 
diff --git a/tests/qemu/qemu-speed-test.c b/tests/qemu/qemu-speed-test.c
index b054bcf..0d0f098 100644
--- a/tests/qemu/qemu-speed-test.c
+++ b/tests/qemu/qemu-speed-test.c
@@ -132,7 +132,7 @@ main (int argc, char *argv[])
       }
       else {
         fprintf (stderr, "%s: unknown long option: %s (%d)\n",
-                 guestfs___program_name, long_options[option_index].name, option_index);
+                 guestfs_int_program_name, long_options[option_index].name, option_index);
         exit (EXIT_FAILURE);
       }
       break;
@@ -141,7 +141,7 @@ main (int argc, char *argv[])
       if (sscanf (optarg, "%d", &max_time_override) != 1 ||
           max_time_override < 0) {
         fprintf (stderr, "%s: -t: argument is not a positive integer\n",
-                 guestfs___program_name);
+                 guestfs_int_program_name);
         exit (EXIT_FAILURE);
       }
       break;
@@ -156,7 +156,7 @@ main (int argc, char *argv[])
 
   if (optind != argc) {
     fprintf (stderr, "%s: extra arguments found on the command line\n",
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
@@ -319,14 +319,14 @@ test_virtio_serial (void)
     if (r == -1 && guestfs_last_errno (g) != EINTR) {
       fprintf (stderr,
                "%s: expecting upload command to return EINTR\n%s\n",
-               guestfs___program_name, guestfs_last_error (g));
+               guestfs_int_program_name, guestfs_last_error (g));
       exit (EXIT_FAILURE);
     }
 
     if (rate == -1) {
     rate_error:
       fprintf (stderr, "%s: internal error: progress callback was not called! (r=%d, errno=%d)\n",
-               guestfs___program_name,
+               guestfs_int_program_name,
                r, guestfs_last_errno (g));
       exit (EXIT_FAILURE);
     }
@@ -355,7 +355,7 @@ test_virtio_serial (void)
     if (r == -1 && guestfs_last_errno (g) != EINTR) {
       fprintf (stderr,
                "%s: expecting download command to return EINTR\n%s\n",
-               guestfs___program_name, guestfs_last_error (g));
+               guestfs_int_program_name, guestfs_last_error (g));
       exit (EXIT_FAILURE);
     }
 
@@ -427,7 +427,7 @@ test_block_device (void)
     exit (EXIT_FAILURE);
   if (devices[0] == NULL) {
     fprintf (stderr, "%s: expected guestfs_list_devices to return at least 1 device\n",
-             guestfs___program_name);
+             guestfs_int_program_name);
     exit (EXIT_FAILURE);
   }
 
@@ -443,7 +443,7 @@ test_block_device (void)
 
     if (sscanf (r, "%" SCNi64, &bytes_written) != 1) {
       fprintf (stderr, "%s: could not parse device_speed output\n",
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
 
@@ -462,7 +462,7 @@ test_block_device (void)
 
     if (sscanf (r, "%" SCNi64, &bytes_read) != 1) {
       fprintf (stderr, "%s: could not parse device_speed output\n",
-               guestfs___program_name);
+               guestfs_int_program_name);
       exit (EXIT_FAILURE);
     }
 
diff --git a/tests/regressions/rhbz790721.c b/tests/regressions/rhbz790721.c
index 683490c..de6646d 100644
--- a/tests/regressions/rhbz790721.c
+++ b/tests/regressions/rhbz790721.c
@@ -72,7 +72,7 @@ main (int argc, char *argv[])
   }
   if (STRNEQ (backend, "direct")) {
     fprintf (stderr, "%s: test skipped because backend isn't 'direct'.\n",
-             guestfs___program_name);
+             guestfs_int_program_name);
     free (backend);
     guestfs_close (g);
     exit (77);
@@ -177,7 +177,7 @@ start_thread (void *vi)
   }
 
   /* The error message should match the one printed by
-   * guestfs___launch_failed_error.  If not, it indicates a bug/race
+   * guestfs_int_launch_failed_error.  If not, it indicates a bug/race
    * in the appliance building code which is what this regression test
    * is designed to spot.
    */
diff --git a/tests/regressions/rhbz914931.c b/tests/regressions/rhbz914931.c
index a677ca9..bce2924 100644
--- a/tests/regressions/rhbz914931.c
+++ b/tests/regressions/rhbz914931.c
@@ -41,9 +41,9 @@ main (int argc, char *argv[])
 
   /* Allow this test to be skipped. */
   str = getenv ("SKIP_TEST_RHBZ914931");
-  if (str && guestfs___is_true (str) > 0) {
+  if (str && guestfs_int_is_true (str) > 0) {
     printf ("%s: test skipped because environment variable is set.\n",
-            guestfs___program_name);
+            guestfs_int_program_name);
     exit (77);
   }
 
diff --git a/v2v/utils-c.c b/v2v/utils-c.c
index 8be5150..43d1480 100644
--- a/v2v/utils-c.c
+++ b/v2v/utils-c.c
@@ -38,7 +38,7 @@ v2v_utils_drive_name (value indexv)
   CAMLlocal1 (namev);
   char name[64];
 
-  guestfs___drive_name (Int_val (indexv), name);
+  guestfs_int_drive_name (Int_val (indexv), name);
   namev = caml_copy_string (name);
 
   CAMLreturn (namev);
-- 
1.8.3.1

